<!DOCTYPE html>

<html lang="pl">
<head>
<meta charset="utf-8"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>Furniture Calc ‚Äî wariant/rodzaj</title>
<style>
    :root{
      --bg:#f6f7fb; --card:#fff; --muted:#64748b; --accent:#0ea5e9; --danger:#ff4d4f;
      --shadow:0 6px 20px rgba(2,6,23,0.06); --radius:12px;
      --selected-border:2px solid #0ea5e9;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,system-ui,Arial,sans-serif;background:var(--bg);color:#0f172a}
    header{background:#fff;border-bottom:1px solid #e6eef6;padding:12px 16px;display:flex;align-items:center;gap:12px;position:sticky;top:0;z-index:20;box-shadow:0 2px 6px rgba(0,0,0,0.03)}
    .left{display:flex;align-items:center;gap:8px}
    .btn{background:var(--card);border:1px solid #e6eef6;padding:8px 12px;border-radius:10px;font-weight:700;cursor:pointer}
    .btn:hover{background:#f0f5ff}
    .btn-primary{background:var(--accent);color:#fff;border:none;padding:8px 12px;border-radius:10px;font-weight:800;cursor:pointer}
    .btn-primary:hover{background:#0284c7}
    .btn-danger{background:var(--danger);color:#fff;border:none;padding:6px 10px;border-radius:10px;cursor:pointer}
    .btn:disabled,.btn-danger:disabled,.btn-primary:disabled{opacity:.5;cursor:not-allowed}
    .container{padding:20px;max-width:1200px;margin:0 auto}
    .rooms{display:grid;grid-template-columns:repeat(4,1fr);gap:14px;margin:18px 0}
    .room-btn{background:var(--card);padding:18px;border-radius:16px;display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:pointer;border:1px solid #e6eef6;box-shadow:var(--shadow);transition:transform .12s}
    .room-btn:hover{transform:translateY(-4px)}
    .room-btn span{font-weight:800;margin-top:8px}
    .card{background:var(--card);padding:18px;border-radius:var(--radius);border:1px solid #e6eef6;box-shadow:var(--shadow);margin-bottom:18px}
    label{display:block;font-size:12px;color:var(--muted);font-weight:800;margin-bottom:6px}
    input[type=number], input[type=text], select, textarea{padding:10px;border:1px solid #e6eef6;border-radius:8px;width:100%;font-weight:700}
    input:focus, select:focus, textarea:focus{outline:none;border-color:var(--accent);box-shadow:0 0 0 4px rgba(14,165,233,0.08)}
    .grid-3{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
    .grid-2{display:grid;grid-template-columns:repeat(2,1fr);gap:12px}
    .flex{display:flex;gap:10px;align-items:center}
    .cabinet{border:1px solid #eef6fb;border-radius:12px;padding:0;background:#fff;margin-bottom:12px;box-shadow:0 6px 18px rgba(2,6,23,0.03);transition:box-shadow .12s, transform .12s}
    .cabinet:hover{transform:translateY(-2px)}
    .cabinet.selected{box-shadow:0 10px 30px rgba(14,165,233,0.12); border: var(--selected-border); }
    .cabinet-header{padding:14px;display:flex;justify-content:space-between;align-items:center;cursor:pointer}
    .cabinet-body{padding:14px;border-top:1px solid #eef6fb}
    .muted{color:var(--muted);font-weight:800;font-size:12px}
    .xs{font-size:12px}
    .modal-back{position:fixed;inset:0;background:rgba(0,0,0,0.55);display:none;align-items:center;justify-content:center;z-index:999;}
    .modal{width:100%;max-width:1100px;background:var(--card);border-radius:12px;overflow:hidden;box-shadow:0 18px 60px rgba(2,6,23,0.2)}
    .modal .header{display:flex;align-items:center;justify-content:space-between;padding:14px;border-bottom:1px solid #eef6fb;background:#f8fbff}
    .modal .body{padding:18px;max-height:72vh;overflow:auto}
/* Mobile: make modals fit viewport */
@media (max-width:600px){
  .modal-back{
    align-items:stretch;
    justify-content:stretch;
    padding:0;
  }
  .modal{
    max-width:100vw;
    width:100vw;
    height:100vh;
    border-radius:0;
  }
  .modal .header{
    position:sticky;
    top:0;
    z-index:2;
    padding:12px;
    flex-wrap:wrap;
    gap:10px;
  }
  .modal .body{
    max-height:none;
    height:calc(100vh - 64px);
    padding:12px;
    -webkit-overflow-scrolling:touch;
  }
  .modal .header > div:last-child{
    width:100%;
    justify-content:flex-end;
  }
}
    .list-item{display:flex;justify-content:space-between;align-items:center;padding:10px;border-bottom:1px solid #f1f5f9}
    .muted-tag{font-size:12px;color:#94a3b8}
    .floating-add{position:fixed;right:18px;bottom:18px;width:64px;height:64px;border-radius:50%;background:var(--accent);color:#fff;display:flex;align-items:center;justify-content:center;font-size:30px;box-shadow:0 10px 30px rgba(2,6,23,0.2);cursor:pointer;z-index:500}
    .build-card{padding:28px;text-align:center;border:1px dashed #e6eef6;border-radius:12px;background:#fff;box-shadow:0 6px 18px rgba(2,6,23,0.03)}
    .top-actions{display:flex;gap:8px;align-items:center}
    @media (max-width:900px){.rooms{grid-template-columns:repeat(2,1fr)}}

    /* Cabinet modal extras */
    .choice-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:12px}
    @media (max-width:900px){.choice-grid{grid-template-columns:repeat(2,1fr)}}
    .choice-tile{
      border:1px solid #e6eef6;border-radius:14px;background:#fff;box-shadow:0 6px 18px rgba(2,6,23,0.03);
      padding:14px;cursor:pointer;transition:transform .12s, box-shadow .12s, border-color .12s;
      display:flex;gap:12px;align-items:center;min-height:74px;
    }
    .choice-tile:hover{transform:translateY(-2px);box-shadow:0 10px 26px rgba(2,6,23,0.06)}
    .choice-tile.selected{border-color:var(--accent);box-shadow:0 10px 30px rgba(14,165,233,0.14)}
    .choice-ico{width:40px;height:40px;border-radius:12px;background:#eaf6ff;display:flex;align-items:center;justify-content:center;font-size:22px}
    .choice-title{font-weight:900}
    .choice-sub{font-size:12px;color:var(--muted);font-weight:800;margin-top:2px}
    .section-title{font-weight:900;margin:0 0 10px 0}
    .hr{height:1px;background:#eef6fb;margin:14px 0}

    .mini-tiles{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
    @media (max-width:900px){.mini-tiles{grid-template-columns:repeat(1,1fr)}}
    .mini-tile{
      border:1px solid #e6eef6;border-radius:14px;background:#fff;box-shadow:0 6px 18px rgba(2,6,23,0.03);
      padding:14px;cursor:pointer;transition:transform .12s, box-shadow .12s, border-color .12s;
    }
    .mini-tile:hover{transform:translateY(-2px)}
    .mini-tile.selected{border-color:var(--accent);box-shadow:0 10px 30px rgba(14,165,233,0.14)}
    .mini-head{display:flex;gap:10px;align-items:center}
    .mini-svg{width:56px;height:40px}
    .mini-title{font-weight:900}
    .mini-desc{font-size:12px;color:var(--muted);font-weight:800;margin-top:6px;line-height:1.35}
    .cab-actions{display:flex;gap:8px;align-items:center}

    /* Read-only rows */
    .ro-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
    @media (max-width:900px){.ro-grid{grid-template-columns:repeat(2,1fr)}}
    .ro-box{border:1px solid #eef6fb;border-radius:10px;padding:10px;background:#fbfdff}
    .ro-val{font-weight:900}

    .badge{
      display:inline-flex;align-items:center;gap:6px;
      padding:4px 8px;border-radius:999px;
      background:#eaf6ff;border:1px solid rgba(14,165,233,0.35);
      font-size:12px;font-weight:900;color:#0369a1;
      margin-left:8px;
    }

    .front-block{
      margin:-6px 0 12px 0;
      border:1px solid #eef6fb;
      border-radius:12px;
      overflow:hidden;
      background:#fbfdff;
    }
    .front-block .head{
      display:flex;justify-content:space-between;align-items:center;
      padding:10px 12px;
      border-bottom:1px solid #eef6fb;
      background:#f3f9ff;
      font-weight:900;
    }
    .front-row{
      display:flex;justify-content:space-between;align-items:center;
      padding:10px 12px;
      border-bottom:1px solid #eef6fb;
    }
    .front-row:last-child{border-bottom:none}
    .front-meta{font-size:12px;color:#64748b;font-weight:800}
  

.warn-orange{
  display:none;
  padding:8px 10px;
  border-radius:10px;
  background:#ffedd5;
  border:1px solid #fb923c;
  color:#9a3412;
  font-weight:900;
}

/* quick focus highlight for jump buttons */
.focus-flash{
  animation: focusFlash 1.2s ease-out 1;
  outline: 3px solid #2aa9ff;
  outline-offset: 2px;
}
@keyframes focusFlash{
  0%{ outline-color: rgba(42,169,255,0.0); box-shadow: 0 0 0 rgba(0,0,0,0); }
  20%{ outline-color: rgba(42,169,255,0.95); box-shadow: 0 0 0 6px rgba(42,169,255,0.15); }
  100%{ outline-color: rgba(42,169,255,0.0); box-shadow: 0 0 0 rgba(0,0,0,0); }
}



.assy-wrap{margin-top:14px;border:1px solid #eef6fb;border-radius:12px;overflow:hidden;background:#fbfdff}
.assy-head{padding:10px 12px;border-bottom:1px solid #eef6fb;background:#f3f9ff;font-weight:900;display:flex;justify-content:space-between;align-items:center;gap:10px}
.assy-body{padding:12px}
.assy-note{margin-top:10px;line-height:1.45}
.assy-note div{margin:2px 0}



    /* Prevent background scroll when modal open (mobile fixes) */
    html.modal-lock, body.modal-lock{overflow:hidden;height:100%;}
    .modal-back{touch-action:none;overscroll-behavior:contain;}
    .modal{touch-action:auto;}



/* ===== RYSUNEK (import) ===== */
.drawing-wrap{ display:flex; flex-direction:column; gap:12px; }
    .drawing-toolbar{
      display:flex; flex-wrap:wrap; gap:8px; align-items:center;
      padding:10px 12px; border:1px solid #eef6fb; border-radius:12px; background:#fbfdff;
    }
    .drawing-toolbar .group{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .drawing-toolbar .pill{
      padding:6px 10px; border-radius:999px; border:1px solid #e5eef7;
      background:#fff; font-size:12px; font-weight:800;
    }
    .drawing-stage{
      border:1px solid #eef6fb; border-radius:14px; background:#fff;
      padding:10px; overflow:auto;
    }
    .drawing-stage svg{ display:block; }
    .svg-cab{ fill:#eaf4ff; stroke:#1e4b8f; stroke-width:1; cursor:pointer; }
    .svg-gap{ fill:#ffffff; stroke:#94a3b8; stroke-width:1; stroke-dasharray:4 4; cursor:pointer; }
    .svg-cab.selected{ fill:#d9f2ff; stroke:#0ea5e9; stroke-width:2; }
    .svg-range{ fill:rgba(14,165,233,0.14); stroke:#0ea5e9; stroke-width:2; }
    .svg-label{ font-size:14px; fill:#0f172a; pointer-events:none; font-weight:800; }
    .svg-finish{ fill:rgba(2,132,199,0.15); stroke:#0284c7; stroke-width:2; pointer-events:none; }
    .svg-finish-strong{ fill:rgba(16,185,129,0.16); stroke:#10b981; stroke-width:2; pointer-events:none; }
    .ctxmenu{
      position:absolute; z-index:50; min-width:260px;
      background:#fff; border:1px solid #e5eef7; border-radius:14px;
      box-shadow:0 10px 30px rgba(2,6,23,0.10);
      padding:10px;
    }
    .ctxmenu h4{ margin:0 0 8px 0; font-size:13px; }
    .ctxmenu .actions{ display:flex; flex-direction:column; gap:6px; }
    .ctxmenu .actions button{ width:100%; text-align:left; }
    .finish-list{ display:flex; flex-direction:column; gap:8px; }
    .finish-item{
      display:flex; justify-content:space-between; gap:10px; align-items:flex-start;
      padding:10px 12px; border:1px solid #eef6fb; border-radius:12px; background:#fbfdff;
    }
    .finish-item .meta{ font-size:12px; }
    .finish-item .meta b{ display:block; margin-bottom:2px; }
    .finish-item .meta .muted{ margin:0; }


</style>
</head>
<body>
<header>
<div class="left">
<button class="btn" id="backToRooms">‚ü≤</button>
<nav id="topTabs" style="display:none; margin-left:8px;">
<button class="btn tab-btn" data-tab="wywiad">WYWIAD</button>
<button class="btn tab-btn" data-tab="rysunek">RYSUNEK</button>
<button class="btn tab-btn" data-tab="material">MATERIA≈Å</button>
<button class="btn tab-btn" data-tab="czynnosci">CZYNNO≈öCI</button>
<button class="btn tab-btn" data-tab="wycena">WYCENA</button>
</nav>
</div>
<div style="margin-left:auto;display:flex;gap:8px;align-items:center">
<button class="btn" id="openMaterialsBtn">Cennik Materia≈Ç√≥w</button>
<button class="btn" id="openServicesBtn">Cennik Us≈Çug</button>
</div>
</header>
<div class="container">
<div id="roomsView">
<div style="display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:12px">
<div>
<h2 style="margin:0">Wybierz pomieszczenie</h2>
<p class="muted" style="margin:4px 0 0">Kliknij kafelek aby wej≈õƒá w edycjƒô</p>
</div>
<div class="top-actions">
<button class="btn-danger" id="newProjectBtn">Nowy projekt</button>
</div>
</div>
<div class="rooms">
<div class="room-btn" data-room="kuchnia"><div style="font-size:28px">üç≥</div><span>Kuchnia</span></div>
<div class="room-btn" data-room="szafa"><div style="font-size:28px">üö™</div><span>Szafa</span></div>
<div class="room-btn" data-room="pokoj"><div style="font-size:28px">üè†</div><span>Pok√≥j</span></div>
<div class="room-btn" data-room="lazienka"><div style="font-size:28px">üõÅ</div><span>≈Åazienka</span></div>
</div>
</div>
<div id="appView" style="display:none">
<div class="card">
<h3 id="roomTitle">Pomieszczenie</h3>
<div class="grid-3" style="margin-top:12px">
<div>
<label>Wys. Pomieszczenia (cm)</label>
<input id="roomHeight" type="number"/>
</div>
<div>
<label>Wys. Do≈Çu z nogami (cm)</label>
<input id="bottomHeight" type="number"/>
</div>
<div>
<label>Wys. N√≥≈ºek (cm)</label>
<input id="legHeight" type="number"/>
</div>
<div>
<label>Gr. Blatu (cm)</label>
<input id="counterThickness" step="0.1" type="number"/>
</div>
<div>
<label>Odstƒôp (Gap) (cm)</label>
<input id="gapHeight" type="number"/>
</div>
<div>
<label>Blenda G√≥ra (cm)</label>
<input id="ceilingBlende" type="number"/>
</div>
</div>
<div class="muted xs" style="margin-top:12px">Auto-wysoko≈õƒá g√≥ry: <strong id="autoTopHeight">0</strong> cm</div>
</div>
<div class="card" style="margin-top:12px">
<div style="display:flex;justify-content:space-between;align-items:center">
<h3 style="margin:0">Szafki</h3>
</div>
<div id="cabinetsList" style="margin-top:14px"></div>
<!-- Ukryte, bo fronty pokazujemy pod zestawami / pod lod√≥wkowƒÖ -->
<div id="frontsSection" style="display:none">
<div class="hr"></div>
<div style="display:flex;justify-content:space-between;align-items:center">
<h3 style="margin:0">Fronty</h3>
<div class="muted xs">Fronty dodawane przy zestawach</div>
</div>
<div id="frontsList" style="margin-top:14px"></div>
</div>
</div>
</div>
</div>
<!-- PRICE MODAL -->
<div aria-modal="true" class="modal-back" id="priceModal" role="dialog">
<div class="modal">
<div class="header">
<div style="display:flex;gap:12px;align-items:center">
<div id="priceModalIcon">üì¶</div>
<div>
<div id="priceModalTitle" style="font-weight:900"></div>
<div class="muted-tag xs" id="priceModalSubtitle"></div>
</div>
</div>
<div style="display:flex;gap:8px;align-items:center">
<input id="priceSearch" placeholder="Wyszukaj pozycjƒô..." style="padding:8px;border-radius:8px;border:1px solid #eef6fb"/>
<button class="btn" id="closePriceModal">Zamknij</button>
</div>
</div>
<div class="body">
<div class="card" style="margin-bottom:12px">
<div style="display:flex;justify-content:space-between;align-items:center">
<div id="priceFormTitle" style="font-weight:900">Dodaj pozycjƒô</div>
<div class="muted xs" id="editingIndicator" style="display:none">EDYTUJ</div>
</div>
<div style="margin-top:12px">
<div id="materialFormFields" style="display:none">
<div class="grid-3">
<div>
<label>Typ materia≈Çu</label>
<select id="formMaterialType"></select>
</div>
<div>
<label>Producent</label>
<select id="formManufacturer"></select>
</div>
<div>
<label>Symbol</label>
<input id="formSymbol" type="text"/>
</div>
</div>
<div style="margin-top:10px">
<label>Nazwa</label>
<input id="formName" type="text"/>
</div>
<div class="grid-2" style="margin-top:10px">
<div>
<label>Cena (PLN)</label>
<input id="formPrice" step="0.01" type="number"/>
</div>
<div style="display:flex;align-items:end;gap:8px">
<button class="btn-primary" id="savePriceBtn">Zapisz</button>
<button class="btn" id="cancelEditBtn" style="display:none">Anuluj</button>
</div>
</div>
</div>
<div id="serviceFormFields" style="display:none">
<div class="grid-3">
<div>
<label>Kategoria</label>
<input id="formCategory" type="text" value="Monta≈º"/>
</div>
<div style="grid-column:span 2">
<label>Nazwa</label>
<input id="formServiceName" type="text"/>
</div>
</div>
<div class="grid-2" style="margin-top:10px">
<div>
<label>Cena (PLN)</label>
<input id="formServicePrice" step="0.01" type="number"/>
</div>
<div style="display:flex;align-items:end;gap:8px">
<button class="btn-primary" id="saveServiceBtn">Zapisz</button>
<button class="btn" id="cancelServiceEditBtn" style="display:none">Anuluj</button>
</div>
</div>
</div>
</div>
</div>
<div class="card" id="priceListContainer">
<div id="priceListItems"></div>
</div>
</div>
</div>
</div>
<!-- CABINET ADD/EDIT MODAL -->
<div aria-modal="true" class="modal-back" id="cabinetModal" role="dialog">
<div class="modal">
<div class="header">
<div style="display:flex;gap:12px;align-items:center">
<div id="cabinetModalIcon">‚ûï</div>
<div>
<div id="cabinetModalTitle" style="font-weight:900">Dodaj</div>
<div class="muted-tag xs" id="cabinetModalSubtitle">Wybierz rodzaj / zestaw</div>
</div>
</div>
<div style="display:flex;gap:8px;align-items:center">
<button type="button" class="btn-primary" id="cabinetModalSave" style="display:none">Zatwierd≈∫</button>
<button type="button" class="btn" id="closeCabinetModal">Zamknij</button>
</div>
</div>
<div class="body">
<div class="card" id="cabinetChoiceCard" style="margin-bottom:12px">
<h3 class="section-title" style="margin:0 0 10px 0">Wybierz co dodajesz</h3>
<div class="choice-grid" id="cabinetTypeChoices"></div>
</div>
<div id="cabinetFormArea" style="display:none">
<div class="card" style="margin-bottom:12px">
<h3 class="section-title" style="margin:0 0 10px 0">Konfiguracja</h3>
<!-- USUNIƒòTO "Rodzaj" (wybierasz na kafelku +) -->
<div class="grid-3">
<div>
<label>Wariant</label>
<select id="cmSubType"></select>
</div>
<div>
<div id="cmFrontCountWrap">
<label id="cmFrontCountLabel">Ilo≈õƒá front√≥w</label>
<select id="cmFrontCount"></select>
<div class="muted-tag xs" id="cmFrontCountStatic" style="display:none;margin-top:8px"></div>
<div class="muted xs" id="cmFrontCountHint" style="margin-top:6px;display:none">
                  Ilo≈õƒá front√≥w dopasowana automatycznie dla tej szafki.
                </div>
</div>
<div id="cmFlapWrap" style="display:none">
<label>Firma</label>
<select id="cmFlapVendor">
<option value="blum">BLUM AVENTOS</option>
<option value="gtv">GTV</option>
<option value="hafele">H√§fele</option>
</select>
<div id="cmFlapKindWrap" style="margin-top:10px">
<label>Rodzaj</label>
<select id="cmFlapKind"></select>
</div>
<div class="muted-tag xs" id="cmFlapFrontInfo" style="margin-top:8px;display:none"></div>
<div class="muted xs" id="cmFlapInfo" style="margin-top:6px;display:none"></div>
</div>
<div id="cmShelvesWrap" style="display:none">
<label>P√≥≈Çki (szt.)</label>
<input id="cmShelves" min="0" step="1" type="number"/>
<div class="muted xs" style="margin-top:6px">Ile p√≥≈Çek ma byƒá w ≈õrodku (do wyceny i rozrysu).</div>
</div>
</div>
<div>
<label>¬†</label>
<div class="muted xs" id="cmHint" style="padding:10px;border:1px solid #eef6fb;border-radius:8px;background:#fbfdff">
                Wybierz wariant aby zobaczyƒá szczeg√≥≈Çy.
              </div>
</div>
</div>
<div id="cmExtraDetails" style="margin-top:12px"></div>
<div class="hr"></div>
<div class="grid-3" id="cmDims">
<div><label>Szeroko≈õƒá</label><input id="cmWidth" step="0.1" type="number"/></div>
<div><label>Wysoko≈õƒá</label><input id="cmHeight" step="0.1" type="number"/></div>
<div><label>G≈Çƒôboko≈õƒá</label><input id="cmDepth" step="0.1" type="number"/></div>
</div>
<div class="hr"></div>
<div class="grid-3" style="gap:12px">
<div>
<label>Materia≈Ç Frontu</label>
<select id="cmFrontMaterial">
<option value="laminat">Laminat</option>
<option value="akryl">Akryl</option>
<option value="lakier">Lakier</option>
</select>
</div>
<div>
<label>Kolor Frontu</label>
<select id="cmFrontColor"></select>
</div>
<div>
<label>Plecy</label>
<select id="cmBackMaterial">
<option value="HDF 3mm bia≈Ça">HDF 3mm bia≈Ça</option>
<option value="18 mm pod kolor korpusu">18 mm pod kolor</option>
<option value="Brak">Brak plec√≥w</option>
</select>
</div>
<div>
<label>Korpus</label>
<select id="cmBodyColor"></select>
</div>
<div>
<label>Otwieranie</label>
<select id="cmOpeningSystem"></select>
</div>
<div></div>
</div>
</div>
<!-- Przyciski: Zatwierd≈∫ jest na g√≥rze obok Zamknij (zawsze widoczny). -->
</div>
<div id="setWizardArea" style="display:none">
<div class="card" style="margin-bottom:12px">
<h3 class="section-title" id="setWizardTitle" style="margin:0 0 10px 0">Zestaw</h3>
<div class="muted xs" id="setWizardDesc" style="margin-bottom:12px;line-height:1.35">
            Wybierz standardowy uk≈Çad. Program doda kilka korpus√≥w oraz fronty.
          </div>
<div class="mini-tiles" id="setTiles"></div>
<div class="hr"></div>
<div class="grid-3" id="setParams" style="display:none"></div>
<div class="hr"></div>
<div id="setFrontBlock" style="display:none">
<h3 class="section-title" style="margin:0 0 10px 0">Fronty w zestawie</h3>
<div class="grid-3">
<div>
<label>Ilo≈õƒá front√≥w</label>
<select id="setFrontCount">
<option value="1">1</option>
<option value="2">2</option>
</select>
</div>
<div>
<label>Materia≈Ç front√≥w</label>
<select id="setFrontMaterial">
<option value="laminat">Laminat</option>
<option value="akryl">Akryl</option>
<option value="lakier">Lakier</option>
</select>
</div>
<div>
<label>Kolor front√≥w</label>
<select id="setFrontColor"></select>
</div>
</div>
<div class="muted xs" id="setFrontHint" style="margin-top:10px;padding:10px;border:1px solid #eef6fb;border-radius:10px;background:#fbfdff">
              Wybierz 1 lub 2 fronty dla tego zestawu.
            </div>
</div>
</div>
<div style="display:flex;justify-content:flex-end;gap:8px">
<button class="btn" id="setWizardCancel">Anuluj</button>
<button class="btn-primary" id="setWizardCreate">Dodaj zestaw</button>
</div>
</div>
</div>
</div>
</div>
<!-- floating add button -->
<div class="floating-add" id="floatingAdd" title="Dodaj">+</div>
<script>
/* ===== Storage keys and defaults ===== */
const STORAGE_KEYS = {
  materials: 'fc_materials_v1',
  services: 'fc_services_v1',
  projectData: 'fc_project_v1',
  ui: 'fc_ui_v1',
};

/** App namespace to reduce globals and keep concerns separated. */
const FC = (function(){
  'use strict';

  /* ===== Module: utils ===== */
  const utils = {
    uid(){
      // Prefer cryptographically strong UUIDs when available.
      if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') return crypto.randomUUID();
      // Fallback: time + random (kept for older browsers).
      return 'id_' + Date.now() + '_' + Math.floor(Math.random() * 1e9);
    },
    clone(x){
      // Prefer structuredClone when available; fallback to JSON for plain data.
      if (typeof structuredClone === 'function') return structuredClone(x);
      return JSON.parse(JSON.stringify(x));
    },
    num(v, fallback){
      const n = Number(v);
      return Number.isFinite(n) ? n : fallback;
    },
    isPlainObject(v){
      return !!v && typeof v === 'object' && (v.constructor === Object || Object.getPrototypeOf(v) === null);
    }
  };

  /* ===== Module: storage ===== */
  const storage = {
    getJSON(key, fallback){
      try{
        const raw = localStorage.getItem(key);
        if (!raw) return utils.clone(fallback);
        return JSON.parse(raw);
      }catch(e){
        return utils.clone(fallback);
      }
    },
    setJSON(key, value){
      try{
        localStorage.setItem(key, JSON.stringify(value));
      }catch(e){}
    }
  };

  /* ===== Module: project schema + migrations ===== */
  const CURRENT_SCHEMA_VERSION = 9;

  const DEFAULT_PROJECT = {
    schemaVersion: CURRENT_SCHEMA_VERSION,
    kuchnia: { cabinets: [], fronts: [], sets: [], settings: { roomHeight: 250, bottomHeight: 82, legHeight: 10, counterThickness: 3.8, gapHeight: 60, ceilingBlende: 10 } },
    szafa: { cabinets: [], fronts: [], sets: [], settings: { roomHeight: 250, bottomHeight: 82, legHeight: 10, counterThickness: 1.8, gapHeight: 0, ceilingBlende: 5 } },
    pokoj: { cabinets: [], fronts: [], sets: [], settings: { roomHeight: 250, bottomHeight: 82, legHeight: 5, counterThickness: 1.8, gapHeight: 0, ceilingBlende: 0 } },
    lazienka: { cabinets: [], fronts: [], sets: [], settings: { roomHeight: 220, bottomHeight: 82, legHeight: 15, counterThickness: 2, gapHeight: 0, ceilingBlende: 0 } }
  };

  const ROOMS = ['kuchnia','szafa','pokoj','lazienka'];

  function migrateV1toV2(data){
    // v1 had no schemaVersion. v2 introduces schemaVersion at root.
    const out = utils.clone(data || {});
    out.schemaVersion = 2;
    return out;
  }


  function migrateV2toV3(data){
    // v3: sensible defaults for base cabinet height & kitchen legs
    const out = utils.clone(data || {});
    for (const r of ROOMS){
      const room = out[r] = utils.isPlainObject(out[r]) ? out[r] : {};
      const settings = room.settings = utils.isPlainObject(room.settings) ? room.settings : {};
      const bh = Number(settings.bottomHeight);
      if (!Number.isFinite(bh) || bh <= 0) settings.bottomHeight = 82;

      if (r === 'kuchnia'){
        const lh = Number(settings.legHeight);
        if (!Number.isFinite(lh) || lh <= 0) settings.legHeight = 10;
      }
    }
    out.schemaVersion = 3;
    return out;
  }

  
  function migrateV3toV4(data){
    // v4: standing standard cabinets get explicit inside mode + internal drawer defaults
    const out = utils.clone(data || {});
    for (const r of ROOMS){
      const room = out[r] = utils.isPlainObject(out[r]) ? out[r] : {};
      const cabinets = Array.isArray(room.cabinets) ? room.cabinets : [];
      for (const cab of cabinets){
        if(!cab || typeof cab !== 'object') continue;
        if(cab.type === 'stojƒÖca' && (cab.subType || 'standardowa') === 'standardowa'){
          cab.details = utils.isPlainObject(cab.details) ? cab.details : {};
          if(!('insideMode' in cab.details)) cab.details.insideMode = 'polki';
          if(!('innerDrawerCount' in cab.details)) cab.details.innerDrawerCount = '1';
          if(!('innerDrawerType' in cab.details)) cab.details.innerDrawerType = 'blum';
        }
        if(cab.type === 'stojƒÖca' && (cab.subType || '') === 'piekarnikowa'){
          cab.details = utils.isPlainObject(cab.details) ? cab.details : {};
          if(!('ovenOption' in cab.details)) cab.details.ovenOption = 'szuflada_dol';
          const oh = Number(cab.details.ovenHeight);
          if(!('ovenHeight' in cab.details) || !isFinite(oh) || oh <= 0) cab.details.ovenHeight = '60';
          const tc = parseInt(cab.details.techShelfCount, 10);
          if(!('techShelfCount' in cab.details) || !Number.isFinite(tc) || tc <= 0) cab.details.techShelfCount = '1';
          const sh = Number(cab.details.shelves);
          if(!('shelves' in cab.details) || !isFinite(sh) || sh < 0) cab.details.shelves = 0;
        }
      }
    }
    out.schemaVersion = 4;
    return out;
  }


  function migrateV4toV5(data){
    // v5: standing oven cabinets shouldn't default to 1 shelf in summaries; set shelves to 0 unless explicitly meaningful.
    const out = utils.clone(data || {});
    for (const r of ROOMS){
      const room = utils.isPlainObject(out[r]) ? out[r] : {};
      const cabs = Array.isArray(room.cabinets) ? room.cabinets : [];
      for (const cab of cabs){
        if(!cab || typeof cab !== 'object') continue;
        if(cab.type === 'stojƒÖca' && (cab.subType || '') === 'piekarnikowa'){
          cab.details = utils.isPlainObject(cab.details) ? cab.details : {};
          // If shelves is missing or equals 1 (legacy default), normalize to 0 to avoid misleading UI.
          const sh = Number(cab.details.shelves);
          if(!('shelves' in cab.details) || !isFinite(sh) || sh === 1){
            cab.details.shelves = 0;
          }
        }
      }
    }
    out.schemaVersion = 5;
    return out;
  }

function normalizeRoom(roomRaw, roomDefault){
    const room = utils.isPlainObject(roomRaw) ? roomRaw : {};
    const def = roomDefault;

    const cabinets = Array.isArray(room.cabinets) ? room.cabinets : [];
    const fronts   = Array.isArray(room.fronts)   ? room.fronts   : [];
    const sets     = Array.isArray(room.sets)     ? room.sets     : [];

    const sRaw = utils.isPlainObject(room.settings) ? room.settings : {};
    const sDef = def.settings;

    const settings = {
      roomHeight: utils.num(sRaw.roomHeight, sDef.roomHeight),
      bottomHeight: utils.num(sRaw.bottomHeight, sDef.bottomHeight),
      legHeight: utils.num(sRaw.legHeight, sDef.legHeight),
      counterThickness: utils.num(sRaw.counterThickness, sDef.counterThickness),
      gapHeight: utils.num(sRaw.gapHeight, sDef.gapHeight),
      ceilingBlende: utils.num(sRaw.ceilingBlende, sDef.ceilingBlende),
    };

    // Derived/normalized cabinet fields that depend on room settings.
    const calcTechDividers = (frontH) => {
      const fh = Number(frontH) || 0;
      if(!(fh > 74.5)) return 0;
      // 74.6‚Äì76.5 => 1; 76.6‚Äì78.5 => 2; ...
      return Math.max(0, Math.ceil(((fh - 74.5) / 2) - 1e-9));
    };

    const leg = Number(settings.legHeight) || 0;
    const bottomFrontH = Math.max(0, (Number(settings.bottomHeight) || 0) - leg);

    const normCabinets = cabinets.map((c) => {
      if(!utils.isPlainObject(c)) return c;
      const cab = { ...c };
      const d = utils.isPlainObject(cab.details) ? { ...cab.details } : {};

      if(cab.subType === 'zmywarkowa'){
        const frontH = (Number(cab.height) || 0) - leg;
        d.techDividerCount = String(calcTechDividers(frontH));
        d.shelves = 0;
        cab.frontCount = 1;
      }

      if(cab.subType === 'lodowkowa'){
        const opt = d.fridgeOption ? String(d.fridgeOption) : 'zabudowa';
        if(opt === 'zabudowa'){
          const div = calcTechDividers(bottomFrontH);
          d.techDividerCount = String(div);
          d.shelves = 0;
          const bh = Number(settings.bottomHeight) || 0;
          const lh = Number(settings.legHeight) || 0;
          const nh = Number(d.fridgeNicheHeight) || 0;
          // Wysoko≈õƒá lod√≥wkowej (zabudowa): nisza + (przegrody*1.8) + 3.6 + n√≥≈ºki
          if(nh > 0){
            cab.height = nh + (div * 1.8) + 3.6 + lh;
          }
        } else {
          d.techDividerCount = '0';
          d.shelves = 0;
        }
      }

      
      if(cab.subType === 'szuflady'){
        // ujednolicenie p√≥l dla szuflad stojƒÖcych
        let lay = String(d.drawerLayout || '');
        if(!lay){
          const legacy = String(d.drawerCount || '3');
          if(legacy === '1') lay = '1_big';
          else if(legacy === '2') lay = '2_equal';
          else if(legacy === '3') lay = '3_1_2_2';
          else if(legacy === '5') lay = '5_equal';
          else lay = '3_equal';
        }
        d.drawerLayout = lay;
        if(!d.drawerSystem) d.drawerSystem = 'skrzynkowe';
      if(!d.drawerBrand) d.drawerBrand = 'blum';
      if(!d.drawerModel) d.drawerModel = 'tandembox';
        if(!('innerDrawerType' in d)) d.innerDrawerType = 'brak';
        if(!('innerDrawerCount' in d) || d.innerDrawerCount == null){
          d.innerDrawerCount = (lay === '3_equal') ? '3' : '2';
        }
        // limity: max 2 (dla 1/2/1:2:2), max 3 (dla 3_equal), brak (dla 5_equal)
        if(lay === '5_equal'){
          d.innerDrawerType = 'brak';
          d.innerDrawerCount = '0';
        } else if(lay === '3_equal'){
          const n = Math.min(3, Math.max(0, parseInt(d.innerDrawerCount, 10) || 0));
          d.innerDrawerCount = String(n > 0 ? n : 3);
        } else {
          const n = Math.min(2, Math.max(0, parseInt(d.innerDrawerCount, 10) || 0));
          d.innerDrawerCount = String(n > 0 ? n : 2);
        }

        // ustaw frontCount zgodnie z uk≈Çadem
        let fc = 3;
        if(lay === '1_big') fc = 1;
        else if(lay === '2_equal') fc = 2;
        else if(lay === '3_equal') fc = 3;
        else if(lay === '5_equal') fc = 5;
        else if(lay === '3_1_2_2') fc = 3;
        cab.frontCount = fc;
      }
cab.details = d;
      return cab;
    });

    return { cabinets: normCabinets, fronts, sets, settings };
  }

  
  function migrateV5toV6(data){
    // v6: add technical shelf for standing oven cabinets (piekarnikowa)
    // Legacy "shelves" (often default 1) is treated as technical shelf count, and user shelves are reset to 0.
    const out = utils.clone(data || {});
    for (const r of ROOMS){
      const room = utils.isPlainObject(out[r]) ? out[r] : {};
      const cabs = Array.isArray(room.cabinets) ? room.cabinets : [];
      for (const cab of cabs){
        if(!cab || typeof cab !== 'object') continue;
        if(cab.type === 'stojƒÖca' && (cab.subType || '') === 'piekarnikowa'){
          cab.details = utils.isPlainObject(cab.details) ? cab.details : {};
          const sh = Number(cab.details.shelves);
          // move legacy shelves -> techShelfCount (default 1)
          if(!('techShelfCount' in cab.details)){
            if(isFinite(sh) && sh > 0){
              cab.details.techShelfCount = String(Math.round(sh));
            } else {
              cab.details.techShelfCount = '1';
            }
          }
          // user shelves for oven cabinet default to 0 (separate from tech shelf)
          cab.details.shelves = 0;
        }
      }
    }
    out.schemaVersion = 6;
    return out;
  }

  function migrateV6toV7(data){
    // v7: zlewowa ‚Äî replace legacy sinkOption with structured fields (sinkFront/sinkDoorCount/sinkExtra)
    const out = utils.clone(data);
    for (const r of ROOMS){
      const room = utils.isPlainObject(out[r]) ? out[r] : {};
      const cabs = Array.isArray(room.cabinets) ? room.cabinets : [];
      cabs.forEach(c => {
        if(!c || c.type !== 'stojƒÖca' || c.subType !== 'zlewowa') return;
        c.details = utils.isPlainObject(c.details) ? c.details : {};
        const d = c.details;

        if(!d.sinkFront){
          if(d.sinkOption === 'zwykle_drzwi') d.sinkFront = 'drzwi';
          else if(d.sinkOption === 'szuflada') d.sinkFront = 'szuflada';
          else if(d.sinkOption === 'szuflada_i_polka'){ d.sinkFront = 'szuflada'; d.sinkExtra = d.sinkExtra || 'polka'; }
          else d.sinkFront = 'drzwi';
        }
        if(!d.sinkDoorCount) d.sinkDoorCount = String([1,2].includes(Number(c.frontCount)) ? Number(c.frontCount) : 2);
        if(!d.sinkExtra) d.sinkExtra = 'brak';
        if(d.sinkExtraCount == null) d.sinkExtraCount = 1;
        if(!d.sinkInnerDrawerType) d.sinkInnerDrawerType = 'skrzynkowe';
      if(!d.sinkInnerDrawerBrand) d.sinkInnerDrawerBrand = 'blum';
      if(!d.sinkInnerDrawerModel) d.sinkInnerDrawerModel = 'tandembox';

        // ustaw frontCount zgodnie z wyborem
        if(d.sinkFront === 'szuflada'){
          c.frontCount = 1;
        } else {
          const dc = Number(d.sinkDoorCount) || 2;
          c.frontCount = (dc === 1 ? 1 : 2);
        }
      });
      room.cabinets = cabs;
      out[r] = room;
    }
    out.schemaVersion = 7;
    return out;
  }

function migrateV7toV8(data){
  // v8: zmywarkowa ‚Äî width selector sync + technical divider count for tall fronts
  const out = utils.clone(data);
  for (const r of ROOMS){
    const room = utils.isPlainObject(out[r]) ? out[r] : {};
    const cabs = Array.isArray(room.cabinets) ? room.cabinets : [];
    const leg = utils.num(room.settings && room.settings.legHeight, utils.num(DEFAULT_PROJECT[r]?.settings?.legHeight, 0));

    cabs.forEach(c => {
      if(!c || c.type !== 'stojƒÖca' || c.subType !== 'zmywarkowa') return;
      c.details = utils.isPlainObject(c.details) ? c.details : {};
      const d = c.details;

      // Width selector default
      let w = d.dishWasherWidth;
      const cw = utils.num(c.width, 0);
      if(!w){
        if(cw === 45) w = '45';
        else if(cw === 60) w = '60';
        else w = '60';
        d.dishWasherWidth = w;
      }
      // Sync cabinet width to selector
      const wn = utils.num(d.dishWasherWidth, 60);
      if(wn) c.width = wn;

      // Technical dividers: 74.6‚Äì76.5 => 1; 76.6‚Äì78.5 => 2; itd.
      const frontH = utils.num(c.height, 0) - leg;
      const div = (frontH > 74.5) ? Math.max(0, Math.ceil(((frontH - 74.5) / 2) - 1e-9)) : 0;
      d.techDividerCount = String(div);
      // Dishwasher cabinet has no standard shelves
      if(d.shelves == null || utils.num(d.shelves, 0) !== 0) d.shelves = 0;
    });
  }
  out.schemaVersion = 9;
  return out;
}




function normalizeProject(raw){
    let data = utils.isPlainObject(raw) ? raw : {};
    let ver = utils.num(data.schemaVersion, 1);
    if (ver < 1) ver = 1;

    // Stepwise migrations.
    if (ver < 2) data = migrateV1toV2(data);
    if (ver < 3) data = migrateV2toV3(data);
    if (ver < 4) data = migrateV3toV4(data);
    if (ver < 5) data = migrateV4toV5(data);
    if (ver < 6) data = migrateV5toV6(data);
    if (ver < 7) data = migrateV6toV7(data);
    if (ver < 8) data = migrateV7toV8(data);

    const out = { schemaVersion: CURRENT_SCHEMA_VERSION };
    for (const r of ROOMS){
      out[r] = normalizeRoom(data[r], DEFAULT_PROJECT[r]);
    }

    // Keep unknown root-level fields for forward compatibility.
    for (const k of Object.keys(data)){
      if (!(k in out)) out[k] = data[k];
    }
    return out;
  }

  const project = {
    CURRENT_SCHEMA_VERSION,
    DEFAULT_PROJECT,
    load(){
      const raw = storage.getJSON(STORAGE_KEYS.projectData, DEFAULT_PROJECT);
      return normalizeProject(raw);
    },
    save(data){
      const normalized = normalizeProject(data);
      storage.setJSON(STORAGE_KEYS.projectData, normalized);
      return normalized;
    },
    normalize: normalizeProject,
  };

  return { utils, storage, project };
})();
const DEFAULT_PROJECT = FC.project.DEFAULT_PROJECT;

/* ===== State initialization ===== */
let materials = FC.storage.getJSON(STORAGE_KEYS.materials, [
  { id: 'm1', materialType: 'laminat', manufacturer: 'Egger', symbol: 'W1100', name: 'Egger W1100 ST9 Bia≈Çy Alpejski', price: 35 },
  { id: 'm2', materialType: 'akryl', manufacturer: 'Rehau', symbol: 'A01', name: 'Akryl Bia≈Çy', price: 180 },
  { id: 'm3', materialType: 'akcesoria', manufacturer: 'blum', symbol: 'B1', name: 'Zawias Blum', price: 18 }
]);
let services = FC.storage.getJSON(STORAGE_KEYS.services, [ { id: 's1', category: 'Monta≈º', name: 'Monta≈º Express', price: 120 } ]);
let projectData = FC.project.load();
let uiState = FC.storage.getJSON(STORAGE_KEYS.ui, { activeTab:'wywiad', roomType:null, showPriceList:null, expanded:{}, matExpandedId:null, searchTerm:'', editingId:null, selectedCabinetId:null });

const MANUFACTURERS = {
  laminat: ['Egger','KronoSpan','Swiss Krono','Woodeco'],
  akryl: ['Rehau','manufaktura ≈Åom≈ºa'],
  lakier: ['elektronowa','Pol-wi√≥r'],
  blat: ['Egger','KronoSpan','Swiss Krono','Woodeco'],
  akcesoria: ['blum','GTV','Peka','Rejs','Nomet','H√§fele','Sevroll','Laguna','Hettich']
};

/* ===== Normalize (backward compatibility) ===== */
function normalizeProjectData(){
  ['kuchnia','szafa','pokoj','lazienka'].forEach(r=>{
    if(!projectData[r]) projectData[r] = FC.utils.clone(DEFAULT_PROJECT[r]);
    if(!Array.isArray(projectData[r].cabinets)) projectData[r].cabinets = [];
    if(!projectData[r].settings) projectData[r].settings = FC.utils.clone(DEFAULT_PROJECT[r].settings);
    if(!Array.isArray(projectData[r].fronts)) projectData[r].fronts = [];
    if(!Array.isArray(projectData[r].sets)) projectData[r].sets = [];

    // numeracja zestaw√≥w je≈õli brak
    let n = 1;
    projectData[r].sets.forEach(s=>{
      if(typeof s.number !== 'number'){
        s.number = n;
      }
      n = Math.max(n, s.number + 1);
    });

    const map = new Map(projectData[r].sets.map(s=>[s.id, s.number]));
    projectData[r].cabinets.forEach(c=>{
      if(c.setId && typeof c.setNumber !== 'number'){
        const num = map.get(c.setId);
        if(typeof num === 'number') c.setNumber = num;
      }
      if(typeof c.frontCount !== 'number') c.frontCount = 2; // domy≈õlnie 2 (dla standard√≥w)
      if(!c.details) c.details = {};
    });
  });
  projectData = FC.project.save(projectData);
}
normalizeProjectData();

/* ===== Modal state ===== */
const cabinetModalState = {
  mode: 'add',          // 'add' | 'edit'
  editingId: null,
  draft: null,
  chosen: null,         // 'stojƒÖca' | 'wiszƒÖca' | 'modu≈Ç' | 'zestaw'
  setPreset: null,
  setEditId: null       // setId when editing a set
};

/* ===== Utility & core functions ===== */
function calculateAvailableTopHeight(){
  const s = projectData.kuchnia.settings;
  const h = (Number(s.roomHeight)||0) - (Number(s.bottomHeight)||0) - (Number(s.counterThickness)||0) - (Number(s.gapHeight)||0) - (Number(s.ceilingBlende)||0);
  return h>0?Math.round(h*10)/10:0;
}
function renderTopHeight(){
  const el = document.getElementById('autoTopHeight');
  if(el) el.textContent = calculateAvailableTopHeight();
}

// ZESTAWY: top = roomHeight - suma ni≈ºszych - blenda
function calcTopForSet(room, blende, sumLowerHeights){
  const s = projectData[room].settings;
  const h = (Number(s.roomHeight)||0) - (Number(sumLowerHeights)||0) - (Number(blende)||0);
  return h>0 ? Math.round(h*10)/10 : 0;
}

/* Toggle expansion (single-open accordion) */
function toggleExpandAll(id){
  const key = String(id);
  const isOpen = !!(uiState.expanded && uiState.expanded[key]);
  // only one cabinet expanded at a time
  uiState.expanded = {};
  if(!isOpen){
    uiState.expanded[key] = true;
    uiState.selectedCabinetId = key;
  }
  FC.storage.setJSON(STORAGE_KEYS.ui, uiState);
  renderCabinets();
}

/* Settings changes */
function handleSettingChange(field, value){
  const room = uiState.roomType; if(!room) return;
  projectData[room].settings[field] = value === '' ? 0 : parseFloat(value);
  projectData = FC.project.save(projectData);
  renderTopHeight();
  renderCabinets();
}

/* --- Variant lists --- */
function getSubTypeOptionsForType(typeVal){
  if(typeVal === 'wiszƒÖca'){
    return [
      { v:'standardowa', t:'Standardowa' },
      { v:'rogowa_slepa', t:'Rogowa ≈õlepa' },
      { v:'narozna_l', t:'Naro≈ºna L' },
      { v:'dolna_podblatowa', t:'Dolna podblatowa' },
      { v:'okap', t:'Okapowa' },
      { v:'uchylne', t:'Uchylne (klapa)' }
    ];
  }
  if(typeVal === 'stojƒÖca'){
    return [
      { v:'standardowa', t:'Standardowa' },
      { v:'rogowa_slepa', t:'Rogowa ≈õlepa' },
      { v:'narozna_l', t:'Naro≈ºna L' },
      { v:'piekarnikowa', t:'Piekarnikowa' },
      { v:'zlewowa', t:'Zlewowa' },
      { v:'zmywarkowa', t:'Zmywarkowa' },
      { v:'lodowkowa', t:'Lod√≥wkowa' },
      { v:'szuflady', t:'Szuflady' }
    ];
  }
  if(typeVal === 'modu≈Ç'){
    return [
      { v:'standardowa', t:'Standardowa' },
      { v:'szuflady', t:'Szufladowa' },
      { v:'uchylne', t:'Uchylna' }
    ];
  }
  return [{ v:'standardowa', t:'Standardowa' }];
}

/* Apply rules */
function applyTypeRules(room, updated, typeVal){
  if(typeVal === 'wiszƒÖca'){
    updated.subType = 'standardowa';
    updated.height = calculateAvailableTopHeight();
    updated.depth = 36;
    updated.details = Object.assign({}, updated.details || {}, { shelves: 2 });
    if(!['TIP-ON','podchwyt','uchwyt klienta','krawƒôdziowy HEXA GTV','korytkowy','UKW'].includes(updated.openingSystem)){
      updated.openingSystem = 'uchwyt klienta';
    }
    if(typeof updated.frontCount !== 'number') updated.frontCount = 2;
  } else if(typeVal === 'stojƒÖca'){
    updated.subType = 'standardowa';
    updated.height = projectData[room].settings.bottomHeight;
    updated.depth = 51;
    if(!['TIP-ON','uchwyt klienta','krawƒôdziowy HEXA GTV','korytkowy','UKW'].includes(updated.openingSystem)){
      updated.openingSystem = 'uchwyt klienta';
    }
    if(typeof updated.frontCount !== 'number') updated.frontCount = 2;
  } else if(typeVal === 'modu≈Ç'){
    // Modu≈Ç: korpus jak stojƒÖca (bez n√≥≈ºek), domy≈õlnie szer. 60, g≈Ç. 51, wys. wg obecnej logiki (gap + blat + 18mm)
    updated.subType = 'standardowa';
    const gap = Number(projectData[room].settings.gapHeight) || 0;
    const counter = Number(projectData[room].settings.counterThickness) || 0;
    updated.width = 60;
    updated.depth = 51;
    updated.height = Math.round((gap + counter + 1.8) * 10) / 10;
    updated.details = Object.assign({}, updated.details || {}, { shelves: (updated.details && updated.details.shelves != null ? updated.details.shelves : 2) });
    if(!['TIP-ON','uchwyt klienta','krawƒôdziowy HEXA GTV','korytkowy','UKW'].includes(updated.openingSystem)){
      updated.openingSystem = 'uchwyt klienta';
    }
    // Modu≈Ç standardowy domy≈õlnie jak drzwi (1/2 do wyboru)
    if(typeof updated.frontCount !== 'number' || ![1,2].includes(Number(updated.frontCount))) updated.frontCount = 2;
  }
  updated.type = typeVal;
  return updated;
}

function applySubTypeRules(room, updated, subTypeVal){
  if(updated.type === 'wiszƒÖca'){
    if(subTypeVal === 'dolna_podblatowa'){
      updated.depth = 57;
      updated.height = projectData[room].settings.bottomHeight;
      updated.details = Object.assign({}, updated.details || {}, { podFrontMode: 'drzwi', podInsideMode: 'polki', podInnerDrawerCount: '1', shelves: 1 });
    } else {
      updated.depth = 36;
      updated.height = calculateAvailableTopHeight();
    }
  } else if(updated.type === 'stojƒÖca'){
    if(subTypeVal === 'zlewowa'){
      updated.depth = 56;
    } else if(['standardowa','rogowa_slepa','narozna_l','szuflady','piekarnikowa'].includes(subTypeVal)){
      updated.depth = 51;
    } else if(['zmywarkowa','lodowkowa'].includes(subTypeVal)){
      updated.depth = 57;
    }

    if(subTypeVal === 'piekarnikowa'){
      updated.details = FC.utils.isPlainObject(updated.details) ? updated.details : {};
      // Oven cabinet: do not treat legacy default shelf=1 as a real shelf.
      updated.details.shelves = 0;
      if(!('ovenOption' in updated.details)) updated.details.ovenOption = 'szuflada_dol';
      if(!('ovenHeight' in updated.details)) updated.details.ovenHeight = '60';
    }
  } else if(updated.type === 'modu≈Ç'){
    // Modu≈Ç: warianty jak stojƒÖca (bez n√≥≈ºek) + uchylna jak wiszƒÖca, ale g≈Çƒôboko≈õƒá zawsze 51, szeroko≈õƒá domy≈õlnie 60
    updated.depth = 51;
    if(!Number(updated.width)) updated.width = 60;

    if(subTypeVal === 'szuflady'){
      const cur = (updated.details || {});
      // ustaw domy≈õlne warto≈õci szuflad (jak w stojƒÖcej)
      updated.details = Object.assign({}, cur, {
        drawerLayout: (cur.drawerLayout || (cur.drawerCount ? null : '3_1_2_2') || '3_1_2_2'),
        drawerSystem: (cur.drawerSystem || 'skrzynkowe'),
        innerDrawerType: (cur.innerDrawerType || 'brak'),
        innerDrawerCount: (cur.innerDrawerCount != null ? cur.innerDrawerCount : 0),
        shelves: (cur.shelves != null ? cur.shelves : 0)
      });
      updated.frontCount = 0;
    } else if(subTypeVal === 'uchylne'){
      const cur = (updated.details || {});
      const vendor = (cur.flapVendor || 'blum');
      let kind = cur.flapKind;
      if(!kind){
        kind = (vendor === 'hafele') ? 'DUO' : 'HKI';
      }

      // Usu≈Ñ ≈õlady po szufladach, ≈ºeby UI nie pokazywa≈Ço p√≥l "szufladowych"
      const clean = Object.assign({}, cur);
      delete clean.drawerLayout;
      delete clean.drawerSystem;
      delete clean.drawerCount;
      delete clean.innerDrawerType;
      delete clean.innerDrawerCount;

      updated.details = Object.assign({}, clean, {
        flapVendor: vendor,
        flapKind: kind,
        shelves: (cur.shelves != null ? cur.shelves : 2)
      });
      updated.frontCount = getFlapFrontCount(updated);
    } else {
      // standardowa
      const cur = (updated.details || {});
      updated.details = Object.assign({}, cur, { shelves: (cur.shelves != null ? cur.shelves : 2) });
      if(![1,2].includes(Number(updated.frontCount))) updated.frontCount = 2;
    }
  }

  updated.subType = subTypeVal;

  // piekarnikowa: parametry piekarnika + p√≥≈Çka techniczna
  if(updated.type === 'stojƒÖca' && subTypeVal === 'piekarnikowa'){
    const cur = (updated.details || {});
    updated.details = Object.assign({}, cur, {
      ovenOption: (cur.ovenOption || 'szuflada_dol'),
      ovenHeight: (cur.ovenHeight || '60'),
      techShelfCount: (cur.techShelfCount || '1'),
      shelves: (cur.shelves != null ? cur.shelves : 0)
    });
  }

  
  // szuflady (stojƒÖca): uk≈Çad + typ + opcjonalne szuflady wewnƒôtrzne
  if(updated.type === 'stojƒÖca' && subTypeVal === 'szuflady'){
    const cur = FC.utils.isPlainObject(updated.details) ? updated.details : {};
    let lay = cur.drawerLayout;
    if(!lay){
      const legacy = String(cur.drawerCount || '3');
      if(legacy === '1') lay = '1_big';
      else if(legacy === '2') lay = '2_equal';
      else if(legacy === '3') lay = '3_1_2_2';
      else if(legacy === '5') lay = '5_equal';
      else lay = '3_equal';
    }
    const innerDef = (lay === '3_equal') ? '3' : '2';
    updated.details = Object.assign({}, cur, {
      drawerLayout: lay,
      drawerSystem: (cur.drawerSystem || 'skrzynkowe'),
      innerDrawerType: (cur.innerDrawerType || 'brak'),
      innerDrawerCount: (cur.innerDrawerCount != null ? String(cur.innerDrawerCount) : innerDef),
      // zachowaj legacy dla kompatybilno≈õci
      drawerCount: (cur.drawerCount != null ? String(cur.drawerCount) : (lay === '1_big' ? '1' : lay === '2_equal' ? '2' : lay === '5_equal' ? '5' : '3'))
    });
    // uk≈Çad 5 szuflad: brak wewnƒôtrznych
    if(lay === '5_equal'){
      updated.details.innerDrawerType = 'brak';
      updated.details.innerDrawerCount = '0';
    }
  }

// zlewowa: wyb√≥r frontu (drzwi/szuflada) + opcje dodatkowe (p√≥≈Çka / szuflada wewn.)
  if(updated.type === 'stojƒÖca' && subTypeVal === 'zlewowa'){
    const cur = (updated.details || {});
    // migracja z poprzedniego pola sinkOption, je≈õli istnieje
    let sinkFront = cur.sinkFront

// zmywarkowa: wyb√≥r szeroko≈õci zmywarki synchronizuje wymiar szafki + przegrody techniczne dla wysokich front√≥w
if(updated.type === 'stojƒÖca' && subTypeVal === 'zmywarkowa'){
  const cur = FC.utils.isPlainObject(updated.details) ? updated.details : {};
  let dw = cur.dishWasherWidth;
  const cw = Number(updated.width) || 0;
  if(!dw){
    if(cw === 45) dw = '45';
    else if(cw === 60) dw = '60';
    else dw = '60';
  }
  updated.details = Object.assign({}, cur, { dishWasherWidth: dw });
  updated.width = Number(dw) || 60;

  const leg = Number(projectData[room]?.settings?.legHeight) || 0;
  const frontH = (Number(updated.height) || 0) - leg;
  // Przegroda techniczna: 74.6‚Äì76.5 => 1; 76.6‚Äì78.5 => 2; itd.
  const div = (frontH > 74.5) ? Math.max(0, Math.ceil(((frontH - 74.5) / 2) - 1e-9)) : 0;
  updated.details = Object.assign({}, updated.details, { techDividerCount: String(div), shelves: 0 });

  updated.frontCount = 1;
}

;
    let sinkDoorCount = cur.sinkDoorCount;
    let sinkExtra = cur.sinkExtra;
    let sinkExtraCount = cur.sinkExtraCount;
    let sinkInnerDrawerType = cur.sinkInnerDrawerType;

    if(!sinkFront && cur.sinkOption){
      if(cur.sinkOption === 'zwykle_drzwi'){
        sinkFront = 'drzwi';
      } else if(cur.sinkOption === 'szuflada'){
        sinkFront = 'szuflada';
      } else if(cur.sinkOption === 'szuflada_i_polka'){
        sinkFront = 'szuflada';
        sinkExtra = 'polka';
        sinkExtraCount = sinkExtraCount || 1;
      }
    }

    updated.details = Object.assign({}, cur, {
      sinkFront: (sinkFront || 'drzwi'),
      sinkDoorCount: (sinkDoorCount || '2'),
      sinkExtra: (sinkExtra || 'brak'),
      sinkExtraCount: (sinkExtraCount != null ? sinkExtraCount : 1),
      sinkInnerDrawerType: (sinkInnerDrawerType || 'skrzynkowe')
    });

    // p√≥≈Çki u≈ºytkowe dla zlewowej domy≈õlnie 0 (opcjonalne przez sinkExtra)
    if(updated.details.shelves == null) updated.details.shelves = 0;

    // je≈ºeli szuflada z przodu -> 1 du≈ºy front
    if(updated.details.sinkFront === 'szuflada'){
      updated.frontCount = 1;
    } else {
      const dc = Number(updated.details.sinkDoorCount) || 2;
      updated.frontCount = (dc === 1 ? 1 : 2);
    }
  }

  // rogowa_slepa: dodatkowy wymiar "czƒô≈õƒá za≈õlepiona" (cm)
  if(subTypeVal === 'rogowa_slepa'){
    const cur = (updated.details || {});
    updated.details = Object.assign({}, cur, { blindPart: (cur.blindPart ?? 30), cornerOption: (cur.cornerOption || 'polki') });
  }

  // frontCount defaults per subtype (tam gdzie logiczne)
  if(updated.type === 'stojƒÖca'){
    if(subTypeVal === 'zmywarkowa' || subTypeVal === 'piekarnikowa'){
      updated.frontCount = 1;
    } else if(subTypeVal === 'szuflady'){
      const d = FC.utils.isPlainObject(updated.details) ? updated.details : {};
      const lay = String(d.drawerLayout || '');
      let n = 3;
      if(lay === '1_big') n = 1;
      else if(lay === '2_equal') n = 2;
      else if(lay === '3_equal') n = 3;
      else if(lay === '5_equal') n = 5;
      else if(lay === '3_1_2_2') n = 3;
      updated.frontCount = n;
    } else if(typeof updated.frontCount !== 'number' || updated.frontCount === 0){
      updated.frontCount = 2;
    }
    if(subTypeVal === 'lodowkowa'){
      // domy≈õlnie: lod√≥wka w zabudowie, nisza 178, 2 fronty
      const cur = (updated.details && FC.utils.isPlainObject(updated.details)) ? updated.details : {};
      const opt = cur.fridgeOption ? String(cur.fridgeOption) : 'zabudowa';
      const niche = cur.fridgeNicheHeight ? String(cur.fridgeNicheHeight) : '178';
      const freeOpt = cur.fridgeFreeOption ? String(cur.fridgeFreeOption) : 'brak';
      const fc = cur.fridgeFrontCount ? String(cur.fridgeFrontCount) : '2';

      // szeroko≈õƒá: standard 60 (u≈ºytkownik mo≈ºe zmieniƒá w polu szeroko≈õci)
      if(!Number.isFinite(Number(updated.width)) || Number(updated.width) <= 0){
        updated.width = 60;
      }

      // wysoko≈õƒá: dla zabudowy = wysoko≈õƒá do≈Çu (z nogami) + nisza + (przegrody techn. * 1.8) + 3.6
      if(opt === 'zabudowa'){
        const s = projectData[room] ? projectData[room].settings : null;
        const bh = s ? (Number(s.bottomHeight) || 0) : 0;
        const leg = s ? (Number(s.legHeight) || 0) : 0;
        const bottomFrontH = Math.max(0, bh - leg);
        const div = (bottomFrontH > 74.5) ? Math.max(0, Math.ceil(((bottomFrontH - 74.5) / 2) - 1e-9)) : 0;
        const nh = Number(niche) || 0;
        if(nh > 0){
          updated.height = nh + (div * 1.8) + 3.6 + leg;
        }
      }

      // Przegroda techniczna: zale≈ºne od dolnego frontu (wys. do≈Çu bez n√≥g), jak w zmywarce
      const s2 = projectData[room] ? projectData[room].settings : null;
      const leg = s2 ? (Number(s2.legHeight) || 0) : 0;
      const bottomFrontH = s2 ? Math.max(0, (Number(s2.bottomHeight) || 0) - leg) : 0;
      const div = (opt === 'zabudowa' && bottomFrontH > 74.5) ? Math.max(0, Math.ceil(((bottomFrontH - 74.5) / 2) - 1e-9)) : 0;

      updated.details = Object.assign({}, cur, {
        fridgeOption: opt,
        fridgeNicheHeight: niche,
        fridgeFreeOption: freeOpt,
        fridgeFrontCount: fc,
        techDividerCount: String(div)
      });

      // frontCount na kabinie nie u≈ºywane dla lod√≥wkowej (obs≈Çuga jest przez fridgeFrontCount),
      // ale zostawiamy niezerowe aby nie psuƒá UI w innych miejscach.
      if(typeof updated.frontCount !== 'number' || updated.frontCount === 0) updated.frontCount = 2;
    }
  }
  if(updated.type === 'wiszƒÖca'){
    if(typeof updated.frontCount !== 'number' || updated.frontCount === 0) updated.frontCount = 2;
  }

  return updated;
}

/* ===== Fronts storage helpers ===== */
function addFront(room, front){
  const f = Object.assign({
    id: FC.utils.uid(),
    material: 'laminat',
    color: '',
    width: 0,
    height: 0,
    note: '',
    setId: null,
    setNumber: null,
    cabId: null
  }, front);
  if(!projectData[room]) return;
  projectData[room].fronts = projectData[room].fronts || [];
  projectData[room].fronts.push(f);
}

function removeFrontsForSet(room, setId){
  projectData[room].fronts = (projectData[room].fronts || []).filter(f => f.setId !== setId);
}
function removeFrontsForCab(room, cabId){
  projectData[room].fronts = (projectData[room].fronts || []).filter(f => f.cabId !== cabId);
}
function getFrontsForSet(room, setId){
  return (projectData[room].fronts || []).filter(f => f.setId === setId);
}
function getFrontsForCab(room, cabId){
  return (projectData[room].fronts || []).filter(f => f.cabId === cabId);
}

/* ===== Front generation for cabinets (point 2 + 3) ===== */
function cabinetAllowsFrontCount(cab){
  if(cab.type !== 'stojƒÖca' && cab.type !== 'wiszƒÖca' && cab.type !== 'modu≈Ç') return false;
  const st = cab.subType;
  if(st === 'narozna_l') return false; // naro≈ºna L: sta≈Ça ilo≈õƒá front√≥w (2)
  if(st === 'uchylne') return false; // klapa: ilo≈õƒá front√≥w zale≈ºy od rodzaju
  if(st === 'szuflady') return false;
  if(st === 'zmywarkowa' || st === 'piekarnikowa') return false; // 1 front
  // reszta: pozwalamy 1/2
  return true;
}


function getFlapFrontCount(cab){
  const vendor = (cab.details && cab.details.flapVendor) ? String(cab.details.flapVendor) : 'blum';
  const kind = (cab.details && cab.details.flapKind) ? String(cab.details.flapKind) : 'HKI';
  // 2 fronty tylko dla Aventos HF top (uchylno‚Äësk≈Çadany)
  if(vendor === 'blum' && kind === 'HF_top') return 2;
  return 1;
}

// Backward-compat helper: older code may call this name.
function getFlapFrontCountFromDetails(details){
  return getFlapFrontCount({ details: details || {} });
}


function ensureFrontCountRules(cab){
  // Naro≈ºna L zawsze ma 2 fronty (liczone osobno: FL/FP)
  if(cab.subType === 'narozna_l'){
    cab.frontCount = 2;
    return;
  }

  // Uchylne (klapy): ilo≈õƒá front√≥w zale≈ºy od rodzaju podno≈õnika (HF top = 2, reszta = 1)
  if((cab.type === 'wiszƒÖca' || cab.type === 'modu≈Ç') && cab.subType === 'uchylne'){
    cab.frontCount = getFlapFrontCount(cab);
    return;
  }

  // Modu≈Ç: szuflady nie majƒÖ osobnego wyboru ilo≈õci front√≥w (fronty wynikajƒÖ z uk≈Çadu)
  if(cab.type === 'modu≈Ç'){
    if(cab.subType === 'szuflady'){
      cab.frontCount = 0;
      return;
    }
    if(![1,2].includes(Number(cab.frontCount))) cab.frontCount = 2;
    return;
  }

  // WiszƒÖca: domy≈õlnie 2 fronty (chyba ≈ºe specjalne tryby)
  if(cab.type === 'wiszƒÖca'){
    const isPod = (cab.subType === 'dolna_podblatowa');
    const mode = cab.details && cab.details.podFrontMode ? cab.details.podFrontMode : null;

    if(isPod && mode === 'brak'){
      cab.frontCount = 0;
      return;
    }
    if(isPod && mode === 'szuflady'){
      if(![1,2].includes(Number(cab.frontCount))) cab.frontCount = 2;
      return;
    }
    if(!cab.frontCount || cab.frontCount < 1) cab.frontCount = 2;
    return;
  }

  // StojƒÖca: domy≈õlnie 2 fronty, wyjƒÖtki
  if(cab.type === 'stojƒÖca'){
    if(cab.subType === 'rogowa_slepa'){
      const co = cab.details?.cornerOption || 'polki';
      if(co === 'magic_corner') cab.frontCount = 1;
    }
    if(!cab.frontCount || cab.frontCount < 1) cab.frontCount = 2;
    return;
  }
}


// ===== Walidacja AVENTOS (klapy uchylne) na etapie dodawania/edycji szafki =====
// Cel: je≈õli KH/LF poza zakresem ‚Äì nie pozw√≥l zapisaƒá szafki (zamiast ostrze≈ºe≈Ñ w "Materia≈Çy").
// U≈ºywa istniejƒÖcego #cmFlapInfo (bez dodawania nowych element√≥w UI).
function validateAventosForDraft(room, draft){
  if(!room || !draft) return { ok:true };
  if(String(draft.subType || '') !== 'uchylne') return { ok:true };

  const info = getBlumAventosInfo(draft, room);
  if(!info) return { ok:true };

  if(info.status && info.status !== 'ok'){
    // je≈õli da siƒô dobraƒá poprzez zwiƒôkszenie liczby podno≈õnik√≥w ‚Äî to NIE jest b≈ÇƒÖd blokujƒÖcy
    if(info.status === 'needs_more_lifts'){
      return { ok:true, warning:true, info, msg: String(info.message || '') };
    }
    let extra = '';
    if(info.status === 'out_pf' && info.neededLiftQty){
      extra = ` Potrzeba ok. ${info.neededLiftQty} podno≈õnik√≥w.`;
    }
    const msg = String(info.message || `Poza zakresem: LF=${info.powerFactor}`) + extra;
    return { ok:false, info, msg };
  }

  // Ostrze≈ºenia informacyjne (np. zalecenia warsztatowe) przy status='ok'
  if(info.status === 'ok' && info.message && String(info.message).trim() && info.messageTone === 'orange'){
    return { ok:true, warning:true, info, msg: String(info.message) };
  }


  return { ok:true, info };
}

function applyAventosValidationUI(room, draft){
  const saveBtn = document.getElementById('cabinetModalSave');
  const infoEl = document.getElementById('cmFlapInfo');
  if(!saveBtn || !infoEl) return;

  const res = validateAventosForDraft(room, draft);

  // reset
  saveBtn.disabled = false;

  // domy≈õlnie chowamy
  infoEl.style.display = 'none';
  infoEl.textContent = '';

  if(res.ok && !res.warning){
    return;
  }

  // poka≈º komunikat (ostrze≈ºenie lub b≈ÇƒÖd)
  infoEl.style.display = 'block';
  infoEl.textContent = res.msg || '';

  if(!res.ok){
    // b≈ÇƒÖd blokujƒÖcy
    saveBtn.disabled = true;
  }

  // Kolory t≈Ça: czerwony (blokuje) / pomara≈Ñczowy (ostrze≈ºenie lub za wysoki front)
  const tone = res.warning ? 'orange' : ((res.info && res.info.messageTone) ? res.info.messageTone : 'red');
  if(tone === 'orange'){
    infoEl.style.background = '#fff3cd';
    infoEl.style.border = '1px solid #ffecb5';
    infoEl.style.color = '#7a4b00';
  }else{
    infoEl.style.background = '#f8d7da';
    infoEl.style.border = '1px solid #f5c2c7';
    infoEl.style.color = '#7a0000';
  }
  infoEl.style.padding = '10px';
  infoEl.style.borderRadius = '8px';
}


function syncDraftFromCabinetModalForm(d){
  if(!d) return;
  const num = (id) => {
    const el = document.getElementById(id);
    if(!el) return null;
    const raw = String(el.value ?? '').trim().replace(',', '.');
    const v = Number(raw);
    return Number.isFinite(v) ? v : null;
  };
  const str = (id) => {
    const el = document.getElementById(id);
    if(!el) return null;
    const v = String(el.value ?? '').trim();
    return v;
  };

  const w = num('cmWidth');  if(w !== null) d.width = w;
  const h = num('cmHeight'); if(h !== null) d.height = h;
  const dep = num('cmDepth'); if(dep !== null) d.depth = dep;

  const fc = num('cmFrontCount'); // mo≈ºe nie istnieƒá (np. klapa/naro≈ºna L)
  if(fc !== null) d.frontCount = fc;

  // p√≥≈Çki
  // UWAGA: cmShelves istnieje w DOM zawsze (ukryty wrap), ale nie ka≈ºda szafka u≈ºywa tego pola.
  // ≈ªeby nie nadpisywaƒá warto≈õci ustawianych w dynamicznych polach (np. Modu≈Ç‚ÜíStandardowa),
  // czytamy cmShelves tylko wtedy, gdy jego wrap jest widoczny.
  const shWrap = document.getElementById('cmShelvesWrap');
  const shWrapVisible = !!(shWrap && shWrap.style.display !== 'none' && shWrap.offsetParent !== null);
  if(shWrapVisible){
    const sh = num('cmShelves');
    if(sh !== null){
      // store as integer number for consistency across cabinet types
      d.details = Object.assign({}, d.details || {}, { shelves: Math.max(0, Math.round(sh)) });
    }
  }

  // naro≈ºna L (GL/GP/ST/SP)
  const gl = num('cmGL'), gp = num('cmGP'), st = num('cmST'), sp = num('cmSP');
  if([gl,gp,st,sp].some(v => v !== null)){
    d.details = Object.assign({}, d.details || {}, {
      gl: gl !== null ? String(gl) : (d.details?.gl ?? ''),
      gp: gp !== null ? String(gp) : (d.details?.gp ?? ''),
      st: st !== null ? String(st) : (d.details?.st ?? ''),
      sp: sp !== null ? String(sp) : (d.details?.sp ?? '')
    });
    // pomocniczo: szeroko≈õƒá=ST, g≈Çƒôboko≈õƒá=max(GL,GP) ‚Äì tak jak w sync naro≈ºnej
    if(st !== null) d.width = st;
    if(gl !== null || gp !== null) d.depth = Math.max(gl ?? 0, gp ?? 0);
  }

  // klapa (uchylne)
  const flapVendor = str('cmFlapVendor');
  const flapKind = str('cmFlapKind');
  if((d.type === 'wiszƒÖca' || d.type === 'modu≈Ç') && d.subType === 'uchylne'){
    const det = Object.assign({}, d.details || {});
    if(flapVendor) det.flapVendor = flapVendor;
    if(flapKind) det.flapKind = flapKind;
    d.details = det;
  }
}


function generateFrontsForCabinet(room, cab){
  // czy≈õcimy stare
  removeFrontsForCab(room, cab.id);

  // tylko je≈õli ma sens
  if(!(cab.type === 'stojƒÖca' || cab.type === 'wiszƒÖca' || cab.type === 'modu≈Ç')) return;

  // wysoko≈õƒá front√≥w: dla szafek stojƒÖcych odejmujemy wysoko≈õƒá n√≥≈ºek (ustawienia pomieszczenia)
  function getFrontHeightForCab(){
    let h = Number(cab.height) || 0;
    if(cab.type === 'stojƒÖca'){
      const s = (projectData[room] && projectData[room].settings) ? projectData[room].settings : {};
      const leg = Number(s.legHeight) || 0;
      if(leg > 0) h = Math.max(0, h - leg);
    }
    return h;
  }
  if(cab.subType === 'szuflady'){
    const d = cab.details || {};
    // uk≈Çad szuflad (kompatybilno≈õƒá wstecz: drawerCount)
    let lay = String(d.drawerLayout || '');
    if(!lay){
      const legacy = String(d.drawerCount || '3');
      if(legacy === '1') lay = '1_big';
      else if(legacy === '2') lay = '2_equal';
      else if(legacy === '3') lay = '3_1_2_2';
      else if(legacy === '5') lay = '5_equal';
      else lay = '3_equal';
    }

    let ratios = [1,2,2];
    if(lay === '1_big') ratios = [1];
    else if(lay === '2_equal') ratios = [1,1];
    else if(lay === '3_equal') ratios = [1,1,1];
    else if(lay === '5_equal') ratios = [1,1,1,1,1];
    else if(lay === '3_1_2_2') ratios = [1,2,2];

    const cabW = Number(cab.width) || 0;
    const cabH = getFrontHeightForCab();
    const sum = ratios.reduce((a,b)=>a+b,0) || 1;

    // wylicz wysoko≈õci z zaokrƒÖgleniem do 0.1 i korektƒÖ ostatniego
    const heights = [];
    let acc = 0;
    for(let i=0;i<ratios.length;i++){
      let h = (cabH * ratios[i]) / sum;
      h = Math.round(h*10)/10;
      if(i === ratios.length-1){
        h = Math.round((cabH - acc)*10)/10;
      }
      acc += h;
      heights.push(h);
    }

    const mat = cab.frontMaterial || 'laminat';
    const col = cab.frontColor || '';
    // zapisujemy te≈º poprawnƒÖ ilo≈õƒá front√≥w dla podsumowania
    cab.frontCount = ratios.length;

    for(let i=0;i<heights.length;i++){
      addFront(room, { id: FC.utils.uid(), cabId: cab.id, setId: cab.setId||null, setNumber: cab.setNumber||null, material: mat, color: col, width: cabW, height: heights[i], note: `Szuflada ${i+1}` });
    }
    return;
  }

  const mat = cab.frontMaterial || 'laminat';
  const col = cab.frontColor || '';

  // effectiveW: szeroko≈õƒá u≈ºywana do front√≥w (niekt√≥re typy majƒÖ za≈õlepienia)
  let effectiveW = Number(cab.width)||0;
  if(cab.subType === 'rogowa_slepa'){
    const blind = Math.max(0, Number(cab.details?.blindPart)||0);
    effectiveW = Math.max(0, effectiveW - blind);
  }

  // dolna_podblatowa (wiszƒÖca): tryb frontu (brak / drzwi / szuflady)
  if(cab.type === 'wiszƒÖca' && cab.subType === 'dolna_podblatowa'){
    const d = cab.details || {};
    const mode = d.podFrontMode || (d.subTypeOption && String(d.subTypeOption).startsWith('szuflada') ? 'szuflady' : ((Number(cab.frontCount)||0) ? 'drzwi' : 'brak'));

    // brak frontu
    if(mode === 'brak' || (Number(cab.frontCount)||0) === 0){
      return;
    }

    // szuflady zamiast drzwi: fronty poziome na pe≈ÇnƒÖ szeroko≈õƒá
    if(mode === 'szuflady'){
      const n = Math.max(1, Number(cab.frontCount)||1);
      const cabW = Number(cab.width) || 0;
      const cabH = getFrontHeightForCab();
      const hEach = n ? Math.round((cabH / n) * 10) / 10 : 0;

      for(let i=0;i<n;i++){
        addFront(room, { id: FC.utils.uid(), cabId: cab.id, setId: cab.setId||null, setNumber: cab.setNumber||null, material: mat, color: col, width: cabW, height: hEach, note: `Szuflada ${i+1}/${n}` });
      }
      return;
    }
    // drzwi -> normalna logika poni≈ºej (szeroko≈õƒá dzielona przez ilo≈õƒá front√≥w)
  }

// uchylne (klapa) ‚Äì 1 front lub 2 fronty (Aventos HF)
if((cab.type === 'wiszƒÖca' || cab.type === 'modu≈Ç') && cab.subType === 'uchylne'){
  const fcFlap = getFlapFrontCount(cab);
  cab.frontCount = fcFlap; // informacyjnie + do podsumowa≈Ñ
  const fhFull = getFrontHeightForCab();
  const noteBase = (cab.details && cab.details.flapVendor) ? `Klapa (${cab.details.flapVendor})` : 'Klapa';
  if(fcFlap === 1){
    addFront(room, { cabId: cab.id, material: mat, color: col, width: effectiveW, height: fhFull, note: noteBase });
  } else {
    const h1 = Math.round((fhFull/2)*10)/10;
    const h2 = Math.max(0, Math.round((fhFull - h1)*10)/10);
    addFront(room, { cabId: cab.id, material: mat, color: col, width: effectiveW, height: h1, note: `${noteBase} ‚Äì front 1/2` });
    addFront(room, { cabId: cab.id, material: mat, color: col, width: effectiveW, height: h2, note: `${noteBase} ‚Äì front 2/2` });
  }
  return;
}

  // lod√≥wkowa w zabudowie ‚Äî specjalna logika (point 3)
  if(cab.type === 'stojƒÖca' && cab.subType === 'lodowkowa'){
    const opt = (cab.details && cab.details.fridgeOption) ? cab.details.fridgeOption : 'zabudowa';
    

const fc = (cab.details && cab.details.fridgeFrontCount) ? String(cab.details.fridgeFrontCount) : '2';

    if(opt === 'zabudowa'){
      const s = projectData[room].settings;
      const legH = (Number(s.legHeight)||0);
      const bottomFront = Math.max(0, (Number(s.bottomHeight)||0) - legH); // dolny front bez n√≥g
      const totalFrontH = Math.max(0, (Number(cab.height)||0) - legH); // suma wysoko≈õci front√≥w (bez n√≥g)
      if(fc === '1'){
        addFront(room, { cabId: cab.id, material: mat, color: col, width: Number(cab.width)||0, height: getFrontHeightForCab(), note: `Lod√≥wkowa (1 front)` });
      } else {
        const topFront = Math.max(0, totalFrontH - bottomFront);
        addFront(room, { cabId: cab.id, material: mat, color: col, width: Number(cab.width)||0, height: bottomFront, note: `Lod√≥wkowa (dolny front)` });
        addFront(room, { cabId: cab.id, material: mat, color: col, width: Number(cab.width)||0, height: topFront, note: `Lod√≥wkowa (g√≥rny front)` });
      }
      return;
    }
    // wolnostojƒÖca: brak front√≥w (obudowa/podest to elementy korpusu, nie fronty)
    return;
  }

  // zmywarkowa: 1 front
  if(cab.type === 'stojƒÖca' && cab.subType === 'zmywarkowa'){
    addFront(room, { cabId: cab.id, material: mat, color: col, width: Number(cab.width)||0, height: getFrontHeightForCab(), note: `zmywarkowa (1 front)` });
    return;
  }

  // piekarnikowa: front = wysoko≈õƒá szafki (bez n√≥≈ºek) minus wysoko≈õƒá piekarnika
  if(cab.type === 'stojƒÖca' && cab.subType === 'piekarnikowa'){
    const ovenH = Number(cab.details?.ovenHeight) || 60;
    const h = Math.max(0, getFrontHeightForCab() - ovenH);
    addFront(room, { cabId: cab.id, material: mat, color: col, width: Number(cab.width)||0, height: h, note: `piekarnikowa (front bez piekarnika)` });
    return;
  }

  // reszta: 1 lub 2 fronty (drzwi)


  // naro≈ºna L (wiszƒÖca / stojƒÖca): fronty liczone z GL/GP/ST/SP (cm)
  if((cab.type === 'wiszƒÖca' || cab.type === 'stojƒÖca') && cab.subType === 'narozna_l'){
    const d = cab.details || {};
    const GL = Number(d.gl) || 0;
    const GP = Number(d.gp) || 0;
    const ST = Number(d.st) || 0;
    const SP = Number(d.sp) || 0;
    const t = 1.8; // cm (p≈Çyta 18mm)

    const FL = Math.abs(GL - GP);
    const FP = Math.abs(ST - SP - t);

    const fh = getFrontHeightForCab();
    addFront(room, { cabId: cab.id, material: mat, color: col, width: FL, height: fh, note: `Naro≈ºna L (front A)` });
    addFront(room, { cabId: cab.id, material: mat, color: col, width: FP, height: fh, note: `Naro≈ºna L (front B)` });
    // wymuszamy 2 dla sp√≥jno≈õci podsumowania
    cab.frontCount = 2;
    return;
  }

  const fc = Math.max(1, Number(cab.frontCount||2));
  if(fc === 1){
    addFront(room, { cabId: cab.id, material: mat, color: col, width: effectiveW, height: getFrontHeightForCab(), note: `1 front` });
  } else {
    const w = effectiveW;
    const left = Math.round((w/2)*10)/10;
    const right = Math.max(0, w - left);
    addFront(room, { cabId: cab.id, material: mat, color: col, width: left, height: getFrontHeightForCab(), note: `Front 1/2` });
    addFront(room, { cabId: cab.id, material: mat, color: col, width: right, height: getFrontHeightForCab(), note: `Front 2/2` });
  }
}



function drawCornerSketch(opts){
  const c = document.getElementById('cornerPreview');
  if(!c) return;
  const ctx = c.getContext('2d');

  const GL = Number(opts?.GL) || 0;
  const GP = Number(opts?.GP) || 0;
  const ST = Number(opts?.ST) || 0;
  const SP = Number(opts?.SP) || 0;
  const t  = Number(opts?.t ?? 1.8) || 1.8; // cm
  const flip = !!opts?.flip;

  // computed fronts (Twoje zasady)
  const FL = Math.abs(GL - GP);
  const FP = Math.abs(ST - SP - t);

  // pomocniczo dla podpis√≥w / strza≈Çek
  // Po FLIP chcemy, ≈ºeby "lewa strona rysunku" pokazywa≈Ça dawnƒÖ prawƒÖ g≈Çƒôboko≈õƒá (GP)
  // i odwrotnie ‚Äì bez lustrzanego odwracania tekstu.
  const yLeftSide  = flip ? GP : GL;
  const yRightSide = flip ? GL : GP;
  const yFrontLine = Math.max(GL, GP);

  const W = c.width, H = c.height;
  ctx.clearRect(0,0,W,H);

  // marginesy
  const m = 55;
  const drawW = W - 2*m;
  const drawH = H - 2*m;

  const maxDepth = Math.max(GL, GP, 1);
  const sx = drawW / Math.max(1, ST);
  const sy = drawH / maxDepth;
  const s = Math.min(sx, sy);

  const ox = m, oy = m;
  const X = (v) => ox + v*s;
  const Y = (v) => oy + v*s;

  // Geometria poglƒÖdowa (top‚Äëdown) zgodna z Twoimi parametrami.
  // Kluczowe: przy flip rysunek jest LUSTROWANY, a nie tylko "przestawiany" punkt schodka.
  // Dziƒôki temu odcinek czerwony odpowiada zawsze FP = |ST ‚àí SP ‚àí t|.

  const notchX0 = Math.max(0, Math.min(ST, SP + t)); // o≈õ "schodka" w bazowej orientacji
  const tx = (x) => (flip ? (ST - x) : x);

  // Punkty obrysu w bazie (bez flip), potem ewentualne lustrzane odbicie w osi pionowej.
  const ptsBase = [
    {x:0,    y:0},
    {x:ST,   y:0},
    {x:ST,   y:GP},
    {x:notchX0, y:GP},
    {x:notchX0, y:GL},
    {x:0,    y:GL}
  ];
  const pts = ptsBase.map(p => ({ x: tx(p.x), y: p.y }));

  // obrys korpusu (czarny)
  ctx.lineWidth = 3;
  ctx.strokeStyle = "#111";
  ctx.beginPath();
  ctx.moveTo(X(pts[0].x), Y(pts[0].y));
  for(let i=1;i<pts.length;i++) ctx.lineTo(X(pts[i].x), Y(pts[i].y));
  ctx.closePath();
  ctx.stroke();

  // fronty (czerwony):
  // FL = |GL‚àíGP| to pion schodka (pomiƒôdzy y=GP i y=GL),
  // FP = |ST‚àíSP‚àít| to poziom schodka (pomiƒôdzy x=notch a skrajem).
  const pNotchTop = { x: tx(notchX0), y: GP };
  const pNotchBot = { x: tx(notchX0), y: GL };
  const pEdgeTop  = { x: tx(ST),      y: GP }; // po flip to bƒôdzie x=0

  ctx.lineWidth = 4;
  ctx.strokeStyle = "#d11";
  ctx.beginPath();
  // pion (FL)
  ctx.moveTo(X(pNotchTop.x), Y(pNotchTop.y));
  ctx.lineTo(X(pNotchBot.x), Y(pNotchBot.y));
  // poziom (FP)
  ctx.moveTo(X(pNotchTop.x), Y(pNotchTop.y));
  ctx.lineTo(X(pEdgeTop.x),  Y(pEdgeTop.y));
  ctx.stroke();

  // plecy/HDF (zielony) ‚Äì poglƒÖdowo przy tylnej krawƒôdzi
  ctx.lineWidth = 4;
  ctx.strokeStyle = "#0a7";
  ctx.beginPath();
  // przy flip tx(0)=ST, tx(ST)=0, wiƒôc bierzemy min/max ≈ºeby nie wyj≈õƒá poza rysunek
  const hdfX1 = Math.min(tx(0), tx(ST)) + 1;
  const hdfX2 = Math.max(tx(0), tx(ST)) - 1;
  ctx.moveTo(X(hdfX1), Y(1));
  ctx.lineTo(X(Math.max(hdfX1, hdfX2)), Y(1));
  ctx.stroke();

  function arrow(x1,y1,x2,y2,label){
    const head = 9;
    const ang = Math.atan2(y2-y1, x2-x1);
    ctx.strokeStyle = "#1e4b8f";
    ctx.fillStyle = "#1e4b8f";
    ctx.lineWidth = 2;

    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();

    const hx1 = x2 - head*Math.cos(ang) + head*0.6*Math.cos(ang+Math.PI/2);
    const hy1 = y2 - head*Math.sin(ang) + head*0.6*Math.sin(ang+Math.PI/2);
    const hx2 = x2 - head*Math.cos(ang) + head*0.6*Math.cos(ang-Math.PI/2);
    const hy2 = y2 - head*Math.sin(ang) + head*0.6*Math.sin(ang-Math.PI/2);

    ctx.beginPath();
    ctx.moveTo(x2,y2); ctx.lineTo(hx1,hy1); ctx.lineTo(hx2,hy2); ctx.closePath();
    ctx.fill();

    ctx.font = "bold 18px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(label, (x1+x2)/2, (y1+y2)/2 - 14);
  }

  // opisy wymiar√≥w (cm)
  // SP rysujemy jako odcinek na "dole" (front dolny). Przy flip lƒÖduje po prawej.
  const spClamped = Math.max(0, Math.min(ST, SP));
  const spA1 = flip ? (ST - spClamped) : 0;
  const spA2 = flip ? ST : spClamped;
  arrow(X(0), Y(-1.4), X(ST), Y(-1.4), `ST = ${ST} cm`);
  arrow(X(spA1), Y(yFrontLine+1.6), X(spA2), Y(yFrontLine+1.6), `SP = ${SP} cm`);

  // Etykiety GL/GP przechodzƒÖ na strony zgodnie z FLIP.
  // (Warto≈õci wej≈õciowe GL/GP nie muszƒÖ siƒô zamieniaƒá ‚Äì liczymy fronty z |...|.)
  const leftLabel  = flip ? `GP = ${GP} cm` : `GL = ${GL} cm`;
  const rightLabel = flip ? `GL = ${GL} cm` : `GP = ${GP} cm`;
  arrow(X(-1.4), Y(0), X(-1.4), Y(yLeftSide), leftLabel);
  arrow(X(ST+1.4), Y(0), X(ST+1.4), Y(yRightSide), rightLabel);

  const legend = document.getElementById('cornerPreviewLegend');
  if(legend){
    legend.textContent = `Fronty: FL=|GL‚àíGP|=${Math.round(FL*10)/10} cm, FP=|ST‚àíSP‚àí1,8|=${Math.round(FP*10)/10} cm`;
  }
}

/* ===== add cabinet (opens modal) ===== */
function addCabinet(){
  if(!uiState.roomType){ alert('Wybierz pomieszczenie najpierw'); return; }
  openCabinetModalForAdd();
}


/* ===== Delete cabinet by id (used by per-card delete) ===== */
function deleteCabinetById(cabId){
  const room = uiState.roomType; if(!room) return;
  if(!cabId){ alert('Wybierz szafkƒô do usuniƒôcia'); return; }

  const cab = (projectData[room].cabinets || []).find(c => c.id === cabId);
  const label = cab ? `${cab.type || 'szafka'} ${cab.subType ? '('+cab.subType+')' : ''} ${cab.width}√ó${cab.height}√ó${cab.depth}` : 'szafkƒô';
  if(!confirm(`UsunƒÖƒá ${label}?`)) return;

  // usu≈Ñ powiƒÖzane fronty
  removeFrontsForCab(room, cabId);

  projectData[room].cabinets = (projectData[room].cabinets || []).filter(c => c.id !== cabId);

  if(uiState.selectedCabinetId === cabId) uiState.selectedCabinetId = null;

  FC.storage.setJSON(STORAGE_KEYS.projectData, projectData);
  FC.storage.setJSON(STORAGE_KEYS.ui, uiState);
  renderCabinets();
}

/* delete selected cabinet or last if none selected */
function deleteSelectedCabinet(){
  const room = uiState.roomType; if(!room) return;
  let sel = uiState.selectedCabinetId;
  if(!sel){
    const arr = projectData[room].cabinets || [];
    if(arr.length === 0){ alert('Brak szafek do usuniƒôcia'); return; }
    sel = arr[arr.length-1].id;
  }
  deleteCabinetById(sel);
}

/* ===== Price modal functions ===== */
function closePriceModal(){ uiState.showPriceList = null; uiState.editingId = null; FC.storage.setJSON(STORAGE_KEYS.ui, uiState); document.getElementById('priceModal').style.display = 'none'; }

function saveMaterialFromForm(){
  const type = document.getElementById('formMaterialType').value;
  const manufacturer = document.getElementById('formManufacturer').value;
  const symbol = document.getElementById('formSymbol').value.trim();
  const name = document.getElementById('formName').value.trim();
  const price = parseFloat(document.getElementById('formPrice').value || 0);
  if(!name){ alert('Wprowad≈∫ nazwƒô'); return; }
  const data = { materialType: type, manufacturer, symbol, name, price };
  if(uiState.editingId){
    materials = materials.map(m => m.id === uiState.editingId ? Object.assign({}, m, data) : m);
    uiState.editingId = null;
  } else {
    const id = FC.utils.uid();
    materials.push(Object.assign({ id }, data));
  }
  FC.storage.setJSON(STORAGE_KEYS.materials, materials);
  renderPriceModal();
  renderCabinetModal();
}

function saveServiceFromForm(){
  const category = document.getElementById('formCategory').value.trim() || 'Monta≈º';
  const name = document.getElementById('formServiceName').value.trim();
  const price = parseFloat(document.getElementById('formServicePrice').value || 0);
  if(!name){ alert('Wprowad≈∫ nazwƒô'); return; }
  const data = { category, name, price };
  if(uiState.editingId){
    services = services.map(s => s.id === uiState.editingId ? Object.assign({}, s, data) : s);
    uiState.editingId = null;
  } else {
    const id = FC.utils.uid();
    services.push(Object.assign({ id }, data));
  }
  FC.storage.setJSON(STORAGE_KEYS.services, services);
  renderPriceModal();
}

function deletePriceItem(item){
  if(!confirm('UsunƒÖƒá pozycjƒô?')) return;
  if(uiState.showPriceList === 'materials'){ materials = materials.filter(m => m.id !== item.id); FC.storage.setJSON(STORAGE_KEYS.materials, materials); }
  else { services = services.filter(s => s.id !== item.id); FC.storage.setJSON(STORAGE_KEYS.services, services); }
  renderPriceModal();
  renderCabinetModal();
}

/* ===== Cabinet Modal helpers ===== */
function makeDefaultCabinetDraftForRoom(room){
  const arr = projectData[room].cabinets;
  const last = arr[arr.length - 1];

  // powiel poprzedniƒÖ ze wszystkimi ustawieniami
  if(last){
    const cloned = FC.utils.clone(last);
    cloned.id = null;
    delete cloned.setId;
    delete cloned.setPreset;
    delete cloned.setRole;
    delete cloned.setName;
    delete cloned.setNumber;
    return cloned;
  }

  const isKitchen = room === 'kuchnia';
  const baseLaminat = (materials.find(m=>m.materialType==='laminat')?.name || '');
  return {
    id: null,
    width: 60,
    height: isKitchen ? projectData.kuchnia.settings.bottomHeight : 200,
    depth: isKitchen ? 51 : 60,
    type: isKitchen ? 'stojƒÖca' : 'modu≈Ç',
    subType: 'standardowa',
    bodyColor: baseLaminat,
    frontMaterial: 'laminat',
    frontColor: baseLaminat,
    openingSystem: 'uchwyt klienta',
    backMaterial: 'HDF 3mm bia≈Ça',
    frontCount: 2,
    details: { insideMode: 'polki', innerDrawerCount: '1', innerDrawerType: 'blum', shelves: 1, cornerOption: 'polki', dishWasherWidth: '60', ovenOption: 'szuflada_dol', ovenHeight: '60', sinkOption: 'zwykle_drzwi', fridgeOption: 'zabudowa', fridgeWidth: '60', drawerCount: '3', subTypeOption: 'polki', fridgeFrontCount: '2' }
  };
}

function openCabinetModalForAdd(){
  cabinetModalState.mode = 'add';
  cabinetModalState.editingId = null;
  cabinetModalState.setEditId = null;
  cabinetModalState.chosen = null;
  cabinetModalState.setPreset = null;
  cabinetModalState.draft = makeDefaultCabinetDraftForRoom(uiState.roomType);
  renderCabinetModal();
  document.getElementById('cabinetModal').style.display = 'flex';
  lockModalScroll();
}


function lockModalScroll(){
  document.documentElement.classList.add('modal-lock');
  document.body.classList.add('modal-lock');
}
function unlockModalScroll(){
  document.documentElement.classList.remove('modal-lock');
  document.body.classList.remove('modal-lock');
}

function openCabinetModalForEdit(cabId){
  cabId = String(cabId);
  const room = uiState.roomType; if(!room) return;
  const cab = projectData[room].cabinets.find(c => String(c.id) === cabId);
  if(!cab) return;

  if(cab.setId){
    openSetWizardForEdit(cab.setId);
    return;
  }

  cabinetModalState.mode = 'edit';
  cabinetModalState.editingId = cabId;
  cabinetModalState.setEditId = null;
  cabinetModalState.chosen = cab.type;
  cabinetModalState.setPreset = null;
  cabinetModalState.draft = FC.utils.clone(cab);
  renderCabinetModal();
  document.getElementById('cabinetModal').style.display = 'flex';
  lockModalScroll();
}

function openSetWizardForEdit(setId){
  setId = String(setId);
  const room = uiState.roomType; if(!room) return;
  const set = projectData[room].sets.find(s => String(s.id) === setId);
  if(!set){ alert('Nie znaleziono zestawu'); return; }

  cabinetModalState.mode = 'add';
  cabinetModalState.editingId = null;
  cabinetModalState.setEditId = setId;
  cabinetModalState.chosen = 'zestaw';
  cabinetModalState.setPreset = set.presetId;
  cabinetModalState.draft = null;

  renderCabinetModal();
  fillSetParamsUIFromSet(set);
  document.getElementById('cabinetModal').style.display = 'flex';
  lockModalScroll();
}

function closeCabinetModal(){
  unlockModalScroll();
  document.getElementById('cabinetModal').style.display = 'none';
}

/* ===== Cabinet Modal rendering ===== */
function renderCabinetTypeChoices(){
  const wrap = document.getElementById('cabinetTypeChoices');
  wrap.innerHTML = '';
  const choices = [
    { key:'stojƒÖca', title:'Szafka dolna', sub:'Standardowy d√≥≈Ç', ico:'‚¨áÔ∏è' },
    { key:'wiszƒÖca', title:'Szafka wiszƒÖca', sub:'Standardowa g√≥ra', ico:'‚¨ÜÔ∏è' },
    { key:'modu≈Ç', title:'Modu≈Ç', sub:'Wk≈Çad / segment', ico:'üß±' },
    { key:'zestaw', title:'Zestaw', sub:'Standardy na ikonkach', ico:'üß©' }
  ];

  choices.forEach(ch => {
    const tile = document.createElement('div');
    tile.className = 'choice-tile' + (cabinetModalState.chosen === ch.key ? ' selected' : '');
    tile.innerHTML = `
      <div class="choice-ico">${ch.ico}</div>
      <div>
        <div class="choice-title">${ch.title}</div>
        <div class="choice-sub">${ch.sub}</div>
      </div>
    `;
    tile.addEventListener('click', () => {
      cabinetModalState.chosen = ch.key;

      if(ch.key !== 'zestaw'){
        const room = uiState.roomType;
    projectData[room].cabinets = projectData[room].cabinets || [];
        if(!cabinetModalState.draft) cabinetModalState.draft = makeDefaultCabinetDraftForRoom(room);

        applyTypeRules(room, cabinetModalState.draft, ch.key);
        const opts = getSubTypeOptionsForType(ch.key).map(o=>o.v);
        if(!opts.includes(cabinetModalState.draft.subType)) cabinetModalState.draft.subType = opts[0];
        applySubTypeRules(room, cabinetModalState.draft, cabinetModalState.draft.subType);
        ensureFrontCountRules(cabinetModalState.draft);
      }
      renderCabinetModal();
    });
    wrap.appendChild(tile);
  });
}

function populateSelect(el, options, selected){
  el.innerHTML = '';
  options.forEach(o => {
    const opt = document.createElement('option');
    opt.value = o.v; opt.textContent = o.t;
    if(selected === o.v) opt.selected = true;
    el.appendChild(opt);
  });
}

function populateFrontColorsTo(selectEl, typeVal, selected){
  selectEl.innerHTML = '';
  materials.filter(m => m.materialType === typeVal).forEach(m => {
    const o = document.createElement('option');
    o.value = m.name; o.textContent = m.name;
    if(m.name === selected) o.selected = true;
    selectEl.appendChild(o);
  });
  if(selectEl.options.length === 0){
    const o = document.createElement('option'); o.value=''; o.textContent='‚Äî brak ‚Äî';
    selectEl.appendChild(o);
  }
}

function populateBodyColorsTo(selectEl, selected){
  selectEl.innerHTML = '';
  materials.filter(m => m.materialType === 'laminat').forEach(m => {
    const o = document.createElement('option');
    o.value = m.name; o.textContent = m.name;
    if(m.name === selected) o.selected = true;
    selectEl.appendChild(o);
  });
  if(selectEl.options.length === 0){
    const o = document.createElement('option'); o.value=''; o.textContent='‚Äî brak ‚Äî';
    selectEl.appendChild(o);
  }
}

function populateOpeningOptionsTo(selectEl, typeVal, selected){
  selectEl.innerHTML = '';
  const isHanging = typeVal === 'wiszƒÖca';
  const options = isHanging
    ? ['uchwyt klienta','podchwyt','TIP-ON','krawƒôdziowy HEXA GTV','korytkowy','UKW']
    : ['uchwyt klienta','TIP-ON','krawƒôdziowy HEXA GTV','UKW','korytkowy'];
  options.forEach(v => {
    const o = document.createElement('option');
    o.value = v; o.textContent = v;
    if(v === selected) o.selected = true;
    selectEl.appendChild(o);
  });
}

function renderCabinetExtraDetailsInto(container, draft){
  container.innerHTML = '';
  const t = draft.type;
  const st = draft.subType;
  const d = draft.details || {};

  function addSelect(labelText, key, options, onChangeExtra){
    const div = document.createElement('div'); div.style.marginBottom='10px';
    div.innerHTML = `<label>${labelText}</label><select></select>`;
    const sel = div.querySelector('select');
    options.forEach(opt => {
      const o = document.createElement('option'); o.value=opt.v; o.textContent=opt.t; sel.appendChild(o);
    });
    sel.value = (draft.details && draft.details[key]) ? draft.details[key] : options[0].v;
    sel.addEventListener('change', e => {
      draft.details = Object.assign({}, draft.details || {}, { [key]: e.target.value });
      if(onChangeExtra) onChangeExtra(e.target.value);
      renderCabinetModal();
    });
    container.appendChild(div);
  }

  function addNumber(labelText, key, fallback){
    const div = document.createElement('div'); div.style.marginBottom='10px';
    const raw = (draft.details && draft.details[key] != null) ? draft.details[key] : fallback;
    const existingShelves = document.getElementById('cmShelves');
    const idAttr = (!existingShelves && key === 'shelves') ? ' id="cmShelves"' : '';
    div.innerHTML = `<label>${labelText}</label><input type="number"${idAttr} value="${raw}" />`;
    const inp = div.querySelector('input');

    const apply = () => {
      // zapisuj od razu (≈ºeby nie wymaga≈Ço "odklikniƒôcia" pola)
      draft.details = Object.assign({}, draft.details || {}, { [key]: inp.value });
    };

    inp.addEventListener('input', apply);
    inp.addEventListener('change', apply);
    container.appendChild(div);
  }


  // naro≈ºna L (wiszƒÖca / stojƒÖca): w≈Çasne wymiary + szkic (bez grafik zewnƒôtrznych)
  if((t === 'wiszƒÖca' || t === 'stojƒÖca') && st === 'narozna_l'){
    const d0 = FC.utils.isPlainObject(draft.details) ? draft.details : {};
    // domy≈õlne wymiary zale≈ºnie od typu
    const isStanding = (t === 'stojƒÖca');
    const defaults = {
      gl: (d0.gl != null ? d0.gl : (isStanding ? '110' : '70')),
      gp: (d0.gp != null ? d0.gp : (isStanding ? '50'  : '36')),
      st: (d0.st != null ? d0.st : (isStanding ? '100' : '60')),
      sp: (d0.sp != null ? d0.sp : (isStanding ? '47'  : '33')),
      shelves: (d0.shelves != null ? d0.shelves : 2)
    ,
      cornerFlip: (d0.cornerFlip != null ? d0.cornerFlip : false)
    };
    draft.details = Object.assign({}, d0, defaults);

    const wrap = document.createElement('div');
    wrap.innerHTML = `
      <div style="display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:12px">
        <div>
          <label>GL</label>
          <input id="cmGL" type="number" step="0.1" />
          <div class="muted xs" style="margin-top:4px">G≈Çƒôboko≈õƒá lewa (cm)</div>
        </div>
        <div>
          <label>GP</label>
          <input id="cmGP" type="number" step="0.1" />
          <div class="muted xs" style="margin-top:4px">G≈Çƒôboko≈õƒá prawa (cm)</div>
        </div>
        <div>
          <label>ST</label>
          <input id="cmST" type="number" step="0.1" />
          <div class="muted xs" style="margin-top:4px">Szeroko≈õƒá ty≈Çu (cm)</div>
        </div>
        <div>
          <label>SP</label>
          <input id="cmSP" type="number" step="0.1" />
          <div class="muted xs" style="margin-top:4px">Szeroko≈õƒá przodu (cm)</div>
        </div>
      </div>

      <div class="flex" style="margin-top:10px;justify-content:space-between;flex-wrap:wrap">
        <button id="flipCornerBtn" class="btn" type="button">Odwr√≥ƒá naro≈ºnik</button>
        <div id="cornerWarn" class="warn-orange xs"></div>
      </div>

      <div class="muted xs" style="margin-top:8px">
        Widok z g√≥ry. Fronty liczone: <b>FL = |GL‚àíGP|</b> oraz <b>FP = |ST‚àíSP‚àí1,8|</b> (p≈Çyta 18&nbsp;mm).
      </div>

      <div style="margin-top:10px">
        <canvas id="cornerPreview" width="520" height="360" style="width:100%;max-width:520px;border:1px solid #ddd;border-radius:10px;"></canvas>
        <div class="muted xs" id="cornerPreviewLegend" style="margin-top:6px"></div>
      </div>
    `;
    container.appendChild(wrap);

    const iGL = wrap.querySelector('#cmGL');
    const iGP = wrap.querySelector('#cmGP');
    const iST = wrap.querySelector('#cmST');
    const iSP = wrap.querySelector('#cmSP');
    const warnEl = wrap.querySelector('#cornerWarn');
    const flipBtn = wrap.querySelector('#flipCornerBtn');

    iGL.value = draft.details.gl;
    iGP.value = draft.details.gp;
    iST.value = draft.details.st;
    iSP.value = draft.details.sp;

    const widthInput = document.getElementById('cmWidth');
    const depthInput = document.getElementById('cmDepth');

    const sync = () => {
      const GL = Number(iGL.value) || 0;
      const GP = Number(iGP.value) || 0;
      const ST = Number(iST.value) || 0;
      const SP = Number(iSP.value) || 0;
      const flip = !!(draft.details && draft.details.cornerFlip);

      // Twoje zasady na fronty (cm)
      const FL = Math.abs(GL - GP);
      const FP = Math.abs(ST - SP - 1.8);

      draft.details = Object.assign({}, draft.details || {}, {
        gl: String(GL),
        gp: String(GP),
        st: String(ST),
        sp: String(SP)
      });

      // pomocniczo: uzupe≈Çnij "Szeroko≈õƒá" i "G≈Çƒôboko≈õƒá" w g≈Ç√≥wnych polach (≈ºeby wycena/listy mia≈Çy sens)
      // szeroko≈õƒá = ST, g≈Çƒôboko≈õƒá = max(GL, GP)
      draft.width = ST;
      draft.depth = Math.max(GL, GP);

      if(widthInput) widthInput.value = String(draft.width);
      if(depthInput) depthInput.value = String(draft.depth);

      drawCornerSketch({ GL, GP, ST, SP, t: 1.8, flip });

      // Ostrze≈ºenie: front < 15 cm
      if(warnEl){
        const msgs = [];
        if(FL > 0 && FL < 15) msgs.push('Front (FL) < 15 cm');
        if(FP > 0 && FP < 15) msgs.push('Front (FP) < 15 cm');
        if(msgs.length){
          warnEl.style.display = 'block';
          warnEl.textContent = '‚ö† ' + msgs.join(' ‚Ä¢ ');
        } else {
          warnEl.style.display = 'none';
          warnEl.textContent = '';
        }
      }
    };

    [iGL,iGP,iST,iSP].filter(Boolean).forEach(inp => {
      inp.addEventListener('input', sync);
      inp.addEventListener('change', sync);
    });

    if(flipBtn){
      flipBtn.addEventListener('click', () => {
        // Odwr√≥ƒá tylko "stronƒô" naro≈ºnika (rysunek + opisy), bez zamiany wpisanych warto≈õci.
        // Fronty i tak liczymy z warto≈õci bezwzglƒôdnych, a GL/GP w formularzu zostajƒÖ tym,
        // co wpisa≈Ç operator.
        draft.details = Object.assign({}, draft.details || {}, {
          cornerFlip: !(draft.details && draft.details.cornerFlip)
        });
        sync();
      });
    }

    sync();
    return;
  }

  if(t === 'wiszƒÖca'){
    if(st === 'dolna_podblatowa'){
      // PODBLATOWA: fronty mogƒÖ byƒá brak/drzwi/szuflady, a wnƒôtrze: p√≥≈Çki lub szuflady wewnƒôtrzne
      if(!d.podFrontMode){
        // kompatybilno≈õƒá wstecz: je≈õli stary zapis mia≈Ç subTypeOption szuflady_1/2
        if(d.subTypeOption === 'szuflada_1'){ d.podFrontMode = 'szuflady'; cabinetModalState.draft.frontCount = 1; }
        else if(d.subTypeOption === 'szuflada_2'){ d.podFrontMode = 'szuflady'; cabinetModalState.draft.frontCount = 2; }
        else d.podFrontMode = (Number(cabinetModalState.draft.frontCount) === 0 ? 'brak' : 'drzwi');
      }
      if(!d.podInsideMode) d.podInsideMode = 'polki';
      if(!d.podInnerDrawerCount) d.podInnerDrawerCount = '1';

      addSelect('Front', 'podFrontMode', [
        {v:'brak', t:'Otwarta (brak front√≥w)'},
        {v:'drzwi', t:'Drzwi (fronty)'},
        {v:'szuflady', t:'Szuflady (zamiast drzwi)'}
      ], (val)=>{
        // synchronizacja z ilo≈õciƒÖ front√≥w/szuflad
        if(val === 'brak'){
          cabinetModalState.draft.frontCount = 0;
        } else {
          const fc = Number(cabinetModalState.draft.frontCount);
          if(![1,2].includes(fc)) cabinetModalState.draft.frontCount = 2;
        }
      });

      if(d.podFrontMode !== 'szuflady'){
        addSelect('Wnƒôtrze', 'podInsideMode', [
          {v:'polki', t:'P√≥≈Çki'},
          {v:'szuflady_wewn', t:'Szuflady wewnƒôtrzne'}
        ]);

        if(d.podInsideMode === 'polki'){
          addNumber('Ilo≈õƒá p√≥≈Çek', 'shelves', 2);
        } else {
          addSelect('Ilo≈õƒá szuflad wewnƒôtrznych', 'podInnerDrawerCount', [
            {v:'1', t:'1'},
            {v:'2', t:'2'}
          ]);
        }

      // Plecy (tak/nie) ‚Äì tylko dla szafki: wiszƒÖca podblatowa
      if(!(draft.details && (draft.details.hasBack !== undefined))){
        draft.details = Object.assign({}, draft.details || {}, { hasBack: '1' });
      }
      addSelect('Plecy', 'hasBack', [
        {v:'1', t:'Tak'},
        {v:'0', t:'Nie'}
      ]);
      }
    } else {
      if(st === 'rogowa_slepa') addNumber('Czƒô≈õƒá za≈õlepiona (cm)', 'blindPart', 30);
      if(st !== 'uchylne') addNumber('Ilo≈õƒá p√≥≈Çek', 'shelves', 2);
    }
  }

  if(t === 'stojƒÖca' || t === 'modu≈Ç'){
    if(st === 'szuflady'){
      // Szafka stojƒÖca szufladowa: uk≈Çad + typ szuflad + opcjonalne szuflady wewnƒôtrzne
      if(!d.drawerLayout){
        // kompatybilno≈õƒá wstecz: drawerCount 1/2/3/4/5
        const legacy = String(d.drawerCount || '3');
        if(legacy === '1') d.drawerLayout = '1_big';
        else if(legacy === '2') d.drawerLayout = '2_equal';
        else if(legacy === '3') d.drawerLayout = '3_1_2_2';
        else if(legacy === '5') d.drawerLayout = '5_equal';
        else d.drawerLayout = '3_equal';
      }
      if(!d.drawerSystem) d.drawerSystem = 'skrzynkowe';
      if(!('innerDrawerType' in d)) d.innerDrawerType = 'brak';
      if(!('innerDrawerCount' in d) || d.innerDrawerCount == null) d.innerDrawerCount = '0';
addSelect('Uk≈Çad szuflad (fronty)', 'drawerLayout', [
        {v:'1_big', t:'1 du≈ºa (1:1)'},
        {v:'3_1_2_2', t:'1 ma≈Ça + 2 du≈ºe (1:2:2)'},
        {v:'2_equal', t:'2 r√≥wne (1:1)'},
        {v:'3_equal', t:'3 r√≥wne (1:1:1)'},
        {v:'5_equal', t:'5 r√≥wnych (1:1:1:1:1)'}
      ], () => {
        // dostosuj domy≈õlne limity dla szuflad wewnƒôtrznych
        const lay = String(draft.details?.drawerLayout || '3_1_2_2');
        if(lay === '5_equal'){
          draft.details = Object.assign({}, draft.details || {}, { innerDrawerType: 'brak', innerDrawerCount: '0' });
        } else if(lay === '3_equal'){
          if(String(draft.details?.innerDrawerCount || '') === '0' || !draft.details?.innerDrawerCount) draft.details = Object.assign({}, draft.details || {}, { innerDrawerCount: '3' });
        } else {
          if(String(draft.details?.innerDrawerCount || '') === '0' || !draft.details?.innerDrawerCount) draft.details = Object.assign({}, draft.details || {}, { innerDrawerCount: '2' });
        }
        renderCabinetModal();
      });

      // domy≈õlne ustawienia dla szafki szufladowej
      draft.details = Object.assign({}, draft.details || {});
      const isAdd = (cabinetModalState.mode === 'add' || !cabinetModalState.editingId);

      // UWAGA: nie nadpisuj wybor√≥w u≈ºytkownika przy ka≈ºdym renderze.
      // drawerSystem przyjmuje tylko: 'skrzynkowe' | 'systemowe'
      if(!draft.details.drawerSystem || !['skrzynkowe','systemowe'].includes(String(draft.details.drawerSystem))){
        draft.details.drawerSystem = 'skrzynkowe';
      }
      if(!draft.details.innerDrawerType) draft.details.innerDrawerType = 'brak';
      if(draft.details.innerDrawerType === 'brak'){
        draft.details.innerDrawerCount = '0';
      } else if(!draft.details.innerDrawerCount){
        // domy≈õlnie 2, dalsze ograniczenia liczy istniejƒÖca logika uk≈Çadu
        draft.details.innerDrawerCount = '2';
      }
addSelect('Typ szuflad (frontowych)', 'drawerSystem', [
        {v:'skrzynkowe', t:'Skrzynkowe'},
        {v:'systemowe', t:'Systemowe'}
      ], ()=>{ renderCabinetModal(); });

      const ds = String((draft.details && draft.details.drawerSystem) ? draft.details.drawerSystem : 'skrzynkowe');
      if(ds === 'systemowe'){
        // domy≈õlne warto≈õci
        if(!draft.details.drawerBrand) draft.details.drawerBrand = 'blum';
        if(draft.details.drawerBrand === 'blum' && !draft.details.drawerModel) draft.details.drawerModel = 'tandembox';

        addSelect('Firma systemu', 'drawerBrand', [
          {v:'blum', t:'BLUM'},
          {v:'gtv', t:'GTV'},
          {v:'rejs', t:'Rejs'}
        ], ()=>{ renderCabinetModal(); });

        const br = String(draft.details.drawerBrand || 'blum');
        if(br === 'blum'){
          addSelect('Typ szuflady BLUM', 'drawerModel', [
            {v:'tandembox', t:'TANDEMBOX (domy≈õlnie)'},
            {v:'legrabox', t:'LEGRABOX'},
            {v:'merivobox', t:'MERIVOBOX'},
            {v:'metabox', t:'METABOX'}
          ]);
        } else {
          const warn = document.createElement('div');
          warn.className = 'muted xs';
          warn.style.marginTop = '6px';
          warn.textContent = 'GTV/Rejs ‚Äì w budowie. Nie mo≈ºna zatwierdziƒá.';
          container.appendChild(warn);
        }
      }

      const lay = String(d.drawerLayout || '3_1_2_2');
      if(lay === '5_equal'){
        // Brak szuflad wewnƒôtrznych dla 5 szuflad
        draft.details = Object.assign({}, draft.details || {}, { innerDrawerType: 'brak', innerDrawerCount: '0' });
        const note = document.createElement('div');
        note.className = 'muted xs';
        note.style.marginTop = '6px';
        note.textContent = 'Dla uk≈Çadu 5 szuflad nie dodajemy szuflad wewnƒôtrznych.';
        container.appendChild(note);
      } else {
        addSelect('Szuflady wewnƒôtrzne', 'innerDrawerType', [
          {v:'brak', t:'Brak'},
          {v:'skrzynkowe', t:'Skrzynkowe'},
          {v:'blum', t:'Systemowe BLUM'}
        ], () => renderCabinetModal());

        const mode = String((draft.details && draft.details.innerDrawerType) ? draft.details.innerDrawerType : 'brak');
        const max = (lay === '3_equal') ? 3 : 2;
        const def = (lay === '3_equal') ? 3 : 2;

        if(mode !== 'brak'){
          // ilo≈õƒá z listy (limit)
          (function(){
            const div = document.createElement('div'); div.style.marginBottom='10px';
            div.innerHTML = `<label>Ilo≈õƒá szuflad wewnƒôtrznych (max ${max})</label><select></select>`;
            const sel = div.querySelector('select');

            const raw = (draft.details && draft.details.innerDrawerCount != null) ? draft.details.innerDrawerCount : String(def);
            let cur = parseInt(raw || '0', 10);
            if(!Number.isFinite(cur) || cur < 1) cur = def;
            if(cur > max) cur = max;

            sel.innerHTML = Array.from({length:max}, (_,i)=>i+1).map(n=>`<option value="${n}">${n}</option>`).join('');
            sel.value = String(cur);

            sel.addEventListener('change', e => {
              let v = parseInt(e.target.value || '1', 10);
              if(!Number.isFinite(v) || v < 1) v = 1;
              if(v > max) v = max;
              draft.details = Object.assign({}, draft.details || {}, { innerDrawerCount: String(v) });
              renderCabinetModal();
            });

            container.appendChild(div);
          })();
        } else {
          // utrzymuj sensownƒÖ domy≈õlnƒÖ warto≈õƒá "na start"
          const cur = parseInt(d.innerDrawerCount, 10);
          if(!Number.isFinite(cur) || cur <= 0){
            draft.details = Object.assign({}, draft.details || {}, { innerDrawerCount: String(def) });
          }
        }
      }
    }

    if(st === 'zlewowa'){
      // FRONT: drzwi lub szuflada
      if(!d.sinkFront) d.sinkFront = 'drzwi';
      if(!d.sinkDoorCount) d.sinkDoorCount = '2';
      if(!d.sinkExtra) d.sinkExtra = 'brak';
      if(d.sinkExtraCount == null) d.sinkExtraCount = 1;
      if(!d.sinkInnerDrawerType) d.sinkInnerDrawerType = 'skrzynkowe';

      addSelect('Front szafki zlewowej', 'sinkFront', [
        {v:'drzwi', t:'Drzwi'},
        {v:'szuflada', t:'Szuflada (1 du≈ºy front)'}
      ], () => {
        // wymuszenia front√≥w
        const curFront = (draft.details && draft.details.sinkFront) ? draft.details.sinkFront : 'drzwi';
        if(curFront === 'szuflada'){
          draft.frontCount = 1;
        } else {
          const dc = Number((draft.details && draft.details.sinkDoorCount) ? draft.details.sinkDoorCount : '2') || 2;
          draft.frontCount = (dc === 1 ? 1 : 2);
        }
        renderCabinetModal();
      });

      const curFront = (draft.details && draft.details.sinkFront) ? draft.details.sinkFront : 'drzwi';

      if(curFront === 'drzwi'){
        addSelect('Ilo≈õƒá drzwi', 'sinkDoorCount', [
          {v:'1', t:'1 drzwi'},
          {v:'2', t:'2 drzwi'}
        ], () => {
          const dc = Number((draft.details && draft.details.sinkDoorCount) ? draft.details.sinkDoorCount : '2') || 2;
          draft.frontCount = (dc === 1 ? 1 : 2);
        });
      } else {
        // szuflada: 1 front
        draft.frontCount = 1;
      }

      if(curFront === 'szuflada'){
        if(!draft.details.drawerSystem) draft.details.drawerSystem = 'skrzynkowe';
        if(!draft.details.drawerBrand) draft.details.drawerBrand = 'blum';
        if(!draft.details.drawerModel) draft.details.drawerModel = 'tandembox';

        addSelect('Typ szuflady (zlewowa)', 'drawerSystem', [
          {v:'skrzynkowe', t:'Skrzynkowe'},
          {v:'systemowe', t:'Systemowe'}
        ], ()=>{ renderCabinetModal(); });

        const ds3 = String(draft.details.drawerSystem || 'skrzynkowe');
        if(ds3 === 'systemowe'){
          addSelect('Firma systemu', 'drawerBrand', [
            {v:'blum', t:'BLUM'},
            {v:'gtv', t:'GTV'},
            {v:'rejs', t:'Rejs'}
          ], ()=>{ renderCabinetModal(); });
          const br3 = String(draft.details.drawerBrand || 'blum');
          if(br3 === 'blum'){
            addSelect('Typ szuflady BLUM', 'drawerModel', [
              {v:'tandembox', t:'TANDEMBOX (domy≈õlnie)'},
              {v:'legrabox', t:'LEGRABOX'},
              {v:'merivobox', t:'MERIVOBOX'},
              {v:'metabox', t:'METABOX'}
            ]);
          } else {
            const warn3 = document.createElement('div');
            warn3.className = 'muted xs';
            warn3.style.marginTop = '6px';
            warn3.textContent = 'GTV/Rejs ‚Äì w budowie. Nie mo≈ºna zatwierdziƒá.';
            container.appendChild(warn3);
          }
        }
      }

      // DODATKOWE WNƒòTRZE
      addSelect('Dodatkowo w ≈õrodku', 'sinkExtra', [
        {v:'brak', t:'Brak'},
        {v:'polka', t:'Dodatkowa p√≥≈Çka'},
        {v:'szuflada_wew', t:'Szuflada wewnƒôtrzna'}
      ], ()=>{ renderCabinetModal(); });

      const extra = (draft.details && draft.details.sinkExtra) ? draft.details.sinkExtra : 'brak';
      if(extra === 'polka'){
        addNumber('Ilo≈õƒá dodatkowych p√≥≈Çek', 'sinkExtraCount', 1);
      } else if(extra === 'szuflada_wew'){
        addNumber('Ilo≈õƒá szuflad wewnƒôtrznych', 'sinkExtraCount', 1);
        addSelect('Typ szuflad wewnƒôtrznych', 'sinkInnerDrawerType', [
          {v:'skrzynkowe', t:'Skrzynkowe'},
          {v:'systemowe', t:'Systemowe'}
        ], ()=>{ renderCabinetModal(); });

        const stt = String((draft.details && draft.details.sinkInnerDrawerType) ? draft.details.sinkInnerDrawerType : 'skrzynkowe');
        if(stt === 'systemowe'){
          if(!draft.details.sinkInnerDrawerBrand) draft.details.sinkInnerDrawerBrand = 'blum';
          if(draft.details.sinkInnerDrawerBrand === 'blum' && !draft.details.sinkInnerDrawerModel) draft.details.sinkInnerDrawerModel = 'tandembox';

          addSelect('Firma systemu', 'sinkInnerDrawerBrand', [
            {v:'blum', t:'BLUM'},
            {v:'gtv', t:'GTV'},
            {v:'rejs', t:'Rejs'}
          ], ()=>{ renderCabinetModal(); });

          const br2 = String(draft.details.sinkInnerDrawerBrand || 'blum');
          if(br2 === 'blum'){
            addSelect('Typ szuflady BLUM', 'sinkInnerDrawerModel', [
              {v:'tandembox', t:'TANDEMBOX (domy≈õlnie)'},
              {v:'legrabox', t:'LEGRABOX'},
              {v:'merivobox', t:'MERIVOBOX'},
              {v:'metabox', t:'METABOX'}
            ]);
          } else {
            const warn2 = document.createElement('div');
            warn2.className = 'muted xs';
            warn2.style.marginTop = '6px';
            warn2.textContent = 'GTV/Rejs ‚Äì w budowie. Nie mo≈ºna zatwierdziƒá.';
            container.appendChild(warn2);
          }
        }
      }
    }
    if(st === 'zmywarkowa'){
      addSelect('Szeroko≈õƒá zmywarki', 'dishWasherWidth', [
        {v:'45', t:'45 cm'},
        {v:'60', t:'60 cm'}
      ], (val) => {
        draft.frontCount = 1;
        draft.width = Number(val) || draft.width;
      });
    }
    if(st === 'lodowkowa'){
      // Lod√≥wkowa: zabudowa / wolnostojƒÖca
      const grid = document.createElement('div');
      grid.className = 'grid-2';
      grid.style.gap = '12px';
      grid.style.marginBottom = '10px';

      const cur = (draft.details && FC.utils.isPlainObject(draft.details)) ? draft.details : {};
      const opt = cur.fridgeOption ? String(cur.fridgeOption) : 'zabudowa';
      const niche = cur.fridgeNicheHeight ? String(cur.fridgeNicheHeight) : '178';
      const freeOpt = cur.fridgeFreeOption ? String(cur.fridgeFreeOption) : 'brak';

      grid.innerHTML = `
        <div>
          <label>Typ lod√≥wki</label>
          <select id="cmFridgeOption">
            <option value="zabudowa">W zabudowie</option>
            <option value="wolnostojaca">WolnostojƒÖca</option>
          </select>
        </div>
        <div id="cmFridgeNicheWrap">
          <label>Wysoko≈õƒá niszy (cm)</label>
          <select id="cmFridgeNiche">
            <option value="82">82</option>
            <option value="122">122</option>
            <option value="158">158</option>
            <option value="178">178</option>
            <option value="194">194</option>
            <option value="204">204</option>
          </select>
        </div>
        <div id="cmFridgeFreeWrap" style="display:none">
          <label>Opcja</label>
          <select id="cmFridgeFree">
            <option value="brak">Brak</option>
            <option value="podest">Podest</option>
            <option value="obudowa">Obudowa</option>
          </select>
        </div>
      `;

      const fo = grid.querySelector('#cmFridgeOption');
      const fn = grid.querySelector('#cmFridgeNiche');
      const fw = grid.querySelector('#cmFridgeFree');
      const nicheWrap = grid.querySelector('#cmFridgeNicheWrap');
      const freeWrap = grid.querySelector('#cmFridgeFreeWrap');

      fo.value = opt;
      fn.value = niche;
      fw.value = freeOpt;

      function applyFridgeDims(){
        const room = uiState.roomType;
        const s = projectData[room] ? projectData[room].settings : null;
        const bh = s ? (Number(s.bottomHeight) || 0) : 0;
        const leg = s ? (Number(s.legHeight) || 0) : 0;

        const curOpt = (draft.details && draft.details.fridgeOption) ? String(draft.details.fridgeOption) : (fo ? fo.value : 'zabudowa');
        const curFree = (draft.details && draft.details.fridgeFreeOption) ? String(draft.details.fridgeFreeOption) : (fw ? fw.value : 'brak');
        const nh = Number((draft.details && draft.details.fridgeNicheHeight) ? draft.details.fridgeNicheHeight : (fn ? fn.value : 0)) || 0;

        // zawsze utrzymuj sp√≥jne details
        draft.details = Object.assign({}, draft.details || {}, {
          fridgeOption: curOpt,
          fridgeFreeOption: curFree,
          fridgeNicheHeight: String(nh)
        });

        if(curOpt === 'zabudowa'){
          // ilo≈õƒá przegr√≥d technicznych liczona jak w zmywarce: od dolnego frontu (wys. do≈Çu - n√≥≈ºki)
          const bottomFrontH = Math.max(0, bh - leg);
          const div = (bottomFrontH > 74.5)
            ? Math.max(0, Math.ceil(((bottomFrontH - 74.5) / 2) - 1e-9))
            : 0;

          draft.details = Object.assign({}, draft.details, { techDividerCount: String(div) });

          // wysoko≈õƒá s≈Çupka lod√≥wkowego: nisza + (przegrody * 1.8) + 3.6 + n√≥≈ºki
          draft.height = nh + (div * 1.8) + 3.6 + leg;
          return;
        }

        // wolnostojƒÖca: auto-wymiary zale≈ºnie od opcji
        if(curFree === 'podest'){
          draft.width = 60;
          draft.depth = 60;
          draft.height = 3.6 + leg;
        } else if(curFree === 'obudowa'){
          draft.width = 65;
          draft.depth = 59.2;
          draft.height = 207;
        }
      }

      function toggleFridgeUI(){
        const o = (draft.details && draft.details.fridgeOption) ? draft.details.fridgeOption : fo.value;
        const isBuiltIn = (o === 'zabudowa');
        nicheWrap.style.display = isBuiltIn ? 'block' : 'none';
        freeWrap.style.display = isBuiltIn ? 'none' : 'block';
      }

      fo.addEventListener('change', e => {
        draft.details = Object.assign({}, draft.details || {}, { fridgeOption: e.target.value });
        applyFridgeDims();
        // dla zmiany typu nie tracimy danych, ale aktualizujemy UI
        renderCabinetModal();
      });

      fn.addEventListener('change', e => {
        draft.details = Object.assign({}, draft.details || {}, { fridgeNicheHeight: e.target.value });
        applyFridgeDims();
        // od≈õwie≈ºamy warto≈õci p√≥l
        renderCabinetModal();
      });

      fw.addEventListener('change', e => {
        draft.details = Object.assign({}, draft.details || {}, { fridgeFreeOption: e.target.value });
        applyFridgeDims();
        renderCabinetModal();
      });

      container.appendChild(grid);

      // FRONTY lod√≥wkowej: 1 lub 2 (tylko zabudowa)
      const builtInNow = (opt === 'zabudowa');
      if(builtInNow){
        addSelect('Fronty lod√≥wki (zabudowa)', 'fridgeFrontCount', [
          {v:'1', t:'1 du≈ºy front'},
          {v:'2', t:'2 fronty (dolny + g√≥rny)'}
        ]);
      }

      toggleFridgeUI();
      // ustaw wysoko≈õƒá przy wej≈õciu (zabudowa)
      draft.details = Object.assign({}, draft.details || {}, {
        fridgeOption: opt,
        fridgeNicheHeight: niche,
        fridgeFreeOption: freeOpt
      });
      applyFridgeDims();
    }
    if(st === 'piekarnikowa'){
      addSelect('Opcja piekarnika', 'ovenOption', [
        {v:'szuflada_dol', t:'Szuflada na dole'},
        {v:'szuflada_gora', t:'Szuflada na g√≥rze'},
        {v:'klapka_dol', t:'Klapka na dole'},
        {v:'klapka_gora', t:'Klapka na g√≥rze'}
      ], () => {
        draft.frontCount = 1;
      });
      addNumber('Wysoko≈õƒá piekarnika (cm)', 'ovenHeight', 60);
      addNumber('Przegroda techniczna (szt)', 'techShelfCount', 1);
      const oo = String((draft.details && draft.details.ovenOption) ? draft.details.ovenOption : 'szuflada_dol');
      if(oo.indexOf('szuflada') !== -1){
        if(!draft.details.drawerSystem) draft.details.drawerSystem = 'skrzynkowe';
        if(!draft.details.drawerBrand) draft.details.drawerBrand = 'blum';
        if(!draft.details.drawerModel) draft.details.drawerModel = 'tandembox';

        addSelect('Typ szuflady (piekarnikowa)', 'drawerSystem', [
          {v:'skrzynkowe', t:'Skrzynkowe'},
          {v:'systemowe', t:'Systemowe'}
        ], ()=>{ renderCabinetModal(); });

        const ds2 = String(draft.details.drawerSystem || 'skrzynkowe');
        if(ds2 === 'systemowe'){
          addSelect('Firma systemu', 'drawerBrand', [
            {v:'blum', t:'BLUM'},
            {v:'gtv', t:'GTV'},
            {v:'rejs', t:'Rejs'}
          ], ()=>{ renderCabinetModal(); });

          const br = String(draft.details.drawerBrand || 'blum');
          if(br === 'blum'){
            addSelect('Typ szuflady BLUM', 'drawerModel', [
              {v:'tandembox', t:'TANDEMBOX (domy≈õlnie)'},
              {v:'legrabox', t:'LEGRABOX'},
              {v:'merivobox', t:'MERIVOBOX'},
              {v:'metabox', t:'METABOX'}
            ]);
          } else {
            const warn = document.createElement('div');
            warn.className = 'muted xs';
            warn.style.marginTop = '6px';
            warn.textContent = 'GTV/Rejs ‚Äì w budowie. Nie mo≈ºna zatwierdziƒá.';
            container.appendChild(warn);
          }
        }
      }
    }
    if(['standardowa','rogowa_slepa','narozna_l'].includes(st)){
      if(st !== 'standardowa'){
        const opt = (st === 'narozna_l') ? {v:'karuzela', t:'Karuzela'} : {v:'magic_corner', t:'Magic Corner'};
        if(st === 'rogowa_slepa') addNumber('Czƒô≈õƒá za≈õlepiona (cm)', 'blindPart', 30);
        addSelect('System naro≈ºny', 'cornerOption', [
          {v:'polki', t:'P√≥≈Çki'},
          opt
        ], () => {
          if(st === 'rogowa_slepa' && (draft.details?.cornerOption || 'polki') === 'magic_corner'){
            draft.frontCount = 1;
          }
        });
      }
      const corner = d.cornerOption ? d.cornerOption : 'polki';

      // STANDARDOWA: wnƒôtrze p√≥≈Çki lub szuflady wewnƒôtrzne
      if(st === 'standardowa'){
        if(!d.insideMode) d.insideMode = 'polki';
        if(!d.innerDrawerCount) d.innerDrawerCount = '1';
        if(!d.innerDrawerType) d.innerDrawerType = 'blum';

        addSelect('Wnƒôtrze', 'insideMode', [
          {v:'polki', t:'P√≥≈Çki'},
          {v:'szuflady_wew', t:'Szuflady wewnƒôtrzne'}
        ], (val)=>{
          // utrzymuj sp√≥jne dane: je≈õli wybierasz szuflady wew., p√≥≈Çki powinny byƒá 0 (≈ºeby nie mieszaƒá w szczeg√≥≈Çach)
          const dv = FC.utils.isPlainObject(draft.details) ? draft.details : {};
          if(String(val) === 'szuflady_wew'){
            dv.shelves = 0;
            if(!dv.innerDrawerCount) dv.innerDrawerCount = '1';
            if(!dv.innerDrawerType) dv.innerDrawerType = 'blum';
          } else {
            // p√≥≈Çki
            if(dv.shelves == null || dv.shelves === '' || Number(dv.shelves) <= 0) dv.shelves = 1;
          }
          draft.details = dv;
        });

        const inside = (draft.details && draft.details.insideMode) ? draft.details.insideMode : 'polki';
        if(inside === 'polki'){
          addNumber('Ilo≈õƒá p√≥≈Çek', 'shelves', 1);
        } else {
          addNumber('Ilo≈õƒá szuflad wewnƒôtrznych', 'innerDrawerCount', 1);
          addSelect('Typ szuflad wewnƒôtrznych', 'innerDrawerType', [
            {v:'skrzynkowe', t:'Skrzynkowe'},
            {v:'blum', t:'Systemowe BLUM'}
          ]);
        }
      } else if(corner === 'polki'){
        addNumber('Ilo≈õƒá p√≥≈Çek', 'shelves', 1);
      }
    }
  }
}

/* ===== Zestawy (presety) ===== */
function renderSetTiles(){
  const wrap = document.getElementById('setTiles');
  wrap.innerHTML = '';

  const presets = [
    {
      id:'A',
      title:'2 dolne + g√≥rny modu≈Ç',
      desc:'Dwa dolne korpusy obok siebie + g√≥rny modu≈Ç. Wysoko≈õƒá g√≥rnego = pomieszczenie - d√≥≈Ç - blenda.',
      svg: `
        <svg class="mini-svg" viewBox="0 0 56 40" xmlns="http://www.w3.org/2000/svg">
          <rect x="2" y="18" width="24" height="20" rx="3" fill="#eaf6ff" stroke="#0ea5e9" />
          <rect x="30" y="18" width="24" height="20" rx="3" fill="#eaf6ff" stroke="#0ea5e9" />
          <rect x="2" y="2" width="52" height="14" rx="3" fill="#ffffff" stroke="#94a3b8" />
        </svg>
      `
    },
    {
      id:'C',
      title:'1 pion: d√≥≈Ç + g√≥rny modu≈Ç',
      desc:'Jeden pion (d√≥≈Ç + g√≥rny modu≈Ç). Wysoko≈õƒá g√≥rnego = pomieszczenie - d√≥≈Ç - blenda.',
      svg: `
        <svg class="mini-svg" viewBox="0 0 56 40" xmlns="http://www.w3.org/2000/svg">
          <rect x="18" y="2" width="20" height="36" rx="3" fill="#eaf6ff" stroke="#0ea5e9" />
          <line x1="18" y1="22" x2="38" y2="22" stroke="#0ea5e9" stroke-width="2"/>
        </svg>
      `
    },
    {
      id:'D',
      title:'1 pion: d√≥≈Ç + ≈õrodek + g√≥ra',
      desc:'Trzy segmenty w pionie. ≈örodkowy i g√≥rny to modu≈Çy (g≈Çƒôboko≈õƒá = d√≥≈Ç - 1). Wysoko≈õƒá g√≥rnego = pomieszczenie - d√≥≈Ç - ≈õrodek - blenda.',
      svg: `
        <svg class="mini-svg" viewBox="0 0 56 40" xmlns="http://www.w3.org/2000/svg">
          <rect x="18" y="2" width="20" height="36" rx="3" fill="#ffffff" stroke="#0ea5e9" />
          <line x1="18" y1="15" x2="38" y2="15" stroke="#0ea5e9" stroke-width="2"/>
          <line x1="18" y1="26" x2="38" y2="26" stroke="#0ea5e9" stroke-width="2"/>
          <rect x="18" y="26" width="20" height="12" rx="0" fill="#eaf6ff" opacity="0.65" />
        </svg>
      `
    }
  ];

  presets.forEach(p => {
    const tile = document.createElement('div');
    tile.className = 'mini-tile' + (cabinetModalState.setPreset === p.id ? ' selected' : '');
    tile.innerHTML = `
      <div class="mini-head">
        ${p.svg}
        <div>
          <div class="mini-title">${p.title}</div>
          <div class="muted-tag xs">Zestaw standardowy</div>
        </div>
      </div>
      <div class="mini-desc">${p.desc}</div>
    `;
    tile.addEventListener('click', () => {
      cabinetModalState.setPreset = p.id;
      renderCabinetModal();
    });
    wrap.appendChild(tile);
  });
}

function renderSetParamsUI(presetId){
  const room = uiState.roomType;
  const s = projectData[room].settings;
  const paramsWrap = document.getElementById('setParams');
  paramsWrap.innerHTML = '';
  if(!presetId){ paramsWrap.style.display='none'; return; }

  paramsWrap.style.display='grid';

  function addInput(id,label,value,extra=''){
    const d = document.createElement('div');
    d.innerHTML = `<label>${label}</label><input id="${id}" type="number" value="${value}" ${extra}/>`;
    paramsWrap.appendChild(d);
  }
  function addReadonly(id,label,value){
    const d = document.createElement('div');
    d.innerHTML = `<label>${label}</label><input id="${id}" type="number" value="${value}" disabled />`;
    paramsWrap.appendChild(d);
  }

  const defaultBlende = Number(s.ceilingBlende) || 0;

  if(presetId === 'A'){
    addInput('setW1','Szer. lewa (cm)', 60);
    addInput('setW2','Szer. prawa (cm)', 60);
    addInput('setHBottom','Wys. dolnych (cm)', Number(s.bottomHeight)||82);
    addInput('setDBottom','G≈Çƒôboko≈õƒá dolnych (cm)', 51);
    addInput('setBlende','Blenda (cm)', defaultBlende);

    const hTop = calcTopForSet(room, defaultBlende, Number(s.bottomHeight)||82);
    addReadonly('setHTopResult','Wys. g√≥rnego (wynikowa)', hTop);
    addReadonly('setDTopResult','G≈Çƒôb. g√≥rnego (d√≥≈Ç-1)', Math.max(0, 51-1));
  }

  if(presetId === 'C'){
    addInput('setW','Szeroko≈õƒá (cm)', 60);
    addInput('setHBottom','Wys. dolnego z nogami (cm)', Number(s.bottomHeight)||82);
    addInput('setDBottom','G≈Çƒôboko≈õƒá dolnego (cm)', 51);
    addInput('setBlende','Blenda (cm)', defaultBlende);

    const hTop = calcTopForSet(room, defaultBlende, Number(s.bottomHeight)||82);
    addReadonly('setHTopResult','Wys. g√≥rnego (wynikowa)', hTop);
    addReadonly('setDTopResult','G≈Çƒôb. g√≥rnego (d√≥≈Ç-1)', Math.max(0, 51-1));
  }

  if(presetId === 'D'){
    addInput('setW','Szeroko≈õƒá (cm)', 60);
    addInput('setHBottom','Wys. dolnego z nogami (cm)', Number(s.bottomHeight)||82);
    addInput('setHMiddle','Wys. ≈õrodkowego (cm)', 100);
    addInput('setDBottom','G≈Çƒôboko≈õƒá dolnego (cm)', 51);
    addInput('setBlende','Blenda (cm)', defaultBlende);

    const hTop = calcTopForSet(room, defaultBlende, (Number(s.bottomHeight)||82) + 100);
    addReadonly('setHTopResult','Wys. g√≥rnego (wynikowa)', hTop);
    addReadonly('setDTopResult','G≈Çƒôb. modu≈Ç√≥w (d√≥≈Ç-1)', Math.max(0, 51-1));
  }

  wireSetParamsLiveUpdate(presetId);
}

function wireSetParamsLiveUpdate(presetId){
  const room = uiState.roomType;
  const s = projectData[room].settings;

  function val(id, fallback=0){
    const el = document.getElementById(id);
    if(!el) return fallback;
    return Number(el.value || fallback);
  }

  function update(){
    const bl = val('setBlende', Number(s.ceilingBlende)||0);

    if(presetId === 'A'){
      const db = val('setDBottom', 51);
      const hB = val('setHBottom', Number(s.bottomHeight)||82);
      const ht = calcTopForSet(room, bl, hB);
      const dt = Math.max(0, Math.round((db - 1) * 10)/10);
      const htEl = document.getElementById('setHTopResult');
      const dtEl = document.getElementById('setDTopResult');
      if(htEl) htEl.value = ht;
      if(dtEl) dtEl.value = dt;
    }

    if(presetId === 'C'){
      const db = val('setDBottom', 51);
      const hB = val('setHBottom', Number(s.bottomHeight)||82);
      const ht = calcTopForSet(room, bl, hB);
      const dt = Math.max(0, Math.round((db - 1) * 10)/10);
      const htEl = document.getElementById('setHTopResult');
      const dtEl = document.getElementById('setDTopResult');
      if(htEl) htEl.value = ht;
      if(dtEl) dtEl.value = dt;
    }

    if(presetId === 'D'){
      const db = val('setDBottom', 51);
      const hb = val('setHBottom', Number(s.bottomHeight)||82);
      const hm = val('setHMiddle', 100);
      const ht = calcTopForSet(room, bl, (hb + hm));
      const dt = Math.max(0, Math.round((db - 1) * 10)/10);
      const htEl = document.getElementById('setHTopResult');
      const dtEl = document.getElementById('setDTopResult');
      if(htEl) htEl.value = ht;
      if(dtEl) dtEl.value = dt;
    }
  }

  ['setDBottom','setBlende','setHBottom','setHMiddle'].forEach(id=>{
    const el = document.getElementById(id);
    if(el) el.addEventListener('input', update);
  });

  update();
}

/* ===== Cabinet modal render ===== */
function renderCabinetModal(){
  const isSetEdit = !!cabinetModalState.setEditId;

  // Zatwierd≈∫ w nag≈Ç√≥wku: widoczne tylko gdy pokazujemy formularz szafki (nie przy wyborze typu i nie w zestawie)
  const saveTopBtn = document.getElementById('cabinetModalSave');
  if(saveTopBtn){
    saveTopBtn.style.display = 'none';
    saveTopBtn.disabled = true;
  }

  document.getElementById('cabinetModalIcon').textContent = isSetEdit ? '‚úèÔ∏è' : (cabinetModalState.mode === 'edit' ? '‚úèÔ∏è' : '‚ûï');
  document.getElementById('cabinetModalTitle').textContent = isSetEdit ? 'Edytuj zestaw' : (cabinetModalState.mode === 'edit' ? 'Edytuj szafkƒô' : 'Dodaj');

  const choiceCard = document.getElementById('cabinetChoiceCard');
  choiceCard.style.display = isSetEdit ? 'none' : 'block';

  if(!isSetEdit){
    renderCabinetTypeChoices();
  } else {
    cabinetModalState.chosen = 'zestaw';
  }

  const formArea = document.getElementById('cabinetFormArea');
  const setArea = document.getElementById('setWizardArea');

  formArea.style.display = 'none';
  setArea.style.display = 'none';

  if(cabinetModalState.chosen === 'zestaw'){
    setArea.style.display = 'block';
    renderSetTiles();

    // W trybie zestawu poka≈º \"Zatwierd≈∫\" w nag≈Ç√≥wku (dzia≈Ça jak Dodaj zestaw / Zapisz zmiany)
    if(saveTopBtn){
      const _btn = document.getElementById('setWizardCreate');
      saveTopBtn.style.display = 'inline-flex';
      saveTopBtn.disabled = false;
      saveTopBtn.textContent = _btn ? _btn.textContent : (isSetEdit ? 'Zapisz zmiany' : 'Dodaj zestaw');
    }

    if(isSetEdit){
      document.querySelectorAll('#setTiles .mini-tile').forEach(tile=>{
        tile.style.pointerEvents = 'none';
        tile.style.opacity = '0.8';
      });
      document.getElementById('setWizardCreate').textContent = 'Zapisz zmiany';
      document.getElementById('setWizardTitle').textContent = 'Zestaw (edycja)';
      document.getElementById('setWizardDesc').textContent = 'Zmieniasz parametry zestawu. Program przeliczy korpusy i fronty.';
    } else {
      document.getElementById('setWizardCreate').textContent = 'Dodaj zestaw';
      document.getElementById('setWizardTitle').textContent = 'Zestaw';
      document.getElementById('setWizardDesc').textContent = 'Wybierz standardowy uk≈Çad. Program doda kilka korpus√≥w oraz fronty.';
    }

    const hasPreset = !!cabinetModalState.setPreset;
    renderSetParamsUI(cabinetModalState.setPreset);
    document.getElementById('setParams').style.display = hasPreset ? 'grid' : 'none';

    const frontBlock = document.getElementById('setFrontBlock');
    frontBlock.style.display = hasPreset ? 'block' : 'none';

    if(hasPreset){
      const cntSel = document.getElementById('setFrontCount');
      const matSel = document.getElementById('setFrontMaterial');
      const colSel = document.getElementById('setFrontColor');

      if(!cntSel.value) cntSel.value = '2';
      if(!matSel.value) matSel.value = 'laminat';
      populateFrontColorsTo(colSel, matSel.value, colSel.value || '');

      matSel.onchange = () => { populateFrontColorsTo(colSel, matSel.value, ''); };

      const hint = document.getElementById('setFrontHint');
      const updateHint = () => {
        const c = Number(cntSel.value || 1);
        if(c === 1){
          hint.textContent = 'Powstanie 1 front (na ca≈ÇƒÖ szeroko≈õƒá zestawu) o wysoko≈õci sumy segment√≥w.';
        } else {
          hint.textContent = 'PowstanƒÖ 2 fronty. Dla zestawu A: lewy/prawy. Dla pion√≥w: po 1/2 szeroko≈õci ka≈ºdy.';
        }
      };
      cntSel.onchange = updateHint;
      updateHint();
    }

    return;
  }

  if(!cabinetModalState.chosen) return;

  formArea.style.display = 'block';

  if(saveTopBtn){
    saveTopBtn.style.display = 'inline-flex';
    saveTopBtn.disabled = false;
  }

  // pokazujemy Zatwierd≈∫ w nag≈Ç√≥wku dopiero gdy jest formularz
  if(saveTopBtn){
    saveTopBtn.style.display = 'inline-flex';
    saveTopBtn.disabled = false;
  }

  const draft = cabinetModalState.draft;
  const room = uiState.roomType;

  // Rodzaj z kafelka
  draft.type = cabinetModalState.chosen;

  const cmSubType = document.getElementById('cmSubType');
  populateSelect(cmSubType, getSubTypeOptionsForType(draft.type), draft.subType);

  renderCabinetExtraDetailsInto(document.getElementById('cmExtraDetails'), draft);

  document.getElementById('cmWidth').value = draft.width;
  document.getElementById('cmHeight').value = draft.height;
  document.getElementById('cmDepth').value = draft.depth;

  document.getElementById('cmFrontMaterial').value = draft.frontMaterial || 'laminat';
  document.getElementById('cmBackMaterial').value = draft.backMaterial || 'HDF 3mm bia≈Ça';

  populateFrontColorsTo(document.getElementById('cmFrontColor'), draft.frontMaterial || 'laminat', draft.frontColor || '');
  populateBodyColorsTo(document.getElementById('cmBodyColor'), draft.bodyColor || '');
  populateOpeningOptionsTo(document.getElementById('cmOpeningSystem'), draft.type, draft.openingSystem || 'uchwyt klienta');

  // FRONT COUNT UI
  const fcSel = document.getElementById('cmFrontCount');
  const fcStatic = document.getElementById('cmFrontCountStatic');
  const fcHint = document.getElementById('cmFrontCountHint');
  const fcWrap = document.getElementById('cmFrontCountWrap');
  const shelvesWrap = document.getElementById('cmShelvesWrap');
  const shelvesInput = document.getElementById('cmShelves');

const flapWrap = document.getElementById('cmFlapWrap');
const flapVendorSel = document.getElementById('cmFlapVendor');
const flapKindWrap = document.getElementById('cmFlapKindWrap');
const flapKindSel = document.getElementById('cmFlapKind');
const flapInfo = document.getElementById('cmFlapInfo');
const flapFrontInfo = document.getElementById('cmFlapFrontInfo');

const isFlapDraft = ((draft.type === 'wiszƒÖca' || draft.type === 'modu≈Ç') && draft.subType === 'uchylne');

const BLUM_KINDS = [
  { v:'HKI', t:'HKI ‚Äì zintegrowany' },
  { v:'HF_top', t:'HF top ‚Äì sk≈Çadany (2 fronty)' },
  { v:'HS_top', t:'HS top ‚Äì uchylno‚ÄënachodzƒÖcy' },
  { v:'HL_top', t:'HL top ‚Äì podnoszony ponad korpus' },
  { v:'HK_top', t:'HK top ‚Äì uchylny' },
  { v:'HK-S', t:'HK‚ÄëS ‚Äì ma≈Çy uchylny' },
  { v:'HK-XS', t:'HK‚ÄëXS ‚Äì ma≈Çy uchylny (z zawiasami)' }
];
const HAFELE_KINDS = [
  { v:'DUO', t:'Rozw√≥rka no≈ºycowa DUO.' }
];

function syncFlapUI(){
  // UI dla klap (uchylne) tylko dla: wiszƒÖca + uchylne
  if(!isFlapDraft){
    if(flapWrap) flapWrap.style.display = 'none';
    return;
  }
  if(flapWrap) flapWrap.style.display = 'block';

  const d = FC.utils.isPlainObject(draft.details) ? draft.details : {};
  let vendor = String(d.flapVendor || 'blum');
  if(!['blum','gtv','hafele'].includes(vendor)) vendor = 'blum';
  d.flapVendor = vendor;

  // vendor select
  if(flapVendorSel){
    flapVendorSel.value = vendor;
    flapVendorSel.onchange = () => {
      const dv = FC.utils.isPlainObject(draft.details) ? draft.details : {};
      const v = String(flapVendorSel.value || 'blum');
      dv.flapVendor = (['blum','gtv','hafele'].includes(v) ? v : 'blum');

      // domy≈õlne rodzaje po zmianie firmy
      if(dv.flapVendor === 'hafele') dv.flapKind = 'DUO';
      else if(dv.flapVendor === 'gtv') dv.flapKind = '';
      else dv.flapKind = 'HKI';

      draft.details = dv;
      ensureFrontCountRules(draft);
      renderCabinetModal();
    };
  }

  // vendor specific UI
  if(vendor === 'gtv'){
    if(flapKindWrap) flapKindWrap.style.display = 'none';
    if(flapInfo){
      flapInfo.style.display = 'block';
      flapInfo.textContent = 'GTV ‚Äì w budowie.';
    }
    draft.details = d;
    ensureFrontCountRules(draft);
    return;
  }

  if(flapInfo) flapInfo.style.display = 'none';
  if(flapKindWrap) flapKindWrap.style.display = 'block';

  const kindOptions = (vendor === 'hafele') ? HAFELE_KINDS : BLUM_KINDS;
  const defaultKind = (vendor === 'hafele') ? 'DUO' : 'HKI';
  const selectedKind = String(d.flapKind || defaultKind);
  d.flapKind = selectedKind;

  if(flapKindSel){
    populateSelect(flapKindSel, kindOptions, selectedKind);
    flapKindSel.onchange = () => {
      const dv = FC.utils.isPlainObject(draft.details) ? draft.details : {};
      dv.flapKind = String(flapKindSel.value || defaultKind);
      draft.details = dv;
      ensureFrontCountRules(draft);
      renderCabinetModal();
    };
  }

  draft.details = d;
  ensureFrontCountRules(draft);
}

  // Podblatowa (wiszƒÖca dolna): pozw√≥l na brak front√≥w oraz rozr√≥≈ºnij drzwi vs szuflady
  const isPodblatowaDraft = (draft.type === 'wiszƒÖca' && draft.subType === 'dolna_podblatowa');
  const fcLabelEl = document.getElementById('cmFrontCountLabel');
  const setFcOptions = (arr) => {
    fcSel.innerHTML = arr.map(n => `<option value="${n}">${n}</option>`).join('');
  };

  if(isPodblatowaDraft){
    const d = draft.details || {};
    // domy≈õlne warto≈õci + kompatybilno≈õƒá wstecz
    if(!d.podFrontMode){
      if(d.subTypeOption === 'szuflada_1'){ d.podFrontMode = 'szuflady'; draft.frontCount = 1; }
      else if(d.subTypeOption === 'szuflada_2'){ d.podFrontMode = 'szuflady'; draft.frontCount = 2; }
      else d.podFrontMode = (Number(draft.frontCount) === 0 ? 'brak' : 'drzwi');
      draft.details = Object.assign({}, d, { podFrontMode: d.podFrontMode });
    }
    if(fcLabelEl){
      fcLabelEl.textContent = (d.podFrontMode === 'szuflady') ? 'Ilo≈õƒá szuflad' : 'Ilo≈õƒá front√≥w';
    }
    if(d.podFrontMode === 'brak'){
      setFcOptions([0]);
      draft.frontCount = 0;
      fcSel.disabled = true;
      if(fcHint) fcHint.textContent = 'Otwarta szafka (bez front√≥w).';
    } else {
      setFcOptions([1,2]);
      if(![1,2].includes(Number(draft.frontCount))) draft.frontCount = 2;
      fcSel.disabled = false;
      if(fcHint) fcHint.textContent = (d.podFrontMode === 'szuflady') ? 'Ilo≈õƒá szuflad = ilo≈õƒá front√≥w szuflad.' : 'Ilo≈õƒá drzwi/front√≥w.';
    }
  } else {
    // standardowe opcje: 1 lub 2 fronty
    if(fcLabelEl) fcLabelEl.textContent = 'Ilo≈õƒá front√≥w';
    setFcOptions([1,2]);
  }

  ensureFrontCountRules(draft);
  syncFlapUI();

  // Domy≈õlnie pokazuj select, a statyczne info ukrywaj (wyjƒÖtek: klapy)
  if(fcSel) fcSel.style.display = '';
  if(fcStatic){
    fcStatic.style.display = 'none';
    fcStatic.textContent = '';
  }

  // czy pokazujemy wyb√≥r 1/2?
  const canPick = cabinetAllowsFrontCount(draft);
  const fixedOne = (draft.type === 'stojƒÖca' && (draft.subType === 'zmywarkowa' || draft.subType === 'piekarnikowa' || (draft.subType === 'rogowa_slepa' && (draft.details?.cornerOption||'polki') === 'magic_corner'))) || (draft.type === 'stojƒÖca' && draft.subType === 'zlewowa' && (draft.details?.sinkFront||'drzwi') === 'szuflada');
  const isFridge = (draft.type === 'stojƒÖca' && draft.subType === 'lodowkowa');

  // lod√≥wkowa w zabudowie ‚Äî zamiast frontCount u≈ºywamy details.fridgeFrontCount (1/2)
  const isCornerL = (draft.subType === 'narozna_l');

  if(isFridge){
    // frontCount select ukrywamy (bo fronty lod√≥wki wybiera siƒô w szczeg√≥≈Çach lod√≥wki)
    if(fcWrap) fcWrap.style.display = 'none';
    fcHint.style.display = 'none';
    if(shelvesWrap) shelvesWrap.style.display = 'none';
  } else if(isCornerL){
    // naro≈ºna L: zawsze 2 fronty, zamiast wyboru front√≥w pokazujemy ilo≈õƒá p√≥≈Çek
    draft.frontCount = 2;

    if(fcWrap) fcWrap.style.display = 'none';
    fcHint.style.display = 'none';

    if(shelvesWrap){
      shelvesWrap.style.display = 'block';
      const d = FC.utils.isPlainObject(draft.details) ? draft.details : {};
      const sh = (d.shelves == null ? 2 : Number(d.shelves));
      draft.details = Object.assign({}, d, { shelves: Math.max(0, Math.round(Number.isFinite(sh) ? sh : 0)) });

      if(shelvesInput){
        shelvesInput.value = String(draft.details.shelves);
        const onShelvesChange = () => {
          const v = Math.max(0, Math.round(Number(shelvesInput.value) || 0));
          draft.details = Object.assign({}, draft.details || {}, { shelves: v });
          shelvesInput.value = String(v);
        };
        shelvesInput.oninput = onShelvesChange;
        shelvesInput.onchange = onShelvesChange;
      }
    }
  } else if(isFlapDraft){
    // Klapa: ilo≈õƒá front√≥w jest automatyczna (1 lub 2 zale≈ºnie od rodzaju)
    // P√≥≈Çki: u≈ºytkownik mo≈ºe wpisaƒá (do wyceny i rozrysu)
    if(shelvesWrap) shelvesWrap.style.display = 'block';
    if(!draft.details) draft.details = {};
    if(draft.details.shelves === undefined || draft.details.shelves === null) draft.details.shelves = 0;
    if(shelvesInput){
      shelvesInput.value = String(Math.max(0, Math.round(Number(draft.details.shelves) || 0)));
      const onShelvesChange = () => {
        const v = Math.max(0, Math.round(Number(shelvesInput.value) || 0));
        draft.details = Object.assign({}, draft.details || {}, { shelves: v });
        shelvesInput.value = String(v);
      };
      shelvesInput.oninput = onShelvesChange;
      shelvesInput.onchange = onShelvesChange;
    }


    const fcAuto = getFlapFrontCount(draft);
    // dla klap ilo≈õƒá front√≥w jest automatyczna i pokazujemy jƒÖ pod wyborem podno≈õnika
    if(fcWrap) fcWrap.style.display = 'none';
    if(fcSel){
      fcSel.style.display = 'none';
      fcSel.innerHTML = `<option value="${fcAuto}">${fcAuto}</option>`;
      fcSel.value = String(fcAuto);
      fcSel.disabled = true;
    }
    if(fcStatic) fcStatic.style.display = 'none';
    if(fcHint) fcHint.style.display = 'none';
    if(flapFrontInfo){
      flapFrontInfo.style.display = 'inline-block';
      flapFrontInfo.textContent = `Ilo≈õƒá front√≥w: ${fcAuto}` + ((fcAuto === 2) ? ' (HF top)' : '');
    }
  } else if(!canPick){
    if(fcWrap) fcWrap.style.display = 'none';
    fcHint.style.display = 'none';
    if(shelvesWrap) shelvesWrap.style.display = 'none';
  } else if(fixedOne){
    if(fcWrap) fcWrap.style.display = 'block';
    if(shelvesWrap) shelvesWrap.style.display = 'none';

    fcSel.value = '1';
    fcSel.disabled = true;
    fcHint.style.display = 'block';
    fcHint.textContent = 'Dla tej szafki ilo≈õƒá front√≥w jest sta≈Ça: 1.';
  } else {
    if(fcWrap) fcWrap.style.display = 'block';
    if(shelvesWrap) shelvesWrap.style.display = 'none';

    const podBrak = (isPodblatowaDraft && draft.details && draft.details.podFrontMode === 'brak');
    fcSel.disabled = podBrak ? true : false;
    const fcVal = (draft.frontCount === 0 ? 0 : (draft.frontCount || 2));
    fcSel.value = String(fcVal);
    if(podBrak){
      fcHint.style.display = 'block';
      fcHint.textContent = 'Otwarta szafka (bez front√≥w).';
    } else {
      fcHint.style.display = 'none';
    }
  }

  cmSubType.onchange = () => {
    applySubTypeRules(room, draft, cmSubType.value);
ensureFrontCountRules(draft);

// Modu≈Ç ‚Üí Uchylna: wymu≈õ tryb klapy i wyczy≈õƒá ewentualne dane po szufladach
if(draft.type === 'modu≈Ç' && cmSubType.value === 'uchylne'){
  draft.subType = 'uchylne';
  draft.details = FC.utils.isPlainObject(draft.details) ? draft.details : {};
  // fronty dla klapy wynikajƒÖ z rodzaju podno≈õnika (HF top = 2)
  draft.frontCount = getFlapFrontCount(draft);
}

// zmywarkowa: szeroko≈õƒá szafki = szeroko≈õƒá zmywarki + przegrody techniczne dla wysokich front√≥w
if(draft.type === 'stojƒÖca' && draft.subType === 'zmywarkowa'){
  const leg = Number(projectData[room]?.settings?.legHeight) || 0;
  const dw = (draft.details && draft.details.dishWasherWidth) ? draft.details.dishWasherWidth : (String(draft.width || '60'));
  draft.details = Object.assign({}, draft.details || {}, { dishWasherWidth: dw });
  draft.width = Number(dw) || 60;

  const frontH = (Number(draft.height) || 0) - leg;
  // Przegroda techniczna: 74.6‚Äì76.5 => 1; 76.6‚Äì78.5 => 2; itd.
  const div = (frontH > 74.5) ? Math.max(0, Math.ceil(((frontH - 74.5) / 2) - 1e-9)) : 0;
  draft.details = Object.assign({}, draft.details, { techDividerCount: String(div) });
}

    renderCabinetModal();
  };

  fcSel.onchange = () => {
    draft.frontCount = Number(fcSel.value || 2);
  };

  document.getElementById('cmWidth').onchange = e => { draft.width = parseFloat(e.target.value || 0); };

  // Live re-check dla uchylnych: po zmianie wysoko≈õci od razu przelicz LF i sprawd≈∫ zakresy
  const _liveAventosCheck = () => {
    try{
      const room = uiState.roomType;
      syncDraftFromCabinetModalForm(draft);
      ensureFrontCountRules(draft);

      // Walidacja szuflad systemowych (GTV/Rejs ‚Äì w budowie -> blokada zapisu)
      const _drawerBlockMsg = (function(){
        const dd = draft.details || {};
        const checkSystem = (sys, brand, ctx) => {
          if(String(sys||'') !== 'systemowe') return null;
          const b = String(brand||'blum');
          if(b !== 'blum') return `Szuflady ${ctx}: ${b.toUpperCase()} ‚Äì w budowie. Nie mo≈ºna zatwierdziƒá.`;
          return null;
        };
        // g≈Ç√≥wna szuflada (szufladowa / modu≈Ç / zlewowa front / piekarnikowa)
        let m = checkSystem(dd.drawerSystem, dd.drawerBrand, 'frontowe');
        if(m) return m;
        // zlewowa: szuflada wewnƒôtrzna
        m = checkSystem(dd.sinkInnerDrawerType, dd.sinkInnerDrawerBrand, 'wewnƒôtrzne (zlewowa)');
        if(m) return m;
        return null;
      })();
      if(_drawerBlockMsg){ alert(_drawerBlockMsg); return; }
      applyAventosValidationUI(room, draft);
    }catch(_e){ /* nie psuj modala */ }
  };
  const _cmHeightEl = document.getElementById('cmHeight');
  if(_cmHeightEl){
    _cmHeightEl.oninput = _liveAventosCheck;
    _cmHeightEl.onchange = _liveAventosCheck;
  }

  const _cmWidthEl = document.getElementById('cmWidth');
  if(_cmWidthEl){
    _cmWidthEl.oninput = _liveAventosCheck;
    _cmWidthEl.onchange = _liveAventosCheck;
  }
  const _cmDepthEl = document.getElementById('cmDepth');
  if(_cmDepthEl){
    _cmDepthEl.oninput = _liveAventosCheck;
    _cmDepthEl.onchange = _liveAventosCheck;
  }

  document.getElementById('cmFrontMaterial').onchange = e => {
    draft.frontMaterial = e.target.value;
    const first = materials.find(m => m.materialType === draft.frontMaterial);
    draft.frontColor = first ? first.name : '';
    renderCabinetModal();
  };
  document.getElementById('cmFrontColor').onchange = e => { draft.frontColor = e.target.value; };
  document.getElementById('cmBackMaterial').onchange = e => { draft.backMaterial = e.target.value; };
  document.getElementById('cmBodyColor').onchange = e => { draft.bodyColor = e.target.value; };
  document.getElementById('cmOpeningSystem').onchange = e => { draft.openingSystem = e.target.value; };

  const _cabCancel = document.getElementById('cabinetModalCancel');
  if(_cabCancel) _cabCancel.onclick = closeCabinetModal;
  document.getElementById('cabinetModalSave').onclick = (e) => {
    // twarde zabezpieczenie: ≈ºadnego "przebicia" klikniƒôcia do innych handler√≥w
    if(e){ e.preventDefault(); e.stopPropagation(); }

    // Tryb zestawu: Zatwierd≈∫ dzia≈Ça jak "Dodaj zestaw / Zapisz zmiany"
    const _setArea = document.getElementById('setWizardArea');
    const inSetMode = (cabinetModalState && cabinetModalState.chosen === 'zestaw') ||
                      (cabinetModalState && cabinetModalState.setEditId) ||
                      (_setArea && _setArea.style.display === 'block');
    if(inSetMode){
      try{
        createOrUpdateSetFromWizard();
      } catch(err){
        console.error(err);
        alert('B≈ÇƒÖd zapisu zestawu: ' + (err && (err.message || err) ? (err.message || err) : 'nieznany b≈ÇƒÖd'));
      }
      return;
    }
    try{
      if(!uiState.roomType){ alert('Wybierz pomieszczenie'); return; }
      const room = uiState.roomType;

      syncDraftFromCabinetModalForm(draft);
      ensureFrontCountRules(draft);

      // Walidacja podno≈õnik√≥w (AVENTOS) na etapie zapisu ‚Äì je≈õli poza zakresem, nie dodawaj/nie zapisuj
      const _av = validateAventosForDraft(room, draft);
      if(_av && _av.ok === false){
        applyAventosValidationUI(room, draft);
        return;
      }

      const beforeCount = (projectData[room].cabinets || []).length;

      const isAdd = (cabinetModalState.mode === 'add' || !cabinetModalState.editingId);
      if(isAdd){
        const newCab = FC.utils.clone(draft);
        newCab.id = FC.utils.uid();
        projectData[room].cabinets.push(newCab);
        uiState.expanded = {};
        // domy≈õlnie zwiniƒôte
        
        uiState.selectedCabinetId = newCab.id;

        // generuj fronty je≈õli trzeba (lod√≥wkowa te≈º)
        generateFrontsForCabinet(room, newCab);
      } else {
        const id = cabinetModalState.editingId;
        projectData[room].cabinets = projectData[room].cabinets.map(c => c.id === id ? Object.assign({}, FC.utils.clone(draft), { id }) : c);

        const updated = projectData[room].cabinets.find(c => c.id === id);
        if(updated) generateFrontsForCabinet(room, updated);
      }

      projectData = FC.project.save(projectData);
      FC.storage.setJSON(STORAGE_KEYS.ui, uiState);

      // najpierw od≈õwie≈º widok ‚Äî je≈õli co≈õ siƒô wysypie, modal ma zostaƒá otwarty
      renderCabinets();

      const afterCount = (projectData[room].cabinets || []).length;
      if(isAdd && afterCount <= beforeCount){
        alert('Nie uda≈Ço siƒô dodaƒá szafki (b≈ÇƒÖd logiki zapisu).');
        return;
      }

      closeCabinetModal();
    }catch(err){
      console.error('B≈ÇƒÖd zapisu szafki:', err);
      alert('B≈ÇƒÖd podczas zapisu (sprawd≈∫ konsolƒô). Modal pozostaje otwarty.');
    }
  };

  // Walidacja klapy (AVENTOS) ‚Äì blokuj zapis je≈õli poza zakresem
  applyAventosValidationUI(room, draft);
}

/* ===== create fronts for sets ===== */
function createFrontsForSet(room, presetId, frontCount, frontMaterial, frontColor, dims, setId, setNumber){
  const fc = Number(frontCount||1);

  if(presetId === 'A'){
    const { w1, w2, hB, hTop } = dims;
    const totalH = (Number(hB)||0) + (Number(hTop)||0);
    if(fc === 1){
      addFront(room, { setId, setNumber, material: frontMaterial, color: frontColor, width: (Number(w1)||0) + (Number(w2)||0), height: totalH, note: `Zestaw ${setNumber}: 1 front` });
    } else {
      addFront(room, { setId, setNumber, material: frontMaterial, color: frontColor, width: (Number(w1)||0), height: totalH, note: `Zestaw ${setNumber}: front lewy` });
      addFront(room, { setId, setNumber, material: frontMaterial, color: frontColor, width: (Number(w2)||0), height: totalH, note: `Zestaw ${setNumber}: front prawy` });
    }
    return;
  }

  if(presetId === 'C'){
    const { w, hB, hTop } = dims;
    const totalH = (Number(hB)||0) + (Number(hTop)||0);
    if(fc === 1){
      addFront(room, { setId, setNumber, material: frontMaterial, color: frontColor, width: (Number(w)||0), height: totalH, note: `Zestaw ${setNumber}: 1 front` });
    } else {
      const half = Math.round(((Number(w)||0) / 2) * 10)/10;
      addFront(room, { setId, setNumber, material: frontMaterial, color: frontColor, width: half, height: totalH, note: `Zestaw ${setNumber}: front 1/2` });
      addFront(room, { setId, setNumber, material: frontMaterial, color: frontColor, width: (Number(w)||0) - half, height: totalH, note: `Zestaw ${setNumber}: front 2/2` });
    }
    return;
  }

  if(presetId === 'D'){
    const { w, hB, hM, hTop } = dims;
    const totalH = (Number(hB)||0) + (Number(hM)||0) + (Number(hTop)||0);
    if(fc === 1){
      addFront(room, { setId, setNumber, material: frontMaterial, color: frontColor, width: (Number(w)||0), height: totalH, note: `Zestaw ${setNumber}: 1 front` });
    } else {
      const half = Math.round(((Number(w)||0) / 2) * 10)/10;
      addFront(room, { setId, setNumber, material: frontMaterial, color: frontColor, width: half, height: totalH, note: `Zestaw ${setNumber}: front 1/2` });
      addFront(room, { setId, setNumber, material: frontMaterial, color: frontColor, width: (Number(w)||0) - half, height: totalH, note: `Zestaw ${setNumber}: front 2/2` });
    }
    return;
  }
}

/* ===== Zestaw: odczyt/wpis parametr√≥w UI ===== */
function getSetParamsFromUI(presetId){
  const room = uiState.roomType;
  const s = projectData[room].settings;

  function num(id, fallback=0){
    const el = document.getElementById(id);
    if(!el) return fallback;
    return Number(el.value || fallback);
  }

  const blende = num('setBlende', Number(s.ceilingBlende)||0);
  const dBottom = num('setDBottom', 51);
  const dModule = Math.max(0, Math.round((dBottom - 1)*10)/10);

  if(presetId === 'A'){
    const w1 = num('setW1', 60);
    const w2 = num('setW2', 60);
    const hB = num('setHBottom', Number(s.bottomHeight)||82);
    const hTop = calcTopForSet(room, blende, hB);
    return { presetId, w1,w2, hB, hTop, dBottom, dModule, blende };
  }
  if(presetId === 'C'){
    const w = num('setW', 60);
    const hB = num('setHBottom', Number(s.bottomHeight)||82);
    const hTop = calcTopForSet(room, blende, hB);
    return { presetId, w, hB, hTop, dBottom, dModule, blende };
  }
  if(presetId === 'D'){
    const w = num('setW', 60);
    const hB = num('setHBottom', Number(s.bottomHeight)||82);
    const hM = num('setHMiddle', 100);
    const hTop = calcTopForSet(room, blende, (hB + hM));
    return { presetId, w, hB, hM, hTop, dBottom, dModule, blende };
  }
  return null;
}

function fillSetParamsUIFromSet(set){
  renderSetParamsUI(set.presetId);

  const p = set.params || {};
  function setVal(id,v){
    const el = document.getElementById(id);
    if(el && v != null && !el.disabled) el.value = v;
  }

  if(set.presetId === 'A'){
    setVal('setW1', p.w1);
    setVal('setW2', p.w2);
    setVal('setHBottom', p.hB);
    setVal('setDBottom', p.dBottom);
    setVal('setBlende', p.blende);
  }
  if(set.presetId === 'C'){
    setVal('setW', p.w);
    setVal('setHBottom', p.hB);
    setVal('setDBottom', p.dBottom);
    setVal('setBlende', p.blende);
  }
  if(set.presetId === 'D'){
    setVal('setW', p.w);
    setVal('setHBottom', p.hB);
    setVal('setHMiddle', p.hM);
    setVal('setDBottom', p.dBottom);
    setVal('setBlende', p.blende);
  }

  const cntSel = document.getElementById('setFrontCount');
  const matSel = document.getElementById('setFrontMaterial');
  const colSel = document.getElementById('setFrontColor');

  if(cntSel && set.frontCount) cntSel.value = String(set.frontCount);
  if(matSel && set.frontMaterial) matSel.value = set.frontMaterial;
  if(colSel){
    populateFrontColorsTo(colSel, (matSel ? matSel.value : 'laminat'), set.frontColor || '');
    colSel.value = set.frontColor || colSel.value;
  }

  wireSetParamsLiveUpdate(set.presetId);
}

/* ===== Create/Update set ===== */
function getNextSetNumber(room){
  const arr = projectData[room].sets || [];
  let max = 0;
  arr.forEach(s=>{ if(typeof s.number === 'number') max = Math.max(max, s.number); });
  return max + 1;
}

function createOrUpdateSetFromWizard(){
  const room = uiState.roomType; if(!room){ alert('Wybierz pomieszczenie'); return; }
  const presetId = cabinetModalState.setPreset;
  if(!presetId){ alert('Wybierz zestaw'); return; }

  const params = getSetParamsFromUI(presetId);
  if(!params){ alert('Brak parametr√≥w'); return; }

  const frontCount = Number(document.getElementById('setFrontCount').value || 1);
  const frontMaterial = document.getElementById('setFrontMaterial').value;
  const frontColor = document.getElementById('setFrontColor').value || '';

  const isEdit = !!cabinetModalState.setEditId;
  const setId = isEdit ? cabinetModalState.setEditId : FC.utils.uid();

  let setNumber;
  if(isEdit){
    const old = projectData[room].sets.find(s=>s.id===setId);
    setNumber = old && typeof old.number === 'number' ? old.number : getNextSetNumber(room);
  } else {
    setNumber = getNextSetNumber(room);
  }

  const base = makeDefaultCabinetDraftForRoom(room);

  function finalizeCab(c){
    c.id = c.id || FC.utils.uid();
    if(!c.details) c.details = FC.utils.clone(base.details || {});
    if(!c.bodyColor) c.bodyColor = base.bodyColor;
    if(!c.frontMaterial) c.frontMaterial = base.frontMaterial || 'laminat';
    if(!c.frontColor){
      const first = materials.find(m => m.materialType === c.frontMaterial);
      c.frontColor = first ? first.name : '';
    }
    if(!c.openingSystem) c.openingSystem = base.openingSystem || 'uchwyt klienta';
    if(!c.backMaterial) c.backMaterial = base.backMaterial || 'HDF 3mm bia≈Ça';
    c.setId = setId;
    c.setPreset = presetId;
    c.setNumber = setNumber;
    c.setName = `Zestaw ${setNumber}`;
    return c;
  }

  if(isEdit){
    projectData[room].cabinets = projectData[room].cabinets.filter(c => c.setId !== setId);
    removeFrontsForSet(room, setId);
  }

  const created = [];

  if(presetId === 'A'){
    const cab1 = finalizeCab(Object.assign({}, FC.utils.clone(base), { type:'stojƒÖca', subType:'standardowa', width:params.w1, height:params.hB, depth:params.dBottom, setRole:'dolny_lewy', frontCount:2 }));
    const cab2 = finalizeCab(Object.assign({}, FC.utils.clone(base), { type:'stojƒÖca', subType:'standardowa', width:params.w2, height:params.hB, depth:params.dBottom, setRole:'dolny_prawy', frontCount:2 }));
    const top = finalizeCab(Object.assign({}, FC.utils.clone(base), { type:'modu≈Ç', subType:'standardowa', width:(params.w1+params.w2), height:params.hTop, depth:params.dModule, setRole:'gorny_modul', frontCount:0 }));
    created.push(cab1, cab2, top);

    createFrontsForSet(room, 'A', frontCount, frontMaterial, frontColor, {w1:params.w1,w2:params.w2,hB:params.hB,hTop:params.hTop}, setId, setNumber);
  }

  if(presetId === 'C'){
    const bottom = finalizeCab(Object.assign({}, FC.utils.clone(base), { type:'stojƒÖca', subType:'standardowa', width:params.w, height:params.hB, depth:params.dBottom, setRole:'dolny', frontCount:2 }));
    const top = finalizeCab(Object.assign({}, FC.utils.clone(base), { type:'modu≈Ç', subType:'standardowa', width:params.w, height:params.hTop, depth:params.dModule, setRole:'gorny_modul', frontCount:0 }));
    created.push(bottom, top);

    createFrontsForSet(room, 'C', frontCount, frontMaterial, frontColor, {w:params.w,hB:params.hB,hTop:params.hTop}, setId, setNumber);
  }

  if(presetId === 'D'){
    const bottom = finalizeCab(Object.assign({}, FC.utils.clone(base), { type:'stojƒÖca', subType:'standardowa', width:params.w, height:params.hB, depth:params.dBottom, setRole:'dolny', frontCount:2 }));
    const middle = finalizeCab(Object.assign({}, FC.utils.clone(base), { type:'modu≈Ç', subType:'standardowa', width:params.w, height:params.hM, depth:params.dModule, setRole:'srodkowy_modul', frontCount:0 }));
    const top = finalizeCab(Object.assign({}, FC.utils.clone(base), { type:'modu≈Ç', subType:'standardowa', width:params.w, height:params.hTop, depth:params.dModule, setRole:'gorny_modul', frontCount:0 }));
    created.push(bottom, middle, top);

    createFrontsForSet(room, 'D', frontCount, frontMaterial, frontColor, {w:params.w,hB:params.hB,hM:params.hM,hTop:params.hTop}, setId, setNumber);
  }

  created.forEach(c => {
    projectData[room].cabinets.push(c);
    // domy≈õlnie zwiniƒôte
    
  });

  const setRecord = {
    id: setId,
    presetId,
    number: setNumber,
    params,
    frontCount,
    frontMaterial,
    frontColor
  };

  if(isEdit){
    projectData[room].sets = projectData[room].sets.map(s => s.id===setId ? setRecord : s);
  } else {
    projectData[room].sets.push(setRecord);
  }

  projectData = FC.project.save(projectData);
  FC.storage.setJSON(STORAGE_KEYS.ui, uiState);

  closeCabinetModal();
  renderCabinets();
}

/* ===== Read-only: cabinet details summary ===== */
function getCabinetExtraSummary(room, cab){
  const d = cab.details || {};
  const parts = [];

  // wiszƒÖca: dolna_podblatowa ma osobny model (front + wnƒôtrze)
  if(cab.type === 'wiszƒÖca' && cab.subType === 'dolna_podblatowa'){
    const mode = d.podFrontMode || (d.subTypeOption && String(d.subTypeOption).startsWith('szuflada') ? 'szuflady' : ((Number(cab.frontCount)||0) ? 'drzwi' : 'brak'));
    const inside = d.podInsideMode || 'polki';

    const getInnerCount = ()=>{
      const v = (d.podInnerDrawerCount ?? d.podInsideDrawerCount ?? d.podInsideDrawersCount);
      const n = parseInt(v, 10);
      return (Number.isFinite(n) && n > 0) ? n : 1;
    };

    if(mode === 'brak' || (Number(cab.frontCount)||0) === 0){
      parts.push('Front: brak');
    } else if(mode === 'szuflady'){
      parts.push(`Front: szuflady ${Number(cab.frontCount)||1}`);
    } else {
      parts.push(`Front: drzwi ${Number(cab.frontCount)||1}`);
    }

    if(mode !== 'szuflady'){
      // Nie pokazuj p√≥≈Çek dla wariant√≥w, gdzie to myli (np. zmywarka/lod√≥wka)
      const skipShelves = (cab.subType === 'zmywarkowa' || cab.subType === 'lodowkowa');
      if(inside === 'polki'){
        if(!skipShelves && ((d.shelves ?? 0) > 0)) parts.push(`P√≥≈Çki: ${d.shelves}`);
      } else if(inside === 'szuflady_wew' || inside === 'szuflady_wewn'){
        parts.push(`Szuflady wew.: ${getInnerCount()}`);
      } else if(inside === 'mieszane'){
        if(((d.shelves ?? 0) > 0)) parts.push(`P√≥≈Çki: ${d.shelves}`);
        parts.push(`Szuflady wew.: ${getInnerCount()}`);
      }
    }

    // Plecy (tak/nie) ‚Äî kr√≥tko w szczeg√≥≈Çach
    const hasBack = String(d.hasBack) !== '0';
    parts.push('Plecy: ' + (hasBack ? 'tak' : 'nie'));


    return parts.join(' ‚Ä¢ ');
  }

  // pozosta≈Çe wiszƒÖce
  if(cab.type === 'wiszƒÖca'){
    if(cab.subType === 'uchylne'){
      const vendor = String(d.flapVendor || 'blum');
      const kind = String(d.flapKind || (vendor === 'hafele' ? 'DUO' : 'HKI'));

      const vendorLabel = (vendor === 'blum') ? 'BLUM'
                        : (vendor === 'gtv') ? 'GTV'
                        : 'H√§fele';

      const blumKindLabel = ({
        'HKI':'HKI ‚Äì zintegrowany',
        'HF_top':'HF top ‚Äì sk≈Çadany (2 fronty)',
        'HS_top':'HS top ‚Äì uchylno‚ÄënachodzƒÖcy',
        'HL_top':'HL top ‚Äì podnoszony ponad korpus',
        'HK_top':'HK top ‚Äì uchylny',
        'HK-S':'HK‚ÄëS ‚Äì ma≈Çy uchylny',
        'HK-XS':'HK‚ÄëXS ‚Äì ma≈Çy uchylny (z zawiasami)'
      })[kind] || kind;

      const kindLabel = (vendor === 'blum') ? blumKindLabel
                      : (vendor === 'hafele') ? 'Rozw√≥rka no≈ºycowa DUO.'
                      : '(w budowie)';

      parts.push(`Podno≈õniki: ${vendorLabel} ‚Ä¢ ${kindLabel}`);
    }
    if(((d.shelves ?? 0) > 0)) parts.push(`P√≥≈Çki: ${d.shelves}`);
    if(cab.frontCount) parts.push(`Fronty: ${cab.frontCount}`);
    return parts.join(' ‚Ä¢ ');
  }

  // modu≈Ç
  if(cab.type === 'modu≈Ç'){
    // standardowa: wnƒôtrze (p√≥≈Çki / szuflady wewnƒôtrzne)
    if(cab.subType === 'standardowa'){
      const inside = String(d.insideMode || 'polki');
      if(inside === 'szuflady_wew'){
        const n = parseInt(d.innerDrawerCount, 10);
        const cnt = (Number.isFinite(n) && n > 0) ? n : 1;
        const it = String(d.innerDrawerType || 'skrzynkowe');
        parts.push(`Szuflady wew.: ${cnt}${it === 'blum' ? ' (BLUM)' : ''}`);
      } else {
        const n = parseInt(d.shelves, 10);
        const cnt = (Number.isFinite(n) && n > 0) ? n : 0;
        if(cnt > 0) parts.push(`P√≥≈Çki: ${cnt}`);
      }
    }
    if(cab.subType === 'uchylne'){
      const vendor = String(d.flapVendor || 'blum');
      const kind = String(d.flapKind || (vendor === 'hafele' ? 'DUO' : 'HKI'));

      const vendorLabel = (vendor === 'blum') ? 'BLUM'
                        : (vendor === 'gtv') ? 'GTV'
                        : 'H√§fele';

      const blumKindLabel = ({
        'HKI':'HKI ‚Äì zintegrowany',
        'HF_top':'HF top ‚Äì sk≈Çadany (2 fronty)',
        'HS_top':'HS top ‚Äì uchylno‚ÄënachodzƒÖcy',
        'HL_top':'HL top ‚Äì podnoszony ponad korpus',
        'HK_top':'HK top ‚Äì uchylny',
        'HK-S':'HK‚ÄëS ‚Äì ma≈Çy uchylny',
        'HK-XS':'HK‚ÄëXS ‚Äì ma≈Çy uchylny (z zawiasami)'
      })[kind] || kind;

      const kindLabel = (vendor === 'blum') ? blumKindLabel
                      : (vendor === 'hafele') ? 'Rozw√≥rka no≈ºycowa DUO.'
                      : '(w budowie)';

      parts.push(`Podno≈õniki: ${vendorLabel} ‚Ä¢ ${kindLabel}`);
    }
    if(cab.subType === 'szuflady'){
      const lay = String(d.drawerLayout || '');
      let label = '';
      if(lay === '1_big') label = '1 du≈ºa';
      else if(lay === '2_equal') label = '2 r√≥wne';
      else if(lay === '3_equal') label = '3 r√≥wne';
      else if(lay === '5_equal') label = '5 r√≥wnych';
      else if(lay === '3_1_2_2') label = '1 ma≈Ça + 2 du≈ºe (1:2:2)';
      else {
        const lc = String(d.drawerCount || '3');
        if(lc === '1') label = '1 du≈ºa';
        else if(lc === '2') label = '2 r√≥wne';
        else if(lc === '5') label = '5 r√≥wnych';
        else if(lc === '3') label = '1 ma≈Ça + 2 du≈ºe (1:2:2)';
        else label = '3 r√≥wne';
      }
      const sys = String(d.drawerSystem || 'skrzynkowe');
      let sysLabel = 'Skrzynkowe';
      if(sys === 'systemowe'){
        const br = String(d.drawerBrand || 'blum');
        if(br !== 'blum'){
          sysLabel = br.toUpperCase() + ' (w budowie)';
        } else {
          const mdl = String(d.drawerModel || 'tandembox');
          const map = {tandembox:'TANDEMBOX', legrabox:'LEGRABOX', merivobox:'MERIVOBOX', metabox:'METABOX'};
          sysLabel = 'BLUM ' + (map[mdl] || mdl.toUpperCase());
        }
      }
      parts.push(`Szuflady: ${label} ‚Ä¢ ${sysLabel}`);

      const innerType = String(d.innerDrawerType || 'brak');
      const innerCnt = parseInt(d.innerDrawerCount, 10);
      if(innerType !== 'brak' && Number.isFinite(innerCnt) && innerCnt > 0){
        parts.push(`Szuflady wew.: ${innerCnt}${innerType === 'blum' ? ' (BLUM)' : ''}`);
      }
    }
    if(((d.shelves ?? 0) > 0)) parts.push(`P√≥≈Çki: ${d.shelves}`);
    if(cab.subType !== 'szuflady' && cab.frontCount) parts.push(`Fronty: ${cab.frontCount}`);
    return parts.join(' ‚Ä¢ ');
  }

  // stojƒÖce
  if(cab.type === 'stojƒÖca'){
    if(cab.subType === 'szuflady'){
      const lay = String(d.drawerLayout || '');
      let label = '';
      if(lay === '1_big') label = '1 du≈ºa';
      else if(lay === '2_equal') label = '2 r√≥wne';
      else if(lay === '3_equal') label = '3 r√≥wne';
      else if(lay === '5_equal') label = '5 r√≥wnych';
      else if(lay === '3_1_2_2') label = '1 ma≈Ça + 2 du≈ºe (1:2:2)';
      else {
        // kompatybilno≈õƒá wstecz
        const lc = String(d.drawerCount || '3');
        if(lc === '1') label = '1 du≈ºa';
        else if(lc === '2') label = '2 r√≥wne';
        else if(lc === '5') label = '5 r√≥wnych';
        else if(lc === '3') label = '1 ma≈Ça + 2 du≈ºe (1:2:2)';
        else label = '3 r√≥wne';
      }
      const sys = String(d.drawerSystem || 'skrzynkowe');
      let sysLabel = 'Skrzynkowe';
      if(sys === 'systemowe'){
        const br = String(d.drawerBrand || 'blum');
        if(br !== 'blum'){
          sysLabel = br.toUpperCase() + ' (w budowie)';
        } else {
          const mdl = String(d.drawerModel || 'tandembox');
          const map = {tandembox:'TANDEMBOX', legrabox:'LEGRABOX', merivobox:'MERIVOBOX', metabox:'METABOX'};
          sysLabel = 'BLUM ' + (map[mdl] || mdl.toUpperCase());
        }
      }
      parts.push(`Szuflady: ${label} ‚Ä¢ ${sysLabel}`);

      const innerType = String(d.innerDrawerType || 'brak');
      const innerCnt = parseInt(d.innerDrawerCount, 10);
      if(innerType !== 'brak' && Number.isFinite(innerCnt) && innerCnt > 0){
        parts.push(`Szuflady wew.: ${innerCnt}${innerType === 'blum' ? ' (BLUM)' : ''}`);
      }
    }
    if(cab.subType === 'zlewowa'){
      // zgodno≈õƒá wstecz: stare pole sinkOption
      let front = d.sinkFront;
      let extra = d.sinkExtra;
      let extraCount = d.sinkExtraCount;
      let innerType = d.sinkInnerDrawerType;

      if(!front && d.sinkOption){
        if(d.sinkOption === 'zwykle_drzwi') front = 'drzwi';
        else if(d.sinkOption === 'szuflada') front = 'szuflada';
        else if(d.sinkOption === 'szuflada_i_polka'){ front = 'szuflada'; extra = extra || 'polka'; extraCount = (extraCount != null ? extraCount : 1); }
      }

      if(front === 'szuflada'){
        parts.push('Zlew: szuflada (1 front)');
        const sys = String(d.drawerSystem || 'skrzynkowe');
        let sysLabel = 'Skrzynkowe';
        if(sys === 'systemowe'){
          const br = String(d.drawerBrand || 'blum');
          if(br !== 'blum') sysLabel = br.toUpperCase() + ' (w budowie)';
          else {
            const mdl = String(d.drawerModel || 'tandembox');
            const map = {tandembox:'TANDEMBOX', legrabox:'LEGRABOX', merivobox:'MERIVOBOX', metabox:'METABOX'};
            sysLabel = 'BLUM ' + (map[mdl] || mdl.toUpperCase());
          }
        }
        parts.push(`Szuflada: ${sysLabel}`);
      } else {
        const dc = Number(d.sinkDoorCount || cab.frontCount || 2) || 2;
        parts.push(`Zlew: drzwi ${dc}`);
      }

      const ex = (extra || 'brak');
      const ec = (extraCount != null ? extraCount : 1);
      if(ex === 'polka'){
        parts.push(`Dodatkowo: p√≥≈Çka ${ec}`);
      } else if(ex === 'szuflada_wew'){
        const t = (innerType || 'skrzynkowe');
        { 
        const t = String(innerType || 'skrzynkowe');
        if(t === 'systemowe'){
          const br = String(d.sinkInnerDrawerBrand || 'blum');
          if(br !== 'blum'){
            parts.push(`Szuflady wew.: ${ec} ‚Ä¢ ${br.toUpperCase()} (w budowie)`);
          } else {
            const mdl = String(d.sinkInnerDrawerModel || 'tandembox');
            const map = {tandembox:'TANDEMBOX', legrabox:'LEGRABOX', merivobox:'MERIVOBOX', metabox:'METABOX'};
            parts.push(`Szuflady wew.: ${ec} ‚Ä¢ BLUM ${(map[mdl]||mdl.toUpperCase())}`);
          }
        } else {
          parts.push(`Szuflady wew.: ${ec} ‚Ä¢ Skrzynkowe`);
        }
      }
      }
    }
if(cab.subType === 'zmywarkowa'){
  const dw = (d.dishWasherWidth || '60');
  parts.push(`Zmywarka: ${dw} cm`);
  const td = parseInt(d.techDividerCount, 10);
  if(Number.isFinite(td) && td > 0) parts.push(`Przegroda techn.: ${td}`);
}
    if(cab.subType === 'lodowkowa'){
      const fo = (d.fridgeOption || 'zabudowa');
      if(fo === 'zabudowa'){
        const nh = d.fridgeNicheHeight || '178';
        parts.push(`Lod√≥wka: zabudowa ‚Ä¢ nisza ${nh}cm`);
      } else {
        const ff = (d.fridgeFreeOption || 'brak');
        parts.push(`Lod√≥wka: wolnostojƒÖca ‚Ä¢ ${ff}`);
      }
      const td = parseInt(d.techDividerCount, 10);
      if(fo === 'zabudowa' && Number.isFinite(td) && td > 0) parts.push(`Przegroda techn.: ${td}`);
    }
    if(cab.subType === 'piekarnikowa'){
      parts.push(`Piekarnik: ${(d.ovenOption || 'szuflada_dol')} ‚Ä¢ H=${d.ovenHeight || '60'}cm`);
      const tc = parseInt(d.techShelfCount, 10);
      parts.push(`Przegroda techn.: ${Number.isFinite(tc) && tc>0 ? tc : 1}`);

      const oo = String(d.ovenOption || 'szuflada_dol');
      if(oo.indexOf('szuflada') !== -1){
        const sys = String(d.drawerSystem || 'skrzynkowe');
        let sysLabel = 'Skrzynkowe';
        if(sys === 'systemowe'){
          const br = String(d.drawerBrand || 'blum');
          if(br !== 'blum') sysLabel = br.toUpperCase() + ' (w budowie)';
          else {
            const mdl = String(d.drawerModel || 'tandembox');
            const map = {tandembox:'TANDEMBOX', legrabox:'LEGRABOX', merivobox:'MERIVOBOX', metabox:'METABOX'};
            sysLabel = 'BLUM ' + (map[mdl] || mdl.toUpperCase());
          }
        }
        parts.push(`Szuflada: ${sysLabel}`);
      }
    }
    const isCorner = ['rogowa_slepa','narozna_l'].includes(cab.subType || '');
    const cornerOption = (d.cornerOption || 'polki');

    if(isCorner){
      parts.push(`Naro≈ºna: ${cornerOption}`);
    }

    // STANDARDOWA: p√≥≈Çki albo szuflady wewnƒôtrzne
    const insideMode = (d.insideMode || 'polki');
    const wantsInnerDrawers = (cab.subType === 'standardowa') && (
      insideMode === 'szuflady_wew' || insideMode === 'szuflady_wewn' || insideMode === 'szuflady_wewnetrzne'
    );

    if(wantsInnerDrawers){
      const cnt = (d.innerDrawerCount != null) ? d.innerDrawerCount : 1;
      const t = (d.innerDrawerType || 'skrzynkowe');
      parts.push(`Szuflady wew.: ${cnt}${t === 'blum' ? ' (BLUM)' : ''}`);
    } else {
      const shelvesN = parseInt(d.shelves, 10);
      const hasShelves = Number.isFinite(shelvesN) && shelvesN > 0;
      const skipShelvesFor = ['szuflady','zlewowa','zmywarkowa','lodowkowa','piekarnikowa'];
      const showShelves = hasShelves && !skipShelvesFor.includes(cab.subType) && !(isCorner && cornerOption !== 'polki');
      if(showShelves && shelvesN > 0) parts.push(`P√≥≈Çki: ${shelvesN}`);
    }

    // FRONTY: niekt√≥re warianty majƒÖ sztywne zasady
    let frontCountForSummary = cab.frontCount || 0;
    if(cab.subType === 'lodowkowa'){
      const fo = (d.fridgeOption || 'zabudowa');
      if(fo === 'zabudowa'){
        // w tej wersji lod√≥wkowa-zabudowa generuje zawsze 2 fronty: dolny + g√≥rny (nisza)
        frontCountForSummary = 2;
      } else {
        // wolnostojƒÖca: bez front√≥w
        frontCountForSummary = 0;
      }
    }
    if(frontCountForSummary > 0) parts.push(`Fronty: ${frontCountForSummary}`);
    return parts.join(' ‚Ä¢ ');
  }

  // modu≈Ç
  if(cab.type === 'modu≈Ç'){
    // standardowa: wnƒôtrze (p√≥≈Çki / szuflady wewnƒôtrzne)
    if(cab.subType === 'standardowa'){
      const inside = String(d.insideMode || 'polki');
      if(inside === 'szuflady_wew'){
        const n = parseInt(d.innerDrawerCount, 10);
        const cnt = (Number.isFinite(n) && n > 0) ? n : 1;
        const it = String(d.innerDrawerType || 'skrzynkowe');
        parts.push(`Szuflady wew.: ${cnt}${it === 'blum' ? ' (BLUM)' : ''}`);
      }
    }
    if(((d.shelves ?? 0) > 0)) parts.push(`P√≥≈Çki: ${d.shelves}`);
    if(cab.frontCount) parts.push(`Fronty: ${cab.frontCount}`);
    return parts.join(' ‚Ä¢ ');
  }

  return '';
}


/* ===== Materia≈Çy: rozpiska mebli (korpusy/plecy/trawersy) ===== */
const FC_BOARD_THICKNESS_CM = 1.8; // domy≈õlnie p≈Çyta 18mm (do oblicze≈Ñ wymiar√≥w "miƒôdzy bokami")
const FC_TOP_TRAVERSE_DEPTH_CM = 9; // trawersy g√≥rne majƒÖ g≈Çƒôboko≈õƒá 9cm

function fmtCm(v){
  const n = Number(v);
  if(!Number.isFinite(n)) return String(v ?? '');
  return (Math.round(n * 10) / 10).toString();
}

function formatM2(v){
  const n = Number(v);
  if(!Number.isFinite(n)) return '0.000';
  return (Math.round(n * 1000) / 1000).toFixed(3);
}

function escapeHtml(str){
  return String(str ?? '').replace(/[&<>"']/g, (ch) => ({
    '&':'&amp;',
    '<':'&lt;',
    '>':'&gt;',
    '"':'&quot;',
    "'":'&#39;'
  }[ch] || ch));
}

function calcPartAreaM2(p){
  const a = Number(p.a) || 0;
  const b = Number(p.b) || 0;
  const qty = Number(p.qty) || 0;
  return qty * (a * b) / 10000; // cm^2 -> m^2
}

function addArea(map, material, area){
  const key = String(material || '');
  if(!key) return;
  map[key] = (map[key] || 0) + (Number(area) || 0);
}

function totalsFromParts(parts){
  const totals = {};
  (parts || []).forEach(p => addArea(totals, p.material, calcPartAreaM2(p)));
  return totals;
}

function mergeTotals(target, src){
  for(const k in (src || {})){
    target[k] = (target[k] || 0) + (src[k] || 0);
  }
  return target;
}

function totalsToRows(totals){
  return Object.entries(totals || {})
    .map(([material, m2]) => ({ material, m2 }))
    .filter(r => r.m2 > 0)
    .sort((a,b) => b.m2 - a.m2);
}

function renderTotals(container, totals){
  container.innerHTML = '';
  const rows = totalsToRows(totals);
  if(!rows.length){
    const em = document.createElement('div');
    em.className = 'muted xs';
    em.textContent = '‚Äî';
    container.appendChild(em);
    return;
  }
  rows.forEach(r => {
    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.justifyContent = 'space-between';
    row.style.gap = '10px';
    row.style.padding = '2px 0';

    const left = document.createElement('div');
    left.className = 'muted xs';
    left.style.fontWeight = '900';
    left.textContent = r.material;

    const right = document.createElement('div');
    right.className = 'muted xs';
    right.style.fontWeight = '900';
    right.textContent = `${formatM2(r.m2)} m¬≤`;

    row.appendChild(left);
    row.appendChild(right);
    container.appendChild(row);
  });
}

function getCabinetAssemblyRuleText(cab){
  if(cab.type === 'wiszƒÖca' || cab.type === 'modu≈Ç'){
    return 'Skrƒôcanie: wieniec g√≥rny i dolny miƒôdzy bokami.';
  }
  if(cab.type === 'stojƒÖca'){
    return `Skrƒôcanie: wieniec dolny pod bokami (boki ni≈ºsze o ${FC_BOARD_THICKNESS_CM} cm); g√≥ra na trawersach 2√ó${FC_TOP_TRAVERSE_DEPTH_CM} cm (prz√≥d+ty≈Ç).`;
  }
  return 'Skrƒôcanie: ‚Äî';
}




function getCabinetFrontCutListForMaterials(room, cab){
  // Zwraca listƒô element√≥w "Front" do zak≈Çadki Materia≈Çy.
  // Wa≈ºne: bez komentarzy w polu wymiar√≥w oraz z agregacjƒÖ identycznych front√≥w (qty zamiast duplikat√≥w).
  const out = [];
  if(!cab || !(cab.type === 'stojƒÖca' || cab.type === 'wiszƒÖca' || cab.type === 'modu≈Ç')) return out;

  const mat = cab.frontMaterial || 'laminat';
  const col = cab.frontColor || '';

  // Agregator: klucz = material|W|H (W/H zaokrƒÖglone do 0,1cm)
  const acc = new Map();
  function addFront(w, h){
    const W = Math.max(0, Number(w) || 0);
    const H = Math.max(0, Number(h) || 0);
    if(W <= 0 || H <= 0) return;

    const Wr = Math.round(W * 10) / 10;
    const Hr = Math.round(H * 10) / 10;
    const materialKey = `Front: ${mat}${col ? ` ‚Ä¢ ${col}` : ''}`;
    const key = `${materialKey}|${Wr}|${Hr}`;

    if(acc.has(key)){
      acc.get(key).qty += 1;
      return;
    }
    acc.set(key, {
      name: 'Front',
      qty: 1,
      a: Wr,
      b: Hr,
      // Bez komentarzy w wymiarach
      dims: `${fmtCm(Wr)} √ó ${fmtCm(Hr)}`,
      material: materialKey
    });
  }
  function finalize(){ return Array.from(acc.values()); }

  // wysoko≈õƒá front√≥w: dla stojƒÖcych odejmujemy wysoko≈õƒá n√≥≈ºek (ustawienia pomieszczenia)
  function getFrontHeightForCab(){
    let h = Number(cab.height) || 0;
    if(cab.type === 'stojƒÖca'){
      const s = (projectData[room] && projectData[room].settings) ? projectData[room].settings : {};
      const leg = Number(s.legHeight) || 0;
      if(leg > 0) h = Math.max(0, h - leg);
    }
    return h;
  }

  // effectiveW: szeroko≈õƒá u≈ºywana do front√≥w (niekt√≥re typy majƒÖ za≈õlepienia)
  let effectiveW = Number(cab.width)||0;
  if(cab.subType === 'rogowa_slepa'){
    const blind = Number(cab.details?.blindPart) || 0;
    // fronty w rogowej ≈õlepej liczone jak wcze≈õniej (fronty bazujƒÖ na szeroko≈õci, a za≈õlepki liczone w korpusie)
    if(blind > 0) effectiveW = Math.max(0, effectiveW - blind);
  }

  // Szuflady: licz fronty szuflad wg zadeklarowanej ilo≈õci
  if(cab.type === 'stojƒÖca' && cab.subType === 'szuflady'){
    const drawers = Math.max(1, Number(cab.details?.drawers) || 1);
    const fh = getFrontHeightForCab();
    const hEach = drawers ? (fh / drawers) : 0;
    for(let i=0;i<drawers;i++) addFront(Number(cab.width)||0, hEach);
    cab.frontCount = drawers;
    return finalize();
  }

  // StojƒÖca z szufladƒÖ + drzwi
  if(cab.type === 'stojƒÖca' && cab.subType === 'szuflada_drzwi'){
    const fh = getFrontHeightForCab();
    const drawerH = Number(cab.details?.drawerHeight) || Math.min(20, fh);
    const doorH = Math.max(0, fh - drawerH);
    addFront(Number(cab.width)||0, drawerH);
    if(doorH > 0){
      const fc = Math.max(1, Number(cab.frontCount||2));
      const wEach = fc ? (effectiveW / fc) : 0;
      for(let i=0;i<fc;i++) addFront(wEach, doorH);
      cab.frontCount = 1 + fc;
    } else {
      cab.frontCount = 1;
    }
    return finalize();
  }

  // Zmywarkowa: 1 front (wysoko≈õƒá wg ustawie≈Ñ)
  if(cab.type === 'stojƒÖca' && cab.subType === 'zmywarkowa'){
    addFront(Number(cab.width)||0, getFrontHeightForCab());
    cab.frontCount = 1;
    return finalize();
  }

  // Lod√≥wkowa: 2 fronty (g√≥ra + d√≥≈Ç)
  if(cab.type === 'stojƒÖca' && cab.subType === 'lodowkowa'){
    const topH = Number(cab.details?.topFrontHeight) || 60;
    const fh = getFrontHeightForCab();
    const bottomH = Math.max(0, fh - topH);
    addFront(Number(cab.width)||0, topH);
    if(bottomH > 0) addFront(Number(cab.width)||0, bottomH);
    cab.frontCount = bottomH > 0 ? 2 : 1;
    return finalize();
  }

  // Piekarnikowa: front nad piekarnikiem (reszta to piekarnik)
  if(cab.type === 'stojƒÖca' && cab.subType === 'piekarnikowa'){
    const ovenH = Number(cab.details?.ovenHeight) || 60;
    const hRest = Math.max(0, getFrontHeightForCab() - ovenH);
    if(hRest > 0) addFront(Number(cab.width)||0, hRest);
    cab.frontCount = hRest > 0 ? 1 : 0;
    return finalize();
  }

  // Uchylna (wiszƒÖca / modu≈Ç): 1 lub 2 fronty wg HF
  if((cab.type === 'wiszƒÖca' || cab.type === 'modu≈Ç') && cab.subType === 'uchylna'){
    const fc = Math.max(1, Number(cab.frontCount||1));
    const fh = getFrontHeightForCab();
    const wEach = fc ? (effectiveW / fc) : 0;
    for(let i=0;i<fc;i++) addFront(wEach, fh);
    cab.frontCount = fc;
    return finalize();
  }

  // Naro≈ºna L (wiszƒÖca / stojƒÖca): 2 fronty wg GL/GP/ST/SP
  if((cab.type === 'wiszƒÖca' || cab.type === 'stojƒÖca') && cab.subType === 'narozna_l'){
    const d = cab.details || {};
    const GL = Number(d.gl) || 0;
    const GP = Number(d.gp) || 0;
    const ST = Number(d.st) || 0;
    const SP = Number(d.sp) || 0;
    const t = 1.8; // cm (p≈Çyta 18mm)
    const FL = Math.abs(GL - GP);
    const FP = Math.abs(ST - SP - t);
    const fh = getFrontHeightForCab();
    addFront(FL, fh);
    addFront(FP, fh);
    cab.frontCount = 2;
    return finalize();
  }

  // Reszta: 1 lub 2 drzwiowe
  const fcDoors = Math.max(1, Number(cab.frontCount||2));
  const fh = getFrontHeightForCab();
  const wEach = fcDoors ? Math.round((effectiveW / fcDoors) * 10) / 10 : 0;
  for(let i=0;i<fcDoors;i++) addFront(wEach, fh);
  cab.frontCount = fcDoors;

  return finalize();
}


/* ===== Okucia: zawiasy BLUM (wg zalece≈Ñ z katalogu/quick reference) =====
   Uwaga: BLUM zaleca dob√≥r g≈Ç√≥wnie wg wagi frontu; szeroko≈õƒá ma wp≈Çyw (dla >600 mm czƒôsto potrzebny dodatkowy zawias).
   Poniewa≈º w projekcie nie mamy wagi z konfiguratora BLUM, szacujemy wagƒô frontu z wymiar√≥w oraz grubo≈õci p≈Çyty 18 mm.
*/
const FC_HANDLE_WEIGHT_KG = 0.2; // orientacyjna masa uchwytu/ga≈Çki (na 1 front)

// Czy w danej szafce jest faktycznie uchwyt (dla oblicze≈Ñ okuƒá BLUM)?
// TIP-ON oraz podchwyt traktujemy jako "bez uchwytu".
function cabinetHasHandle(cab){
  const os = String(cab?.openingSystem || '').toLowerCase();
  if(!os) return true; // domy≈õlnie: jest uchwyt
  if(os.includes('tip-on')) return false;
  if(os.includes('podchwyt')) return false;
  return true;
}


// Wagi front√≥w liczone po m¬≤ (≈∫r√≥d≈Ça: SEVROLL ‚Äì tabela "Wagi wype≈Çnie≈Ñ")
const FC_FRONT_WEIGHT_KG_M2 = {
  laminat: 13.0,   // p≈Çyta wi√≥rowa 18 mm ‚âà 13 kg/m¬≤
  akryl:   14.44,  // MDF 18 mm ‚âà 14,44 kg/m¬≤ (typowy rdze≈Ñ frontu akrylowego)
  lakier:  14.44   // MDF 18 mm ‚âà 14,44 kg/m¬≤ (typowy rdze≈Ñ frontu lakierowanego)
};

function getFrontWeightKgM2(frontMaterial){
  const m = String(frontMaterial || 'laminat').toLowerCase();
  return (m in FC_FRONT_WEIGHT_KG_M2) ? FC_FRONT_WEIGHT_KG_M2[m] : FC_FRONT_WEIGHT_KG_M2.laminat;
}

function estimateFrontWeightKg(wCm, hCm, frontMaterial, hasHandle){
  const wM = Math.max(0, Number(wCm) || 0) / 100;
  const hM = Math.max(0, Number(hCm) || 0) / 100;
  const area = wM * hM;
  const handleKg = hasHandle ? FC_HANDLE_WEIGHT_KG : 0;
  return area * getFrontWeightKgM2(frontMaterial) + handleKg;
}

function blumHingesPerDoor(wCm, hCm, frontMaterial, hasHandle){
  const weightKg = estimateFrontWeightKg(wCm, hCm, frontMaterial, hasHandle);
  const weightLb = weightKg * 2.20462;
  const heightIn = (Math.max(0, Number(hCm) || 0)) / 2.54;
  const widthMm = (Math.max(0, Number(wCm) || 0)) * 10;

  // Bazowo wg wagi (quick reference: <15 lb, 15‚Äì30, 30‚Äì45, 45‚Äì60 => 2‚Äì5 zawias√≥w)
  let hinges = 2;
  if(weightLb <= 15) hinges = 2;
  else if(weightLb <= 30) hinges = 3;
  else if(weightLb <= 45) hinges = 4;
  else if(weightLb <= 60) hinges = 5;
  else hinges = 5 + Math.ceil((weightLb - 60) / 15);

  // Korekta wg wysoko≈õci (konserwatywnie, w duchu BLUM: wy≈ºsze fronty czƒôsto potrzebujƒÖ dodatkowego zawiasu)
  if(hinges <= 2 && heightIn > 40) hinges = 3;
  if(hinges <= 3 && heightIn > 60) hinges = 4;
  if(hinges <= 4 && heightIn > 80) hinges = 5;
  if(hinges <= 5 && heightIn > 100) hinges = 6;

  // Korekta wg szeroko≈õci (BLUM: warto≈õci bazowe dla szer. do 600 mm; do ~650 mm zwykle +1 zawias)
  if(widthMm > 600){
    hinges += Math.ceil((widthMm - 600) / 50);
  }

  return Math.max(0, Math.round(hinges));
}


function getDoorFrontPanelsForHinges(room, cab){
  const out = [];
  if(!cab) return out;
  const type = String(cab.type || '');
  const sub = String(cab.subType || '');

  // brak zawias√≥w dla klap (AVENTOS) i front√≥w urzƒÖdze≈Ñ
  if(sub === 'uchylne') return out;
  if(type !== 'stojƒÖca' && type !== 'wiszƒÖca' && type !== 'modu≈Ç') return out;
  if(sub === 'szuflady' || sub === 'zmywarkowa' || sub === 'lodowkowa') return out;
  const hasHandle = cabinetHasHandle(cab);


  const w = Number(cab.width) || 0;
  const d = Number(cab.depth) || 0;

  // szeroko≈õƒá efektywna (np. rogowa ≈õlepa)
  let effectiveW = w;
  if(sub === 'rogowa_slepa'){
    const blind = Number(cab.details?.blindPart) || 0;
    if(blind > 0) effectiveW = Math.max(0, effectiveW - blind);
  }

  // wysoko≈õƒá frontu dla stojƒÖcych = korpus - n√≥≈ºki
  function frontHeight(){
    let hh = Number(cab.height) || 0;
    if(type === 'stojƒÖca'){
      const s = (projectData[room] && projectData[room].settings) ? projectData[room].settings : {};
      const leg = Number(s.legHeight) || 0;
      if(leg > 0) hh = Math.max(0, hh - leg);
    }
    return hh;
  }

  // stojƒÖca z szufladƒÖ + drzwi
  if(type === 'stojƒÖca' && sub === 'szuflada_drzwi'){
    const fh = frontHeight();
    const drawerH = Number(cab.details?.drawerHeight) || Math.min(20, fh);
    const doorH = Math.max(0, fh - drawerH);
    if(doorH <= 0) return out;
    const fc = Math.max(1, Number(cab.details?.doorCount || cab.frontCount || 2));
    const wEach = fc ? (effectiveW / fc) : 0;
    for(let i=0;i<fc;i++) out.push({ w: wEach, h: doorH , material: (cab.frontMaterial || 'laminat') , hasHandle: hasHandle });
    return out;
  }

  // piekarnikowa: tylko front nad piekarnikiem
  if(type === 'stojƒÖca' && sub === 'piekarnikowa'){
    const ovenH = Number(cab.details?.ovenHeight) || 60;
    const doorH = Math.max(0, frontHeight() - ovenH);
    if(doorH <= 0) return out;
    const fc = Math.max(1, Number(cab.details?.doorCount || cab.frontCount || 1));
    const wEach = fc ? (effectiveW / fc) : 0;
    for(let i=0;i<fc;i++) out.push({ w: wEach, h: doorH , material: (cab.frontMaterial || 'laminat') , hasHandle: hasHandle });
    return out;
  }

  // standard: drzwi wg frontCount
  const fc = Math.max(0, Number(cab.frontCount || 0));
  if(fc <= 0) return out;

  const wEach = effectiveW / fc;
  const hEach = (type === 'stojƒÖca') ? frontHeight() : (Number(cab.height) || 0);
  for(let i=0;i<fc;i++) out.push({ w: wEach, h: hEach , material: (cab.frontMaterial || 'laminat') , hasHandle: hasHandle });
  return out;
}

function getHingeCountForCabinet(room, cab){
  const doors = getDoorFrontPanelsForHinges(room, cab);
  if(!doors.length) return 0;
  let total = 0;
  doors.forEach(d => { total += blumHingesPerDoor(d.w, d.h, d.material, d.hasHandle); });
  return Math.max(0, Math.round(total));
}

/* ===== Okucia: podno≈õniki BLUM AVENTOS (klapy uchylne) =====
   BLUM: wsp√≥≈Çczynnik mocy (LF / power factor) = wysoko≈õƒá korpusu (mm) √ó waga frontu z uchwytem (kg).
   ≈πr√≥d≈Ça: dokumenty BLUM (AVENTOS) / publikacje techniczne.
   Uwaga: w wielu opracowaniach przyjmuje siƒô podw√≥jnƒÖ masƒô uchwytu dla klap (bezpieczniej).
*/

const FC_BLUM_FLAP_KIND_LABEL = {
  'HKI':'HKI',
  'HF_top':'HF top (sk≈Çadany)',
  'HS_top':'HS top (uchylno‚ÄënachodzƒÖcy)',
  'HL_top':'HL top (ponad korpus)',
  'HK_top':'HK top',
  'HK-S':'HK‚ÄëS',
  'HK-XS':'HK‚ÄëXS'
};

function estimateFlapWeightKg(cab, room){
  if(!cab) return 0;
  // wysoko≈õƒá frontu dla stojƒÖcych odejmujemy nogi; dla wiszƒÖcych/modu≈Ç√≥w bierzemy pe≈ÇnƒÖ wysoko≈õƒá
  let hFront = Number(cab.height) || 0;
  if(cab.type === 'stojƒÖca'){
    const s = (projectData[room] && projectData[room].settings) ? projectData[room].settings : {};
    const leg = Number(s.legHeight) || 0;
    if(leg > 0) hFront = Math.max(0, hFront - leg);
  }

  // szeroko≈õƒá efektywna (rogowa ≈õlepa: odjƒôcie blindPart)
  let wFront = Number(cab.width) || 0;
  if(String(cab.subType||'') === 'rogowa_slepa'){
    const blind = Number(cab.details?.blindPart) || 0;
    if(blind > 0) wFront = Math.max(0, wFront - blind);
  }

  const mat = cab.frontMaterial || 'laminat';
  const wM = Math.max(0, wFront) / 100;
  const hM = Math.max(0, hFront) / 100;
  const area = wM * hM;

  // Uchwyt: BLUM liczy r√≥≈ºnie w zale≈ºno≈õci od systemu:
  // HF/HS/HL: + masa uchwytu (1√ó)
  // HK/HK-S/HK-XS/HKi: + podw√≥jna masa uchwytu (2√ó)
  // Tu dobieramy mno≈ºnik na podstawie wybranego rodzaju podno≈õnika.
  const kind = String((cab.details || {}).flapKind || 'HK-XS');
  const singleHandleKinds = new Set(['HF_top','HS_top','HL_top']);
  const handleMul = singleHandleKinds.has(kind) ? 1 : 2;
  return area * getFrontWeightKgM2(mat) + (cabinetHasHandle(cab) ? (FC_HANDLE_WEIGHT_KG * handleMul) : 0);
}

function blumAventosPowerFactor(cab, room){
  const khMm = Math.max(0, Number(cab.height) || 0) * 10; // cm -> mm
  const fgKg = estimateFlapWeightKg(cab, room);
  return Math.round(khMm * fgKg);
}

function getBlumAventosInfo(cab, room){
  const d = (cab && cab.details) ? cab.details : {};
  const vendor = String(d.flapVendor || 'blum');
  if(vendor !== 'blum') return null;

  const kind = String(d.flapKind || 'HK-XS'); // default to HK-XS for "uchylne"
  const label = FC_BLUM_FLAP_KIND_LABEL[kind] || kind;

  const khMm = Math.max(0, Number(cab.height) || 0) * 10; // cm -> mm
  const pf = blumAventosPowerFactor(cab, room); // LF
  const widthMm = Math.round((Number(cab.width) || 0) * 10);
  const depthMm = Math.round((Number(cab.depth) || 0) * 10);

  // Uwaga o jednostkach:
  // W kodzie liczymy LF = KH(mm) √ó waga frontu(kg) (z uchwytem).
  // Czƒô≈õƒá materia≈Ç√≥w BLUM podaje PF w inch√ólb. Wtedy przeliczamy na mm√ókg:
  const INLB_TO_MMKg = 25.4 * 0.45359237; // ‚âà 11.521

  // Zakresy (HK-XS) ‚Äì PF/LF w mm√ókg
  const HKXS_RANGES = [
    { model:'20K1101', min:200, max:1000, strength:'s≈Çaby' },
    { model:'20K1301', min:500, max:1500, strength:'≈õredni' },
    { model:'20K1501', min:800, max:1800, strength:'mocny' }
  ];

  // Zakresy (HK top) ‚Äì ≈∫r√≥d≈Ça BLUM zwykle w inch√ólb -> przeliczamy
  const HKTOP_RANGES = [
    { model:'22K2300', min:Math.round(36*INLB_TO_MMKg),  max:Math.round(139*INLB_TO_MMKg), strength:'s≈Çaby' },
    { model:'22K2500', min:Math.round(80*INLB_TO_MMKg),  max:Math.round(240*INLB_TO_MMKg), strength:'≈õredni' },
    { model:'22K2700', min:Math.round(150*INLB_TO_MMKg), max:Math.round(450*INLB_TO_MMKg), strength:'mocny' },
    { model:'22K2900', min:Math.round(270*INLB_TO_MMKg), max:Math.round(781*INLB_TO_MMKg), strength:'bardzo mocny' }
  ];

  // Zakresy (HK‚ÄëS) ‚Äì PF/LF w mm√ókg
  const HKS_RANGES = [
    { model:'20K2A00', min:220, max:500, strength:'s≈Çaby' },
    { model:'20K2C00', min:400, max:1000, strength:'≈õredni' },
    { model:'20K2E00', min:960, max:2215, strength:'mocny' }
  ];

  // Zakresy (HF top) ‚Äì PF/LF w mm√ókg (podawane dla 2 szt. w zestawie)
  const HFTOP_RANGES = [
    { model:'22F2500', min:2700, max:13500, strength:'s≈Çaby/≈õredni' },
    { model:'22F2800', min:10000, max:19300, strength:'mocny' }
  ];

  // Zakresy (HKi) ‚Äì PF w inch√ólb -> przeliczamy
  const HKI_RANGES = [
    { model:'24K2300', min:Math.round(37*INLB_TO_MMKg),  max:Math.round(142*INLB_TO_MMKg), strength:'s≈Çaby' },
    { model:'24K2500', min:Math.round(82*INLB_TO_MMKg),  max:Math.round(246*INLB_TO_MMKg), strength:'≈õredni' },
    { model:'24K2700', min:Math.round(152*INLB_TO_MMKg), max:Math.round(458*INLB_TO_MMKg), strength:'mocny' },
    { model:'24K2800', min:Math.round(229*INLB_TO_MMKg), max:Math.round(686*INLB_TO_MMKg), strength:'bardzo mocny' }
  ];

  // HS top ‚Äì dob√≥r po tabeli ‚ÄûKH / waga frontu‚Äù (kg). Dane z opis√≥w katalogowych.
  // Sprawdzamy 3 ‚Äûsi≈Çowniki‚Äù: 22S2200, 22S2500, 22S2800.
  const HSTOP_TABLE = [
    { model:'22S2200', khMin:350, khMax:540, wMin0:2.0,   wMin1:3.0,  wMax0:10.25, wMax1:12.5, strength:'s≈Çaby' },
    { model:'22S2500', khMin:480, khMax:660, wMin0:2.75,  wMin1:3.0,  wMax0:12.75, wMax1:15.25, strength:'≈õredni' },
    { model:'22S2800', khMin:650, khMax:800, wMin0:3.5,   wMin1:4.0,  wMax0:16.5,  wMax1:18.5,  strength:'mocny' }
  ];

  // HL top ‚Äì dob√≥r po tabeli ‚ÄûKH / waga frontu‚Äù (kg) (przedzia≈Çy sta≈Çe).
  const HLTOP_TABLE = [
    { model:'22L2200', khMin:300, khMax:340, wMin:0.8, wMax:5.6,  strength:'s≈Çaby' },
    { model:'22L2500', khMin:340, khMax:390, wMin:1.1, wMax:7.5,  strength:'≈õredni' },
    { model:'22L2800', khMin:390, khMax:580, wMin:1.3, wMax:10.3, strength:'mocny' }
  ];

  // Limity wysoko≈õci frontu (KH) dla system√≥w AVENTOS (wg danych katalogowych/strony BLUM)
  const MAX_FRONT_HEIGHT_BY_KIND_MM = {
    'HK-XS': 0,
    'HK_top': 600,
    'HK-S': 600,
    'HKI': 610,
    'HL_top': 580,
    'HS_top': 800,
    'HF_top': 1200
  };

  const MIN_FRONT_HEIGHT_BY_KIND_MM = {
    // ≈∫r√≥d≈Ça (BLUM):
    // HK-XS: 240‚Äì600 mm
    // HK top: 205‚Äì600 mm
    // HK-S: 180‚Äì600 mm
    // HKi: 162‚Äì610 mm
    // HL top: 300‚Äì580 mm
    // HS top: 350‚Äì800 mm
    // HF top: 480‚Äì1200 mm
    'HK-XS': 240,
    'HK_top': 205,
    'HK-S': 180,
    'HKI': 162,
    'HL_top': 300,
    'HS_top': 350,
    'HF_top': 480
  };

  // Ograniczenia szeroko≈õci frontu/korpusu dla system√≥w AVENTOS (typowe warto≈õci katalogowe BLUM)
  // Uwaga: tu walidujemy szeroko≈õƒá korpusu (LW) w mm.
  const MAX_FRONT_WIDTH_BY_KIND_MM = {
    'HK-XS': 0,
    'HK_top': 1800,
    'HK-S': 1800,
    'HKI': 1800,
    'HL_top': 1800,
    'HS_top': 1800,
    'HF_top': 1800
  };

  const MIN_FRONT_WIDTH_BY_KIND_MM = {
    // zwykle brak twardego minimum; zostawiamy 0
    'HK-XS': 0,
    'HK_top': 0,
    'HK-S': 0,
    'HKI': 0,
    'HL_top': 0,
    'HS_top': 0,
    'HF_top': 0
  };

// Minimalna g≈Çƒôboko≈õƒá wewnƒôtrzna korpusu (LT) dla AVENTOS (wg katalogu/BLUM)
// Walidujemy tutaj g≈Çƒôboko≈õƒá korpusu (cm -> mm). Je≈õli projektujesz z plecami we wpuszczanym rowku,
// a zale≈ºy Ci na ultra-precyzji, dodaj sobie korektƒô o grubo≈õƒá plec√≥w / cofniƒôcie ‚Äì tu trzymamy prostƒÖ regu≈Çƒô "czy siƒô zmie≈õci".
const MIN_INTERNAL_DEPTH_BY_KIND_MM = {
  // ≈∫r√≥d≈Ça BLUM (min. g≈Çƒôboko≈õƒá wewnƒôtrzna LT):
  // HK-XS: ‚â•100 mm (dla specjalnej pozycji wiercenia; standardowo czƒôsto 125 mm)
  // HK-S: 163 mm
  // HK top: 187 mm (bez SERVO-DRIVE)
  // HL top / HS top / HF top: 264 mm
  // HKi: 270 mm
  'HK-XS': 100,
  'HK-S': 163,
  'HK_top': 187,
  'HL_top': 264,
  'HS_top': 264,
  'HF_top': 264,
  'HKI': 270
};

// Zalecana (bezpieczna warsztatowo) minimalna g≈Çƒôboko≈õƒá wewnƒôtrzna korpusu (LT).
// Dla HK‚ÄëXS katalog dopuszcza LT‚â•100 mm przy specyficznej pozycji monta≈ºu, ale w praktyce ≈Çatwiej i bezpieczniej przyjƒÖƒá ‚â•125 mm.
const REC_INTERNAL_DEPTH_BY_KIND_MM = {
  'HK-XS': 125
};


function suggestKindsForDepth(lt){
  const out = [];
  Object.keys(MIN_INTERNAL_DEPTH_BY_KIND_MM).forEach(k=>{
    const minD = MIN_INTERNAL_DEPTH_BY_KIND_MM[k] || 0;
    if(!lt) return;
    if(minD && lt < minD) return;
    const lbl = FC_BLUM_FLAP_KIND_LABEL[k] || k;
    out.push(lbl);
  });
  return out;
}


  function suggestKindsForWidth(lw){
    const out = [];
    Object.keys(MAX_FRONT_WIDTH_BY_KIND_MM).forEach(k=>{
      const maxW = MAX_FRONT_WIDTH_BY_KIND_MM[k] || 0;
      const minW = MIN_FRONT_WIDTH_BY_KIND_MM[k] || 0;
      if(!lw) return;
      if(minW && lw < minW) return;
      if(maxW && lw > maxW) return;
      const lbl = FC_BLUM_FLAP_KIND_LABEL[k] || k;
      out.push(lbl);
    });
    return out;
  }




  function suggestKindsForHeight(kh){
    const out = [];
    Object.keys(MAX_FRONT_HEIGHT_BY_KIND_MM).forEach(k=>{
      const maxH = MAX_FRONT_HEIGHT_BY_KIND_MM[k];
      const minH = MIN_FRONT_HEIGHT_BY_KIND_MM[k] || 0;
      if(!kh) return;
      if(minH && kh < minH) return;
      if(maxH && kh > maxH) return;
      const lbl = FC_BLUM_FLAP_KIND_LABEL[k] || k;
      out.push(lbl);
    });
    return out;
  }

  function listAllKindsHeightInfo(kh){
    const order = ['HK-XS','HK_top','HK-S','HKI','HL_top','HS_top','HF_top'];
    return order.map(k=>{
      const lbl = FC_BLUM_FLAP_KIND_LABEL[k] || k;
      const minH = MIN_FRONT_HEIGHT_BY_KIND_MM[k] || 0;
      const maxH = MAX_FRONT_HEIGHT_BY_KIND_MM[k] || 0;
      const minTxt = minH ? `${minH}` : '‚Äî';
      const maxTxt = maxH ? `${maxH}` : '‚Äî';
      const ok = kh ? ((minH ? kh >= minH : true) && (maxH ? kh <= maxH : true)) : false;
      return `${lbl} (${minTxt}‚Äì${maxTxt} mm)${kh ? (ok ? ' ‚Äì pasuje' : ' ‚Äì nie pasuje') : ''}`;
    });
  }




  let model = '';
  let rangeMin = 0;
  let rangeMax = 0;
  let rangeStr = '';
  let strength = '';
  let status = 'ok'; // ok | needs_more_lifts | out_pf | out_height | out_width | out_depth
  let message = '';
  let messageTone = ''; // red | orange
  let neededLiftQty = 0;

  // Dodatkowe notatki (np. zalecenia warsztatowe)
  let depthAdvisory = '';
  let depthAdvisoryTone = '';


  // Ilo≈õƒá mechanizm√≥w: standardowo 2 szt. (lewy+prawy).
  // Dopuszczamy 3/4 szt. (np. szerokie fronty) ‚Äî BLUM czƒôsto podaje +50% dla 3. mechanizmu.
  let liftQty = 2;
  if(kind === 'HK-XS'){
    // HK‚ÄëXS mo≈ºe byƒá montowany jednostronnie lub obustronnie ‚Äì dob√≥r ilo≈õci robimy ni≈ºej na podstawie LF.
    liftQty = 1;
  }


  // Ilo≈õƒá zawias√≥w dla HK-XS (wg typowych tabel: szeroko≈õƒá i/lub LF)
  let hkxsHinges = 0;
  if(kind === 'HK-XS'){
    hkxsHinges = 2;
    if(widthMm >= 900 || pf >= 1800) hkxsHinges = 3;
    if(widthMm >= 1200 || pf >= 2700) hkxsHinges = 4;
  }

  // Informacyjna uwaga: katalog BLUM podaje progi doboru 3/4 zawias√≥w. Przy bardzo szerokich lub ciƒô≈ºkich frontach
  // mo≈ºna rozwa≈ºyƒá zastosowanie wiƒôkszej liczby zawias√≥w (nie zmienia to doboru podno≈õnik√≥w HK‚ÄëXS).
  if(kind === 'HK-XS' && hkxsHinges === 4 && (widthMm > 1200 || pf > 2700)){
    if(!message || messageTone !== 'red'){
      messageTone = messageTone || 'orange';
      message = message || `HK‚ÄëXS: zalecane min. 4 zawiasy (KB‚â•1200 mm lub LF‚â•2700). Przy bardzo szerokich frontach mo≈ºesz daƒá wiƒôcej zawias√≥w dla sztywno≈õci.`;
      status = status || 'ok';
    }
  }

  // 1) Ostrze≈ºenie wysoko≈õci (front za wysoki / za niski)
  const maxH = MAX_FRONT_HEIGHT_BY_KIND_MM[kind] || 0;
  const minH = MIN_FRONT_HEIGHT_BY_KIND_MM[kind] || 0;

  if(maxH && khMm > maxH){
    status = 'out_height';
    messageTone = 'red';
    message = `Za wysoki front: wysoko≈õƒá korpusu ${khMm} mm (dla ${label} max ${maxH} mm).`;
    const sug = suggestKindsForHeight(khMm).filter(x=>x!==label);
    if(sug.length) message += ` PasujƒÖce rodzaje dla tej wysoko≈õci: ${sug.join(', ')}.`;  }else if(minH && khMm > 0 && khMm < minH){
    status = 'out_height';
    messageTone = 'red';
    message = `Za niski front: wysoko≈õƒá korpusu ${khMm} mm (dla ${label} min ${minH} mm).`;
    const sug = suggestKindsForHeight(khMm).filter(x=>x!==label);
    if(sug.length) message += ` PasujƒÖce rodzaje dla tej wysoko≈õci: ${sug.join(', ')}.`;  }



  // 1b) Ostrze≈ºenie szeroko≈õci (front za szeroki)
  const maxW = MAX_FRONT_WIDTH_BY_KIND_MM[kind] || 0;
  const minW = MIN_FRONT_WIDTH_BY_KIND_MM[kind] || 0;

  if(maxW && widthMm > maxW){
    status = 'out_width';
    messageTone = 'red';
    message = `Za szeroki front: szeroko≈õƒá korpusu ${widthMm} mm (dla ${label} max ${maxW} mm).`;
    const sug = suggestKindsForWidth(widthMm).filter(x=>x!==label);
    if(sug.length) message += ` PasujƒÖce rodzaje dla tej szeroko≈õci: ${sug.join(', ')}.`;
  }else if(minW && widthMm > 0 && widthMm < minW){
    status = 'out_width';
    messageTone = 'red';
    message = `Za wƒÖski front: szeroko≈õƒá korpusu ${widthMm} mm (dla ${label} min ${minW} mm).`;
    const sug = suggestKindsForWidth(widthMm).filter(x=>x!==label);
    if(sug.length) message += ` PasujƒÖce rodzaje dla tej szeroko≈õci: ${sug.join(', ')}.`;
  }

  

// 1c) Ostrze≈ºenie g≈Çƒôboko≈õci (korpus za p≈Çytki)
  const minD = MIN_INTERNAL_DEPTH_BY_KIND_MM[kind] || 0;
  const recD = REC_INTERNAL_DEPTH_BY_KIND_MM[kind] || 0;

  if(status === 'ok' && minD && depthMm > 0 && depthMm < minD){
    status = 'out_depth';
    messageTone = 'red';
    message = `Za p≈Çytki korpus: g≈Çƒôboko≈õƒá ${depthMm} mm (dla ${label} min ${minD} mm).`;
    const sug = suggestKindsForDepth(depthMm).filter(x=>x!==label);
    if(sug.length) message += ` PasujƒÖce rodzaje dla tej g≈Çƒôboko≈õci: ${sug.join(', ')}.`;
  }

  // Zalecenie warsztatowe (nie blokuje): HK‚ÄëXS katalogowo bywa mo≈ºliwy od LT‚â•100 mm, ale bezpieczniej przyjƒÖƒá ‚â•125 mm
  if(status === 'ok' && kind === 'HK-XS' && recD && depthMm > 0 && depthMm < recD){
    depthAdvisoryTone = 'orange';
    depthAdvisory = `HK‚ÄëXS: katalogowo mo≈ºna zej≈õƒá do LT‚â•${minD} mm (specyficzna pozycja monta≈ºu), ale warsztatowo bezpieczniej przyjƒÖƒá ‚â•${recD} mm (mniej kolizji, ≈Çatwiejszy monta≈º).`;
  }

// Je≈õli wysoko≈õƒá, szeroko≈õƒá lub g≈Çƒôboko≈õƒá jest poza zakresem ‚Äî nie pokazujemy komunikat√≥w o mocy (LF) i blokujemy zapis
  if(status === 'out_height' || status === 'out_width' || status === 'out_depth'){
    return {
      kind, label,
      status,
      message,
      messageTone: (messageTone || 'red'),
      powerFactor: pf,
      liftQty,
      hkxsHinges
    };
  }

  // 2) Dob√≥r modelu i kontrola wsp√≥≈Çczynnika mocy / wagi
  const fgKg = estimateFlapWeightKg(cab, room);

  function pickByRange(ranges){
    return ranges.find(r => pf >= r.min && pf <= r.max) || null;
  }

  function allowMoreLiftsIfPossible(maxFor2){
    if(pf <= maxFor2) return { ok:true, qty:2, tone:'' };
    if(pf <= Math.round(maxFor2 * 1.5)) return { ok:true, qty:3, tone:'orange' };
    if(pf <= Math.round(maxFor2 * 2.0)) return { ok:true, qty:4, tone:'orange' };
    return { ok:false, qty:0, tone:'red', need: Math.max(2, Math.ceil((pf / maxFor2) * 2)) };
  }

  if(kind === 'HK-XS'){
    // HK‚ÄëXS: si≈Çownik jest symetryczny i mo≈ºe byƒá stosowany z jednej lub z obu stron.
    // Przy obustronnym zastosowaniu wsp√≥≈Çczynnik mocy LF (PF) siƒô podwaja (wg katalogu BLUM 2024/2025).
    const maxPer = HKXS_RANGES[HKXS_RANGES.length - 1].max;
    const minPer = HKXS_RANGES[0].min;

    function pickForPer(pfPer){
      return HKXS_RANGES.find(r => pfPer >= r.min && pfPer <= r.max) || null;
    }

    // Preferuj minimalnƒÖ liczbƒô mechanizm√≥w, kt√≥ra mie≈õci siƒô w zakresie:
    // q=1 (jednostronnie), q=2 (obustronnie).
    let picked = null;
    let pickedQty = 0;

    if(pf < minPer){
      status = (status === 'out_height') ? status : 'out_pf';
      messageTone = (messageTone || 'red');
      message = message || `Poza zakresem wsp√≥≈Çczynnika mocy: ${pf} (min ${minPer}). Front zbyt lekki dla HK‚ÄëXS.`;
      neededLiftQty = 0;
    } else {
      for(const q of [1, 2]){
        const pfPer = Math.ceil(pf / q);
        const p = pickForPer(pfPer);
        if(p){
          picked = p;
          pickedQty = q;
          break;
        }
      }

      if(!picked){
        // Poza zakresem nawet przy 2 mechanizmach (obustronnie)
        status = (status === 'out_height') ? status : 'out_pf';
        messageTone = 'red';
        neededLiftQty = 2;
        message = `Poza zakresem wsp√≥≈Çczynnika mocy dla HK‚ÄëXS nawet przy monta≈ºu obustronnym (HK‚ÄëXS przewiduje maks. 2 mechanizmy): ${pf} (max ${maxPer} na mechanizm, razem max ${maxPer*2}). Rozwa≈º zmianƒô na HK top / HK‚ÄëS (tam mo≈ºna dobraƒá wiƒôkszƒÖ liczbƒô podno≈õnik√≥w).`;
      } else {
        liftQty = pickedQty;
        if(pickedQty === 2){
          // Informacyjnie (nie blokuje): monta≈º obustronny
          if(!message || messageTone !== 'red'){
            status = status || 'ok';
            messageTone = messageTone || 'green';
            message = message || `Dla tej klapy zalecany monta≈º obustronny (2 mechanizmy) ‚Äì wsp√≥≈Çczynnik mocy LF podwaja siƒô.`;
          }
        }
      }
    }

    if(picked){
      model = picked.model;
      rangeMin = picked.min;
      rangeMax = picked.max;
      strength = picked.strength;
    }
  }
 else if(kind === 'HK_top'){
    const picked = pickByRange(HKTOP_RANGES);
    if(!picked){
      status = (status === 'out_height') ? status : 'out_pf';
      messageTone = (messageTone || 'red');
      const max2 = HKTOP_RANGES[HKTOP_RANGES.length - 1].max;
      const okMore = allowMoreLiftsIfPossible(max2);
      if(okMore.ok){
        status = (status === 'out_height') ? status : 'needs_more_lifts';
        messageTone = 'orange';
        liftQty = okMore.qty;
        model = HKTOP_RANGES[HKTOP_RANGES.length - 1].model;
        rangeMin = HKTOP_RANGES[HKTOP_RANGES.length - 1].min;
        rangeMax = max2;
        strength = HKTOP_RANGES[HKTOP_RANGES.length - 1].strength;
        message = `Wymagana wiƒôksza liczba podno≈õnik√≥w: przyjƒôto ${liftQty} szt. (na bazie najmocniejszego HK top).`;
      }else{
        neededLiftQty = okMore.need;
        message = `Poza zakresem wsp√≥≈Çczynnika mocy: ${pf} (max ${max2} dla 2 szt.).`;
      }
    }else{
      model = picked.model;
      rangeMin = picked.min;
      rangeMax = picked.max;
      strength = picked.strength;
    }
  } else if(kind === 'HK-S'){
    const picked = pickByRange(HKS_RANGES);
    if(!picked){
      status = (status === 'out_height') ? status : 'out_pf';
      messageTone = (messageTone || 'red');
      const max2 = HKS_RANGES[HKS_RANGES.length - 1].max;
      const okMore = allowMoreLiftsIfPossible(max2);
      if(okMore.ok){
        status = (status === 'out_height') ? status : 'needs_more_lifts';
        messageTone = 'orange';
        liftQty = okMore.qty;
        model = HKS_RANGES[HKS_RANGES.length - 1].model;
        rangeMin = HKS_RANGES[HKS_RANGES.length - 1].min;
        rangeMax = max2;
        strength = HKS_RANGES[HKS_RANGES.length - 1].strength;
        message = `Wymagana wiƒôksza liczba podno≈õnik√≥w: przyjƒôto ${liftQty} szt. (na bazie najmocniejszego HK‚ÄëS).`;
      }else{
        neededLiftQty = okMore.need;
        message = `Poza zakresem wsp√≥≈Çczynnika mocy: ${pf} (max ${max2} dla 2 szt.).`;
      }
    }else{
      model = picked.model;
      rangeMin = picked.min;
      rangeMax = picked.max;
      strength = picked.strength;
    }
  } else if(kind === 'HF_top'){
    const picked = pickByRange(HFTOP_RANGES);
    if(!picked){
      status = (status === 'out_height') ? status : 'out_pf';
      messageTone = (messageTone || 'red');
      const max2 = HFTOP_RANGES[HFTOP_RANGES.length - 1].max;
      const okMore = allowMoreLiftsIfPossible(max2);
      if(okMore.ok){
        status = (status === 'out_height') ? status : 'needs_more_lifts';
        messageTone = 'orange';
        liftQty = okMore.qty;
        model = HFTOP_RANGES[HFTOP_RANGES.length - 1].model;
        rangeMin = HFTOP_RANGES[HFTOP_RANGES.length - 1].min;
        rangeMax = max2;
        strength = HFTOP_RANGES[HFTOP_RANGES.length - 1].strength;
        message = `Wymagana wiƒôksza liczba podno≈õnik√≥w: przyjƒôto ${liftQty} szt. (na bazie najmocniejszego HF top).`;
      }else{
        neededLiftQty = okMore.need;
        message = `Poza zakresem wsp√≥≈Çczynnika mocy: ${pf} (max ${max2} dla 2 szt.).`;
      }
    }else{
      model = picked.model;
      rangeMin = picked.min;
      rangeMax = picked.max;
      strength = picked.strength;
    }
  } else if(kind === 'HKI'){
    const picked = pickByRange(HKI_RANGES);
    if(!picked){
      status = (status === 'out_height') ? status : 'out_pf';
      messageTone = (messageTone || 'red');
      const max2 = HKI_RANGES[HKI_RANGES.length - 1].max;
      const okMore = allowMoreLiftsIfPossible(max2);
      if(okMore.ok){
        status = (status === 'out_height') ? status : 'needs_more_lifts';
        messageTone = 'orange';
        liftQty = okMore.qty;
        model = HKI_RANGES[HKI_RANGES.length - 1].model;
        rangeMin = HKI_RANGES[HKI_RANGES.length - 1].min;
        rangeMax = max2;
        strength = HKI_RANGES[HKI_RANGES.length - 1].strength;
        message = `Wymagana wiƒôksza liczba podno≈õnik√≥w: przyjƒôto ${liftQty} szt. (na bazie najmocniejszego HKi).`;
      }else{
        neededLiftQty = okMore.need;
        message = `Poza zakresem wsp√≥≈Çczynnika mocy: ${pf} (max ${max2} dla 2 szt.).`;
      }
    }else{
      model = picked.model;
      rangeMin = picked.min;
      rangeMax = picked.max;
      strength = picked.strength;
    }
  } else if(kind === 'HS_top'){
    const row = HSTOP_TABLE.find(r => khMm >= r.khMin && khMm <= r.khMax) || null;
    if(!row){
      status = (status === 'out_height') ? status : 'out_pf';
      messageTone = (messageTone || 'red');
      message = message || `Poza zakresem wysoko≈õci dla HS top: KH=${khMm} mm.`;
    }else{
      const t = (khMm - row.khMin) / (row.khMax - row.khMin);
      const wMin = row.wMin0 + (row.wMin1 - row.wMin0) * t;
      const wMax = row.wMax0 + (row.wMax1 - row.wMax0) * t;
      if(fgKg < wMin || fgKg > wMax){
        status = (status === 'out_height') ? status : 'out_pf';
        messageTone = (messageTone || 'red');
        message = message || `Poza zakresem wagi frontu dla HS top (${row.model}) przy KH=${khMm} mm: waga ${fgKg.toFixed(2)} kg (dopuszczalne ok. ${wMin.toFixed(2)}‚Äì${wMax.toFixed(2)} kg).`;
      }else{
        model = row.model;
        strength = row.strength;
        rangeStr = `${wMin.toFixed(2)}‚Äì${wMax.toFixed(2)} kg (dla KH=${khMm} mm)`;
      }
    }
  } else if(kind === 'HL_top'){
    const row = HLTOP_TABLE.find(r => khMm >= r.khMin && khMm <= r.khMax) || null;
    if(!row){
      status = (status === 'out_height') ? status : 'out_pf';
      messageTone = (messageTone || 'red');
      message = message || `Poza zakresem wysoko≈õci dla HL top: KH=${khMm} mm.`;
    }else{
      if(fgKg < row.wMin || fgKg > row.wMax){
        status = (status === 'out_height') ? status : 'out_pf';
        messageTone = (messageTone || 'red');
        message = message || `Poza zakresem wagi frontu dla HL top (${row.model}) przy KH=${khMm} mm: waga ${fgKg.toFixed(2)} kg (dopuszczalne ${row.wMin}‚Äì${row.wMax} kg).`;
      }else{
        model = row.model;
        strength = row.strength;
        rangeStr = `${row.wMin}‚Äì${row.wMax} kg`;
      }
    }
  }

  let rangeStrFinal = '';
  if(rangeStr){
    rangeStrFinal = rangeStr;
  }else{
    rangeStrFinal = (rangeMin && rangeMax) ? `${rangeMin}‚Äì${rangeMax}` : '';
  }

    let finalMessage = message || '';
  let finalTone = messageTone || '';
  if(depthAdvisory){
    if(finalMessage){
      finalMessage = `${finalMessage} ${depthAdvisory}`;
      if(!finalTone) finalTone = depthAdvisoryTone || 'orange';
    }else{
      finalMessage = depthAdvisory;
      finalTone = depthAdvisoryTone || 'orange';
    }
  }

  return { kind, label, powerFactor: pf, model, rangeStr: rangeStrFinal, strength, liftQty, hkxsHinges, status, message: finalMessage, messageTone: finalTone, neededLiftQty };
}




function getCabinetCutList(cab, room){
  const t = FC_BOARD_THICKNESS_CM;
  const w = Number(cab.width) || 0;
  const h = Number(cab.height) || 0;
  const d = Number(cab.depth) || 0;
  const bodyMat = cab.bodyColor || 'laminat';
  const backMat = cab.backMaterial || 'HDF';

  const subType = String(cab.subType || '');
  // WiszƒÖca podblatowa ma byƒá liczona w materia≈Çach jak stojƒÖca
  const isUnderCounterWall = (String(cab.type || '') === 'wiszƒÖca' && subType === 'dolna_podblatowa');
  const effType = isUnderCounterWall ? 'stojƒÖca' : String(cab.type || '');

  // Plecy: dla "wiszƒÖca podblatowa" u≈ºytkownik mo≈ºe wy≈ÇƒÖczyƒá plecy (tak/nie w modalu)
  const hasBack = !(isUnderCounterWall && String((cab.details || {}).hasBack) === '0');

  const parts = [];

  // StojƒÖce: boki stojƒÖ na wie≈Ñcu dolnym => boki ni≈ºsze o grubo≈õƒá p≈Çyty
  // WyjƒÖtek: wiszƒÖca dolna podblatowa ‚Äì boki majƒÖ wysoko≈õƒá korpusu
  const sideH = (effType === 'stojƒÖca' && !isUnderCounterWall) ? Math.max(0, h - t) : h;

  // Boki: zawsze 2 szt.
  parts.push({ name:'Bok', qty:2, a: sideH, b: d, dims:`${fmtCm(sideH)} √ó ${fmtCm(d)}`, material: bodyMat });
  // Rogowa L: 1 bok du≈ºy, 1 bok ma≈Çy + bok za≈õlepiajƒÖcy (zamiast 2x bok du≈ºy)
  if(String(cab.subType || '') === 'narozna_l'){
    // usu≈Ñ domy≈õlne 2 boki
    parts.pop();

    const det = cab.details || {};
    const GL = Number(det.gl) || 0; // g≈Çƒôboko≈õƒá lewa (du≈ºy bok)
    const GP = Number(det.gp) || 0; // g≈Çƒôboko≈õƒá ma≈Çego boku
    const ST = Number(det.st) || 0; // (fallback) g≈Çƒôboko≈õƒá prawa, gdy GL=0
    const SP = Number(det.sp) || 0; // szeroko≈õƒá boku za≈õlepiajƒÖcego (przed korektƒÖ)

    // Zasady:
    // - Bok ma≈Çy: szeroko≈õci GP
    // - Bok za≈õlepiajƒÖcy: szeroko≈õci SP - 1,8
    // - Bok du≈ºy: przyjmij GL (je≈õli brak, to ST; je≈õli brak, to d)
    const bigDepth = (GL > 0 ? GL : (ST > 0 ? ST : d));
    const smallDepth = (GP > 0 ? GP : Math.max(0, Math.min(bigDepth, d)));
    const blindDepth = Math.max(0, SP - t);

    parts.push({ name:'Bok du≈ºy', qty:1, a: sideH, b: bigDepth, dims:`${fmtCm(sideH)} √ó ${fmtCm(bigDepth)}`, material: bodyMat });
    parts.push({ name:'Bok ma≈Çy', qty:1, a: sideH, b: smallDepth, dims:`${fmtCm(sideH)} √ó ${fmtCm(smallDepth)}`, material: bodyMat });

    if(blindDepth > 0){
      parts.push({ name:'Bok za≈õlepiajƒÖcy', qty:1, a: sideH, b: blindDepth, dims:`${fmtCm(sideH)} √ó ${fmtCm(blindDepth)}`, material: bodyMat });
    }
  }

  const wIn = Math.max(0, w - 2*t);

  // WiszƒÖca rogowa ≈õlepa: za≈õlepka + blenda w kolorze frontu
  if(effType === 'wiszƒÖca' && String(cab.subType || '') === 'rogowa_slepa'){
    const blind = Math.max(0, Number(cab.details?.blindPart) || 0);
    // Za≈õlepka: szeroko≈õƒá (blindPart - (1,8 + 9)), wysoko≈õƒá jak korpus
    const zA = Math.max(0, blind - (t + 9));
    const zB = h;
    if(zA > 0 && zB > 0){
      parts.push({ name:'Za≈õlepka', qty:1, a:zA, b:zB, dims:`${fmtCm(zA)} √ó ${fmtCm(zB)}`, material: bodyMat });
    }

    // Blenda: 15 cm szeroko≈õci, wysoko≈õƒá jak korpus, materia≈Ç jak front
    const fMat = cab.frontMaterial || 'laminat';
    const fCol = cab.frontColor || '';
    const frontMatKey = `Front: ${fMat}${fCol ? ` ‚Ä¢ ${fCol}` : ''}`;
    parts.push({ name:'Blenda', qty:1, a:15, b:h, dims:`${fmtCm(15)} √ó ${fmtCm(h)}`, material: frontMatKey });
  }

  // Wie≈Ñce
  if(effType === 'wiszƒÖca' || effType === 'modu≈Ç'){
    // WiszƒÖce: wie≈Ñce p≈Çytsze o 2cm od korpusu; modu≈Çy: bez tej korekty (tylko jak wiszƒÖce w skrƒôcaniu)
    const crownDepth = (effType === 'wiszƒÖca') ? Math.max(0, d - 2) : d;
    parts.push({ name:'Wieniec g√≥rny', qty:1, a:wIn, b:crownDepth, dims:`${fmtCm(wIn)} √ó ${fmtCm(crownDepth)}`, material: bodyMat });
    parts.push({ name:'Wieniec dolny', qty:1, a:wIn, b:crownDepth, dims:`${fmtCm(wIn)} √ó ${fmtCm(crownDepth)}`, material: bodyMat });
  }

  if(effType === 'stojƒÖca'){
    if(isUnderCounterWall){
      // WiszƒÖca dolna podblatowa: wieniec dolny MIƒòDZY bokami, boki pe≈Çnej wysoko≈õci korpusu
      parts.push({ name:'Wieniec dolny', qty:1, a:wIn, b:d, dims:`${fmtCm(wIn)} √ó ${fmtCm(d)}`, material: bodyMat });
    } else {
      // StojƒÖce: wieniec dolny POD bokami => szer. zewn.
      parts.push({ name:'Wieniec dolny', qty:1, a:w, b:d, dims:`${fmtCm(w)} √ó ${fmtCm(d)}`, material: bodyMat });
    }

    // Trawersy g√≥rne (2 szt.) miƒôdzy bokami, g≈Çƒôboko≈õƒá 9cm
    parts.push({ name:`Trawers g√≥rny (${fmtCm(FC_TOP_TRAVERSE_DEPTH_CM)} cm)`, qty:2, a:wIn, b:FC_TOP_TRAVERSE_DEPTH_CM, dims:`${fmtCm(wIn)} √ó ${fmtCm(FC_TOP_TRAVERSE_DEPTH_CM)}`, material: bodyMat });
  }

  // P√≥≈Çki (je≈õli sƒÖ w szczeg√≥≈Çach)
  const shelves = parseInt((cab.details && cab.details.shelves) ?? 0, 10);
  // StojƒÖce szuflady: w "Materia≈Çy" nie rozpisujemy szuflad jako p√≥≈Çek.
  const isStandingDrawerCabinet = (effType === 'stojƒÖca' && String(cab.subType || '') === 'szuflady');
  if(!isStandingDrawerCabinet && Number.isFinite(shelves) && shelves > 0){
    let shelfDepth = d;

    // 1) StojƒÖce: p√≥≈Çki p≈Çytsze o 0,5cm od korpusu
    // 2) Modu≈Çy: tak samo jak stojƒÖce
    if(effType === 'stojƒÖca' || effType === 'modu≈Ç'){
      shelfDepth = Math.max(0, d - 0.5);
    }

    // 3) WiszƒÖce: p√≥≈Çki p≈Çytsze o 0,5cm od wie≈Ñc√≥w; a wie≈Ñce sƒÖ p≈Çytsze o 2cm od korpusu
    if(effType === 'wiszƒÖca'){
      shelfDepth = Math.max(0, (d - 2) - 0.5); // d - 2,5
    }

    parts.push({ name:'P√≥≈Çka', qty:shelves, a:wIn, b:shelfDepth, dims:`${fmtCm(wIn)} √ó ${fmtCm(shelfDepth)}`, material: bodyMat });
  }

  // Plecy (HDF / p≈Çyta)
  if(backMat && hasBack){
    let backW = w;
    let backH = h;

    // 1) StojƒÖce: plecy mniejsze o 0,5cm wzglƒôdem korpusu
    // 2) Modu≈Çy: tak samo jak stojƒÖce
    if(effType === 'stojƒÖca' || effType === 'modu≈Ç'){
      backW = Math.max(0, w - 0.5);
      backH = Math.max(0, h - 0.5);
    }

    // 3) WiszƒÖce:
    //   A) ni≈ºsze o 0,5cm od korpusu
    //   B) szersze o 2cm wzglƒôdem wie≈Ñca (wieniec = szeroko≈õƒá wewnƒôtrzna)
    if(effType === 'wiszƒÖca'){
      backW = Math.max(0, wIn + 2);
      backH = Math.max(0, h - 0.5);
    }

    parts.push({ name:'Plecy', qty:1, a:backW, b:backH, dims:`${fmtCm(backW)} √ó ${fmtCm(backH)}`, material: backMat });
  }

  // Fronty (materia≈Çy)
  const frontParts = getCabinetFrontCutListForMaterials(room, cab);
  frontParts.forEach(p => parts.push(p));

  

  // Zawiasy BLUM (okucia) ‚Äî dodaj do materia≈Ç√≥w jako ilo≈õƒá sztuk (bez wp≈Çywu na sumy m¬≤)
// UWAGA: dla klap z AVENTOS HK‚ÄëXS ilo≈õƒá zawias√≥w wynika z tabel (KB/LF) i dodajemy je poni≈ºej jako osobnƒÖ pozycjƒô.
let hingeQty = getHingeCountForCabinet(room, cab);
try{
  const det = cab.details || {};
  const isHKXS = (String(cab.subType||'') === 'uchylne'
    && String(det.flapVendor||'blum') === 'blum'
    && String(det.flapKind||'HK-XS') === 'HK-XS');
  if(isHKXS) hingeQty = 0;
}catch(e){ /* noop */ }

if(hingeQty > 0){
  parts.push({ name:'Zawias BLUM', qty:hingeQty, a:0, b:0, dims:'‚Äî', material:'Okucia: zawiasy BLUM' });
}


  
// Podno≈õniki BLUM AVENTOS (dla klap uchylnych) ‚Äî model + zakres LF + opis "mocy"
// Ostrzeganie/przerwanie dodawania robimy na etapie MODALA (przy dodawaniu/edycji),
// wiƒôc w materia≈Çach pokazujemy tylko poprawnie dobrane okucia.
if(String(cab.subType || '') === 'uchylne'){
  const info = getBlumAventosInfo(cab, room);
  if(info && (!info.status || info.status === 'ok' || info.status === 'needs_more_lifts')){
      const nameSuffix = (info.model ? ` ${info.model}` : '');
      const strengthSuffix = (info.strength ? ` (${info.strength})` : '');
      const rangeTxt = (info.rangeStr
        ? (String(info.rangeStr).includes('kg') ? `zakres wagi ${info.rangeStr}` : `zakres LF ${info.rangeStr}`)
        : 'zakres ‚Äî');
      const qtyLift = (info.liftQty && info.liftQty > 0) ? info.liftQty : 2;
      parts.push({
        name:`Podno≈õnik BLUM AVENTOS ${info.label}${nameSuffix}${strengthSuffix}`,
        qty: qtyLift,
        a:0, b:0,
        dims:`LF=${info.powerFactor} ‚Ä¢ ${rangeTxt}${(info.status === 'needs_more_lifts' ? ` ‚Ä¢ UWAGA: przyjƒôto ${qtyLift} szt.` : '')}`,
        material:'Okucia: podno≈õniki BLUM'
      });

      if(info.status === 'needs_more_lifts'){
        parts[parts.length-1].tone = 'orange';
      }

      // HK-XS: zawiasy wg tabel (liczymy oddzielnie od drzwi)
      if(info.hkxsHinges && info.hkxsHinges > 0){
        parts.push({ name:'Zawias BLUM (HK‚ÄëXS)', qty:info.hkxsHinges, a:0, b:0, dims:'‚Äî', material:'Okucia: zawiasy BLUM' });
      }
  }
}

return parts;
}



function renderMaterialsTab(listEl, room){
  const cabinets = projectData[room].cabinets || [];

  // Suma projektu
  const projectTotals = {};
  cabinets.forEach(cab => {
    const parts = getCabinetCutList(cab, room);
    mergeTotals(projectTotals, totalsFromParts(parts));
  });

  const top = document.createElement('div');
  top.className = 'card';
  top.innerHTML = `
    <div style="display:flex;justify-content:space-between;align-items:center;gap:10px">
      <h3 style="margin:0">Materia≈Çy ‚Äî rozpiska mebli</h3>
</div>
    <p class="muted" style="margin:6px 0 0">
      Poni≈ºej jest rozpisany ka≈ºdy dodany mebel (korpus). Wymiary sƒÖ liczone "na czysto" z za≈Ço≈ºeniem p≈Çyty 18&nbsp;mm.
      Nie uwzglƒôdnia to oklein, wpust√≥w pod plecy ani luz√≥w technologicznych.
    </p>

    <div class="hr"></div>
    <div class="muted xs" style="line-height:1.55">
      <div><strong>Zasady skrƒôcania:</strong></div>
      <div>‚Ä¢ WiszƒÖce: wieniec g√≥rny i dolny miƒôdzy boki.</div>
      <div>‚Ä¢ Modu≈Çowe: jak wiszƒÖce.</div>
      <div>‚Ä¢ StojƒÖce: wieniec dolny pod boki (boki ni≈ºsze o ${FC_BOARD_THICKNESS_CM} cm); trawersy g√≥rne: g≈Çƒôboko≈õƒá ${FC_TOP_TRAVERSE_DEPTH_CM} cm.</div>
    </div>

    <div class="hr"></div>
    <div>
      <div class="muted xs" style="font-weight:900; margin-bottom:6px">Suma m¬≤ materia≈Ç√≥w ‚Äî ca≈Çy projekt</div>
      <div id="projectMatTotals"></div>
      <div class="muted xs" style="margin-top:8px;line-height:1.45">
        <div><strong>Za≈Ço≈ºenia do oblicze≈Ñ zawias√≥w/podno≈õnik√≥w (waga front√≥w):</strong></div>
        <div>‚Ä¢ Laminat 18&nbsp;mm: <span id="wLam"></span> kg/m¬≤</div>
        <div>‚Ä¢ Akryl (MDF 18&nbsp;mm): <span id="wAkr"></span> kg/m¬≤</div>
        <div>‚Ä¢ Lakier (MDF 18&nbsp;mm): <span id="wLak"></span> kg/m¬≤</div>
        <div>‚Ä¢ Uchwyt (zawiasy): ${FC_HANDLE_WEIGHT_KG} kg / front; (podno≈õniki klap): ${FC_HANDLE_WEIGHT_KG*2} kg / klapa</div>
        <div style="font-size:12px;color:#5b6b7c;margin-top:6px">Uchwyty doliczane tylko gdy wybrany system z uchwytem (TIP-ON/podchwyt = 0 kg).</div>
      </div>
    </div>
  `;
  listEl.appendChild(top);

  // wype≈Çnij sumy projektu
  const projTotalsEl = top.querySelector('#projectMatTotals');
  if(projTotalsEl) renderTotals(projTotalsEl, projectTotals);

  // wagi za≈Ço≈ºone (kg/m¬≤) ‚Äî do informacji na g√≥rze
  const wLamEl = top.querySelector('#wLam');
  const wAkrEl = top.querySelector('#wAkr');
  const wLakEl = top.querySelector('#wLak');
  if(wLamEl) wLamEl.textContent = String(FC_FRONT_WEIGHT_KG_M2.laminat);
  if(wAkrEl) wAkrEl.textContent = String(FC_FRONT_WEIGHT_KG_M2.akryl);
  if(wLakEl) wLakEl.textContent = String(FC_FRONT_WEIGHT_KG_M2.lakier);


  if(!cabinets.length){
    const empty = document.createElement('div');
    empty.className = 'build-card';
    empty.innerHTML = '<h3>Brak mebli</h3><p class="muted">Dodaj szafki, ≈ºeby pojawi≈Ça siƒô rozpiska materia≈Ç√≥w.</p>';
    listEl.appendChild(empty);
    return;
  }

  cabinets.forEach((cab, idx) => {
    const card = document.createElement('div');
    card.className = 'card';

    card.id = `mat-${cab.id}`;

    const badge = cab.setId && typeof cab.setNumber === 'number'
      ? `<span class="badge">Zestaw ${cab.setNumber}</span>`
      : '';

    const head = document.createElement('div');
    head.style.display = 'flex';
    head.style.justifyContent = 'space-between';
    head.style.alignItems = 'baseline';
    head.style.gap = '12px';
    head.innerHTML = `
      <div>
        <div style="font-weight:900">#${idx+1} ‚Ä¢ ${cab.type || ''} ‚Ä¢ ${cab.subType || ''} ${badge}</div>
        <div class="muted xs">${cab.width} √ó ${cab.height} √ó ${cab.depth} ‚Ä¢ korpus: ${cab.bodyColor || ''} ‚Ä¢ plecy: ${cab.backMaterial || ''}</div>
      </div>
      <div style="display:flex;gap:10px;align-items:center;justify-content:flex-end;flex-wrap:wrap">
        <div class="muted xs" style="white-space:nowrap">${getCabinetAssemblyRuleText(cab)}</div>
        <button class="btn" type="button" data-act="editCab" data-cab="${cab.id}">Edytuj</button>
        <button class="btn" type="button" data-act="jumpCab" data-cab="${cab.id}">‚Üê Szafka</button>
      </div>
    `;
    card.appendChild(head);

    const isOpen = String(uiState.matExpandedId || '') === String(cab.id);
    if(isOpen) card.classList.add('selected');

    head.style.cursor = 'pointer';
    head.addEventListener('click', (e) => {
      if(e && e.target && e.target.closest && e.target.closest('button')) return;
      const nowOpen = String(uiState.matExpandedId || '') === String(cab.id);
      uiState.matExpandedId = nowOpen ? null : String(cab.id);
      FC.storage.setJSON(STORAGE_KEYS.ui, uiState);
      renderCabinets();
    });

    const _editCabBtn = head.querySelector('[data-act="editCab"]');
    if(_editCabBtn){
      _editCabBtn.addEventListener('click', (e) => {
        e.preventDefault(); e.stopPropagation();
        openCabinetModalForEdit(_editCabBtn.getAttribute('data-cab'));
      });
    }

    const _jumpCabBtn = head.querySelector('[data-act=\"jumpCab\"]');
    if(_jumpCabBtn){
      _jumpCabBtn.addEventListener('click', (e) => {
        e.preventDefault(); e.stopPropagation();
        jumpToCabinetFromMaterials(_jumpCabBtn.getAttribute('data-cab'));
      });
    }

    if(!isOpen){
      const collapsedHint = document.createElement('div');
      collapsedHint.className = 'muted xs';
      collapsedHint.style.marginTop = '10px';
      collapsedHint.textContent = 'Kliknij nag≈Ç√≥wek, aby rozwinƒÖƒá rozpis materia≈Ç√≥w tej szafki.';
      card.appendChild(collapsedHint);
      listEl.appendChild(card);
      return;
    }

    const parts = getCabinetCutList(cab, room);

    // SUMA m¬≤ dla szafki
    const cabTotalsBox = document.createElement('div');
    cabTotalsBox.style.marginTop = '10px';
    cabTotalsBox.style.paddingTop = '10px';
    cabTotalsBox.style.borderTop = '1px solid #eef6fb';
    cabTotalsBox.innerHTML = `<div class="muted xs" style="font-weight:900; margin-bottom:6px">Suma m¬≤ materia≈Ç√≥w ‚Äî ta szafka</div>`;
    const cabTotalsEl = document.createElement('div');
    cabTotalsBox.appendChild(cabTotalsEl);
    card.appendChild(cabTotalsBox);
    renderTotals(cabTotalsEl, totalsFromParts(parts));

    const table = document.createElement('div');
    table.style.marginTop = '12px';
    table.style.border = '1px solid #eef6fb';
    table.style.borderRadius = '12px';
    table.style.overflow = 'hidden';

    const tHead = document.createElement('div');
    tHead.className = 'front-row';
    tHead.style.background = '#f8fbff';
    tHead.innerHTML = `
      <div style="font-weight:900">Element</div>
      <div class="front-meta">Ilo≈õƒá</div>
      <div class="front-meta">Wymiar (cm)</div>
      <div class="front-meta">Materia≈Ç</div>
    `;
    tHead.style.display = 'grid';
    tHead.style.gridTemplateColumns = '1.4fr 0.4fr 0.7fr 1fr';
    tHead.style.gap = '10px';
    table.appendChild(tHead);

    
parts.forEach(p => {
      const row = document.createElement('div');
      row.className = 'front-row';
      row.style.display = 'grid';
      row.style.gridTemplateColumns = '1.4fr 0.4fr 0.7fr 1fr';
      row.style.gap = '10px';

      if(p.tone === 'red'){
        row.style.background = '#ffe1e1';
        row.style.borderLeft = '6px solid #d33';
      }else if(p.tone === 'orange'){
        row.style.background = '#fff0d6';
        row.style.borderLeft = '6px solid #f0a000';
      }

      row.innerHTML = `
        <div style="font-weight:900">${p.name}</div>
        <div style="font-weight:900">${p.qty}</div>
        <div style="font-weight:900">${p.dims}</div>
        <div class="front-meta">${p.material || ''}</div>
      `;
      table.appendChild(row);
    });

    card.appendChild(table);

    // najpierw dodaj kartƒô (≈ºeby nawet przy b≈Çƒôdzie w rysunku nie zniknƒô≈Çy materia≈Çy)
    listEl.appendChild(card);
  });
}


/* ===== Render UI: cabinets (NO inline editing) ===== */
function renderCabinets(){
  const list = document.getElementById('cabinetsList'); list.innerHTML = '';
  const room = uiState.roomType;
  document.getElementById('roomTitle').textContent = room ? room.charAt(0).toUpperCase()+room.slice(1) : 'Pomieszczenie';
  if(!room) return;

  const s = projectData[room].settings;
  document.getElementById('roomHeight').value = s.roomHeight;
  document.getElementById('bottomHeight').value = s.bottomHeight;
  document.getElementById('legHeight').value = s.legHeight;
  document.getElementById('counterThickness').value = s.counterThickness;
  document.getElementById('gapHeight').value = s.gapHeight;
  document.getElementById('ceilingBlende').value = s.ceilingBlende;
  renderTopHeight();
  // zak≈Çadki
  if(uiState.activeTab === 'material'){
    renderMaterialsTab(list, room);
    return;
  }
  if(uiState.activeTab === 'rysunek'){
    renderDrawingTab(list, room);
    return;
  }

  if(uiState.activeTab !== 'wywiad'){
    const buildCard = document.createElement('div');
    buildCard.className='build-card';
    buildCard.innerHTML = '<h3>Strona w budowie</h3><p class="muted">Sekcja jest w trakcie przygotowania.</p>';
    list.appendChild(buildCard);
    return;
  }

  // grupowanie: zestawy renderujemy jako blok: korpusy + fronty zestawu pod spodem
  const cabinets = projectData[room].cabinets || [];
  const renderedSets = new Set();

  cabinets.forEach((cab, idx) => {
    // je≈õli element zestawu i nie renderowali≈õmy jeszcze zestawu -> render ca≈Çy zestaw blokiem
    if(cab.setId && !renderedSets.has(cab.setId)){
      const setId = cab.setId;
      renderedSets.add(setId);
      const setNumber = cab.setNumber;

      // wszystkie korpusy zestawu w kolejno≈õci jak w tablicy
      const setCabs = cabinets.filter(c => c.setId === setId);
      setCabs.forEach((sc, jdx) => {
        renderSingleCabinetCard(list, room, sc, idx + jdx + 1);
      });
      return;
    }

    // je≈õli to element zestawu, ale zestaw ju≈º wyrenderowany ‚Äî pomijamy
    if(cab.setId && renderedSets.has(cab.setId)) return;

    // normalna szafka
    renderSingleCabinetCard(list, room, cab, idx+1);
  });
}

function renderSingleCabinetCard(list, room, cab, displayIndex){
  const cabEl = document.createElement('div');
  cabEl.className = 'cabinet';
  cabEl.id = `cab-${cab.id}`;
  if(uiState.selectedCabinetId === cab.id) cabEl.classList.add('selected');

  const header = document.createElement('div');
  header.className = 'cabinet-header';

  const left = document.createElement('div');
  const badge = cab.setId && typeof cab.setNumber === 'number'
    ? `<span class="badge">Zestaw ${cab.setNumber}</span>`
    : '';
  left.innerHTML = (() => {
    const base = `<div style="font-weight:900">#${displayIndex} ‚Ä¢ ${cab.type} ‚Ä¢ ${cab.subType||''}${badge}</div>
                    <div class="muted xs">${cab.frontMaterial || ''} ‚Ä¢ ${cab.frontColor || ''}</div>`;
    return base;
  })();

  const right = document.createElement('div');
  right.style.display = 'flex';
  right.style.gap = '10px';
  right.style.alignItems = 'center';

  const dims = document.createElement('div');
  dims.className = 'muted xs';
  dims.textContent = `${cab.width} √ó ${cab.height} √ó ${cab.depth}`;

  const actions = document.createElement('div');
  actions.className = 'cab-actions';
  actions.innerHTML = `<button class="btn" data-act="edit" type="button">Edytuj</button> <button class="btn" data-act="mat" type="button">Materia≈Çy</button> <button class="btn btn-danger" data-act="del" type="button">Usu≈Ñ</button>`;

  right.appendChild(dims);
  right.appendChild(actions);

  header.appendChild(left);
  header.appendChild(right);
  cabEl.appendChild(header);

  // actions: edit/delete per-cabinet
  actions.addEventListener('click', (e) => {
    e.stopPropagation();
    const btn = e.target && e.target.closest ? e.target.closest('button') : null;
    if(!btn) return;
    const act = btn.getAttribute('data-act');
    if(act === 'edit'){
      openCabinetModalForEdit(cab.id);
      return;
    }
    if(act === 'mat'){
      jumpToMaterialsForCabinet(cab.id);
      return;
    }
    if(act === 'del'){
      deleteCabinetById(cab.id);
      return;
    }
  });

  header.addEventListener('click', (e) => {
    if(e.target && e.target.closest && e.target.closest('button')) return;

    if(uiState.activeTab === 'wywiad'){
      uiState.selectedCabinetId = (uiState.selectedCabinetId === cab.id) ? null : cab.id;
    }
    toggleExpandAll(cab.id);
    FC.storage.setJSON(STORAGE_KEYS.ui, uiState);
    renderCabinets();
  });

  actions.querySelector('[data-act="edit"]').addEventListener('click', (e) => {
    e.stopPropagation();
    openCabinetModalForEdit(cab.id);
  });

  

    const _matBtn = actions.querySelector('[data-act="mat"]');
  if(_matBtn){
    _matBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      jumpToMaterialsForCabinet(cab.id);
    });
  }

  actions.querySelector('[data-act=\"del\"]').addEventListener('click', (e) => {
    e.stopPropagation();
    deleteCabinetById(cab.id);
  });
if(uiState.expanded[cab.id]){
    const body = document.createElement('div');
    body.className = 'cabinet-body';

    const summary = getCabinetExtraSummary(room, cab);

    const ro = document.createElement('div');
    ro.className = 'ro-grid';
    ro.innerHTML = `
      <div class="ro-box"><div class="muted xs">Rodzaj</div><div class="ro-val">${cab.type || ''}</div></div>
      <div class="ro-box"><div class="muted xs">Wariant</div><div class="ro-val">${cab.subType || ''}</div></div>
      <div class="ro-box"><div class="muted xs">Szczeg√≥≈Çy</div><div class="ro-val">${summary || '‚Äî'}</div></div>

      <div class="ro-box"><div class="muted xs">Wymiary</div><div class="ro-val">${cab.width} √ó ${cab.height} √ó ${cab.depth}</div></div>
      <div class="ro-box"><div class="muted xs">Front</div><div class="ro-val">${cab.frontMaterial || ''}</div><div class="muted xs">${cab.frontColor || ''}</div></div>
      <div class="ro-box"><div class="muted xs">Korpus / Plecy</div><div class="ro-val">${cab.bodyColor || ''}</div><div class="muted xs">${cab.backMaterial || ''}</div></div>

      <div class="ro-box"><div class="muted xs">Otwieranie</div><div class="ro-val">${cab.openingSystem || ''}</div></div>
    `;
    body.appendChild(ro);

    // FRONTY (wewnƒÖtrz tej samej szafki / zestawu ‚Äî zwijajƒÖ siƒô razem)
    const frontsForThis = cab.setId ? getFrontsForSet(room, cab.setId) : getFrontsForCab(room, cab.id);
    if(frontsForThis && frontsForThis.length){
      const fb = document.createElement('div');
      fb.className = 'front-block';
      const title = cab.setId
        ? `Fronty zestawu <span class="badge">Zestaw ${cab.setNumber}</span>`
        : 'Fronty szafki';
      fb.innerHTML = `
        <div class="head">
          <div>${title}</div>
          <div class="front-meta">${frontsForThis.length} szt.</div>
        </div>
      `;
      frontsForThis.forEach((f) => {
        const row = document.createElement('div');
        row.className = 'front-row';
        row.innerHTML = `
          <div>
            <div style="font-weight:900">Front: ${f.width} √ó ${f.height}</div>
            <div class="front-meta">${(f.material||'')}${(f.color ? ' ‚Ä¢ ' + f.color : '')}${(f.note ? ' ‚Ä¢ ' + f.note : '')}</div>
          </div>
          <div style="font-weight:900">${Number(f.width)||0}√ó${Number(f.height)||0}</div>
        `;
        fb.appendChild(row);
      });
      body.appendChild(fb);
    }


    const hint = document.createElement('div');
    hint.className = 'muted xs';
    hint.style.marginTop = '10px';
    hint.style.padding = '10px';
    hint.style.border = '1px solid #eef6fb';
    hint.style.borderRadius = '10px';
    hint.style.background = '#fbfdff';
    hint.textContent = 'Edycja tylko przez przycisk ‚ÄûEdytuj‚Äù.';
    body.appendChild(hint);

    cabEl.appendChild(body);
  }

  list.appendChild(cabEl);
}

/* ===== Price modal render ===== */
function renderPriceModal(){
  const modal = document.getElementById('priceModal'); const type = uiState.showPriceList;
  if(!type){ modal.style.display = 'none'; return; }
  modal.style.display = 'flex';
  const isMat = type === 'materials';
  document.getElementById('priceModalTitle').textContent = isMat ? 'Cennik Materia≈Ç√≥w' : 'Cennik Us≈Çug';
  document.getElementById('priceModalSubtitle').textContent = isMat ? 'Dodaj/edytuj materia≈Çy' : 'Dodaj/edytuj us≈Çugi';
  document.getElementById('priceModalIcon').textContent = isMat ? 'üß©' : 'üîß';
  document.getElementById('materialFormFields').style.display = isMat ? 'block' : 'none';
  document.getElementById('serviceFormFields').style.display = isMat ? 'none' : 'block';
  document.getElementById('editingIndicator').style.display = uiState.editingId ? 'inline-block' : 'none';

  const formMaterialType = document.getElementById('formMaterialType'); formMaterialType.innerHTML = '';
  ['laminat','akryl','lakier','blat','akcesoria'].forEach(t => { const o=document.createElement('option'); o.value=t; o.textContent=t; formMaterialType.appendChild(o); });
  const formManufacturer = document.getElementById('formManufacturer');
  function populateManufacturersFor(typeVal){ formManufacturer.innerHTML=''; (MANUFACTURERS[typeVal]||[]).forEach(m=>{const o=document.createElement('option'); o.value=m; o.textContent=m; formManufacturer.appendChild(o)}); }
  populateManufacturersFor(formMaterialType.value);
  formMaterialType.onchange = () => populateManufacturersFor(formMaterialType.value);

  if(uiState.editingId){
    if(isMat){
      const item = materials.find(m => m.id === uiState.editingId);
      if(item){
        formMaterialType.value = item.materialType || 'laminat';
        populateManufacturersFor(formMaterialType.value);
        document.getElementById('formManufacturer').value = item.manufacturer || '';
        document.getElementById('formSymbol').value = item.symbol || '';
        document.getElementById('formName').value = item.name || '';
        document.getElementById('formPrice').value = item.price || '';
      }
    } else {
      const item = services.find(s => s.id === uiState.editingId);
      if(item){
        document.getElementById('formCategory').value = item.category || 'Monta≈º';
        document.getElementById('formServiceName').value = item.name || '';
        document.getElementById('formServicePrice').value = item.price || '';
      }
    }
    document.getElementById('cancelEditBtn').style.display = isMat ? 'inline-block' : 'none';
    document.getElementById('cancelServiceEditBtn').style.display = isMat ? 'none' : 'inline-block';
  } else {
    formMaterialType.value = 'laminat'; populateManufacturersFor('laminat');
    document.getElementById('formSymbol').value = '';
    document.getElementById('formName').value = '';
    document.getElementById('formPrice').value = '';
    document.getElementById('formCategory').value = 'Monta≈º';
    document.getElementById('formServiceName').value = '';
    document.getElementById('formServicePrice').value = '';
    document.getElementById('cancelEditBtn').style.display = 'none';
    document.getElementById('cancelServiceEditBtn').style.display = 'none';
  }

  const q = document.getElementById('priceSearch').value.trim().toLowerCase();
  const list = isMat ? materials : services;
  const filtered = list.filter(item => {
    const name = (item.name||'').toLowerCase(); const symbol=(item.symbol||'').toLowerCase(); const manu=(item.manufacturer||'').toLowerCase();
    const mt=(item.materialType||'').toLowerCase(); const cat=(item.category||'').toLowerCase();
    return name.includes(q) || symbol.includes(q) || manu.includes(q) || mt.includes(q) || cat.includes(q);
  });

  const container = document.getElementById('priceListItems'); container.innerHTML = '';
  filtered.forEach(item => {
    const row = document.createElement('div'); row.className='list-item';
    const left = document.createElement('div');
    left.innerHTML = `<div style="font-weight:900">${item.name}</div><div class="muted-tag xs">${isMat ? (item.materialType + ' ‚Ä¢ ' + (item.manufacturer||'') + (item.symbol ? ' ‚Ä¢ SYM: '+item.symbol : '')) : (item.category || '')}</div>`;
    const right = document.createElement('div'); right.style.display='flex'; right.style.gap='8px'; right.style.alignItems='center';
    const price = document.createElement('div'); price.style.fontWeight='900'; price.textContent = (Number(item.price)||0).toFixed(2) + ' PLN';
    const editBtn = document.createElement('button'); editBtn.className='btn'; editBtn.textContent='Edytuj';
    const delBtn = document.createElement('button'); delBtn.className='btn-danger'; delBtn.textContent='Usu≈Ñ';
    right.appendChild(price); right.appendChild(editBtn); right.appendChild(delBtn);
    row.appendChild(left); row.appendChild(right); container.appendChild(row);

    editBtn.addEventListener('click', () => { uiState.editingId = item.id; FC.storage.setJSON(STORAGE_KEYS.ui, uiState); renderPriceModal(); });
    delBtn.addEventListener('click', () => deletePriceItem(item));
  });

  document.getElementById('savePriceBtn').onclick = saveMaterialFromForm;
  document.getElementById('saveServiceBtn').onclick = saveServiceFromForm;
  document.getElementById('cancelEditBtn').onclick = () => { uiState.editingId = null; FC.storage.setJSON(STORAGE_KEYS.ui, uiState); renderPriceModal(); };
  document.getElementById('cancelServiceEditBtn').onclick = () => { uiState.editingId = null; FC.storage.setJSON(STORAGE_KEYS.ui, uiState); renderPriceModal(); };
}


// Jump helpers: per-cabinet navigation between SZAFKI and MATERIA≈Å
function _scrollToAndFlash(el){
  if(!el) return;
  try{ el.scrollIntoView({behavior:'smooth', block:'start'}); } catch(_){ el.scrollIntoView(true); }
  el.classList.remove('focus-flash'); // reset if repeated
  // force reflow
  void el.offsetWidth;
  el.classList.add('focus-flash');
  window.setTimeout(()=> el.classList.remove('focus-flash'), 1300);
}

function jumpToMaterialsForCabinet(cabId){
  if(!cabId) return;
  uiState.matExpandedId = String(cabId);
  uiState._focusCabAfterRender = { tab:'material', id: String(cabId) };
  FC.storage.setJSON(STORAGE_KEYS.ui, uiState);
  setActiveTab('material');
  // after render
  window.setTimeout(() => {
    const el = document.getElementById(`mat-${cabId}`);
    _scrollToAndFlash(el);
  }, 80);
}

function jumpToCabinetFromMaterials(cabId){
  if(!cabId) return;
  // select + expand to show details
  uiState.selectedCabinetId = String(cabId);
  uiState.expanded = {};
  uiState.expanded[String(cabId)] = true;
  uiState._focusCabAfterRender = { tab:'wywiad', id: String(cabId) };
  FC.storage.setJSON(STORAGE_KEYS.ui, uiState);
  setActiveTab('wywiad');
  window.setTimeout(() => {
    const el = document.getElementById(`cab-${cabId}`);
    _scrollToAndFlash(el);
  }, 80);
}

// Centralne prze≈ÇƒÖczanie zak≈Çadek (u≈ºywane te≈º przez przyciski "skoku")
function setActiveTab(tabName){
  uiState.activeTab = tabName;
  FC.storage.setJSON(STORAGE_KEYS.ui, uiState);
  document.querySelectorAll('.tab-btn').forEach(t=>t.style.background='var(--card)');
  const activeBtn = document.querySelector(`.tab-btn[data-tab="${tabName}"]`);
  if(activeBtn) activeBtn.style.background = '#e6f7ff';
  renderCabinets();
  try{ window.scrollTo({top:0, behavior:'smooth'}); } catch(_){ window.scrollTo(0,0); }
}

/* ===== UI wiring & init ===== */
function initUI(){
  document.querySelectorAll('.room-btn').forEach(b => b.addEventListener('click', () => {
    uiState.roomType = b.getAttribute('data-room');
    FC.storage.setJSON(STORAGE_KEYS.ui, uiState);
    document.getElementById('roomsView').style.display='none';
    document.getElementById('appView').style.display='block';
    document.getElementById('topTabs').style.display = 'inline-block';
    uiState.activeTab = 'wywiad'; FC.storage.setJSON(STORAGE_KEYS.ui, uiState);
    document.querySelectorAll('.tab-btn').forEach(t=> t.style.background = (t.getAttribute('data-tab') === uiState.activeTab) ? '#e6f7ff' : 'var(--card)');
    renderCabinets();
  }));

  document.getElementById('backToRooms').addEventListener('click', () => {
    uiState.roomType = null; uiState.selectedCabinetId = null; FC.storage.setJSON(STORAGE_KEYS.ui, uiState);
    document.getElementById('roomsView').style.display='block'; document.getElementById('appView').style.display='none';
    document.getElementById('topTabs').style.display = 'none';
  });

  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      setActiveTab(btn.getAttribute('data-tab'));
    });
  });
  document.getElementById('roomHeight').addEventListener('change', e => handleSettingChange('roomHeight', e.target.value));
  document.getElementById('bottomHeight').addEventListener('change', e => handleSettingChange('bottomHeight', e.target.value));
  document.getElementById('legHeight').addEventListener('change', e => handleSettingChange('legHeight', e.target.value));
  document.getElementById('counterThickness').addEventListener('change', e => handleSettingChange('counterThickness', e.target.value));
  document.getElementById('gapHeight').addEventListener('change', e => handleSettingChange('gapHeight', e.target.value));
  document.getElementById('ceilingBlende').addEventListener('change', e => handleSettingChange('ceilingBlende', e.target.value));

  document.getElementById('floatingAdd').addEventListener('click', addCabinet);
  document.getElementById('newProjectBtn').addEventListener('click', () => {
    if(!confirm('Utworzyƒá NOWY projekt? Wszystkie pomieszczenia zostanƒÖ wyczyszczone.')) return;
    projectData = FC.utils.clone(DEFAULT_PROJECT);
    uiState.roomType = null; uiState.selectedCabinetId = null; uiState.expanded = {};
    projectData = FC.project.save(projectData); FC.storage.setJSON(STORAGE_KEYS.ui, uiState);
    document.getElementById('roomsView').style.display='block';
    document.getElementById('appView').style.display='none';
    document.getElementById('topTabs').style.display='none';
    renderCabinets();
  });

  document.getElementById('openMaterialsBtn').addEventListener('click', () => { uiState.showPriceList='materials'; FC.storage.setJSON(STORAGE_KEYS.ui, uiState); renderPriceModal(); document.getElementById('priceModal').style.display='flex'; });
  document.getElementById('openServicesBtn').addEventListener('click', () => { uiState.showPriceList='services'; FC.storage.setJSON(STORAGE_KEYS.ui, uiState); renderPriceModal(); document.getElementById('priceModal').style.display='flex'; });
  document.getElementById('closePriceModal').addEventListener('click', closePriceModal);
  document.getElementById('priceSearch').addEventListener('input', renderPriceModal);

  document.getElementById('closeCabinetModal').addEventListener('click', (e)=>{ if(e){e.preventDefault(); e.stopPropagation();} closeCabinetModal(); });
  const _cabCancel2 = document.getElementById('cabinetModalCancel');
  if(_cabCancel2) _cabCancel2.addEventListener('click', closeCabinetModal);
  document.getElementById('setWizardCancel').addEventListener('click', (e)=>{ if(e){e.preventDefault(); e.stopPropagation();} closeCabinetModal(); });
  document.getElementById('setWizardCreate').addEventListener('click', createOrUpdateSetFromWizard);

  if(uiState.roomType){
    document.getElementById('roomsView').style.display='none';
    document.getElementById('appView').style.display='block';
    document.getElementById('topTabs').style.display = 'inline-block';
  } else {
    document.getElementById('roomsView').style.display='block';
    document.getElementById('appView').style.display='none';
    document.getElementById('topTabs').style.display = 'none';
  }

  document.querySelectorAll('.tab-btn').forEach(t=> t.style.background = (t.getAttribute('data-tab') === uiState.activeTab) ? '#e6f7ff' : 'var(--card)');

  renderTopHeight();
  renderCabinets();
  if(uiState.showPriceList){ renderPriceModal(); document.getElementById('priceModal').style.display = 'flex'; }
}

/* ===== Set wizard minimal (reuse existing from previous version) ===== */
function renderCabinetTypeChoicesPlaceholder(){}



/* =========================================================
   RYSUNEK: Layout + interaktywne dodawanie wyko≈Ñcze≈Ñ
   Model danych (w projekcie):
   projectData[room].layout = { segments:[ {id,name,anchor,offsets, rows:{base:[],wall:[],tall:[]} } ] }
   - element w rows: { kind:'cabinet', id:'<cabId>' } lub { kind:'gap', id:'gap_x', width:<cm>, label:'PRZERWA' }
   projectData[room].finishes = [ {id,type,segmentId,row, ... } ]
========================================================= */
function ensureLayout(room){
  const pd = projectData[room];
  if(!pd.layout || !Array.isArray(pd.layout.segments) || pd.layout.segments.length === 0){
    const segId = 'segA';
    const seg = {
      id: segId,
      name: 'Segment A',
      anchor: 'left',
      offsets: { base: 0, module: 0, wall: 0 },
      rows: { base: [], module: [], wall: [] }
    };
    const cabs = pd.cabinets || [];
    cabs.forEach(c=>{
      const row = (c.type === 'wiszƒÖca') ? 'wall' : (c.type === 'modu≈Ç' ? 'module' : 'base');
      seg.rows[row].push({ kind:'cabinet', id:c.id });
    });
    pd.layout = { segments:[seg], activeSegmentId: segId, zOrderRows: ['base','module','wall'] };
  } else {
    // migracja starych uk≈Çad√≥w: zapewnij base/module/wall
    if(!pd.layout.zOrderRows || !Array.isArray(pd.layout.zOrderRows)) pd.layout.zOrderRows = ['base','module','wall'];
    pd.layout.segments.forEach(seg=>{
      if(seg.rows && seg.rows.tall){ delete seg.rows.tall; }
      if(!seg.rows) seg.rows = { base:[], module:[], wall:[] };
      if(!seg.rows.base) seg.rows.base = [];
      if(!seg.rows.module) seg.rows.module = [];
      if(!seg.rows.wall) seg.rows.wall = [];
      if(seg.offsets && seg.offsets.tall !== undefined){ delete seg.offsets.tall; }
      if(!seg.offsets) seg.offsets = { base:0, module:0, wall:0 };
      if(seg.offsets.base === undefined) seg.offsets.base = 0;
      if(seg.offsets.module === undefined) seg.offsets.module = 0;
      if(seg.offsets.wall === undefined) seg.offsets.wall = 0;
    });
  }
  if(!Array.isArray(pd.finishes)) pd.finishes = [];
  const act = pd.layout.activeSegmentId;
  if(act && !pd.layout.segments.find(s=>s.id===act)){
    pd.layout.activeSegmentId = pd.layout.segments[0].id;
  }
}

function getActiveSegment(room){
  ensureLayout(room);
  const pd = projectData[room];
  const segId = pd.layout.activeSegmentId || (pd.layout.segments[0] && pd.layout.segments[0].id);
  return pd.layout.segments.find(s=>s.id===segId) || pd.layout.segments[0];
}

function saveProject(){
  projectData = FC.project.save(projectData);
  FC.storage.setJSON(STORAGE_KEYS.ui, uiState);
}

function humanRow(row){
  if(row==='base') return 'DOLNE';
  if(row==='module') return 'MODU≈ÅY';
  if(row==='wall') return 'G√ìRNE';
  return row;
}

function getCabById(room, id){
  return (projectData[room].cabinets || []).find(c=>c.id===id);
}

function layoutRowTotalWidthCm(room, seg, row){
  const arr = (seg.rows[row] || []);
  let sum = 0;
  arr.forEach(el=>{
    if(el.kind==='gap') sum += Number(el.width)||0;
    else if(el.kind==='cabinet'){
      const c = getCabById(room, el.id);
      sum += (c ? Number(c.width)||0 : 0);
    }
  });
  return sum;
}

function computeXPositionsCm(room, seg, row){
  const arr = (seg.rows[row] || []);
  let x = Number(seg.offsets?.[row] || 0);
  const out = [];
  for(let i=0;i<arr.length;i++){
    const el = arr[i];
    const w = (el.kind==='gap') ? (Number(el.width)||0) : (getCabById(room, el.id)?.width || 0);
    out.push({ i, el, x0:x, x1:x + (Number(w)||0), w:Number(w)||0 });
    x += (Number(w)||0);
  }
  return out;
}

function cmToPx(cm, scale){ return cm*scale; }

function defaultFinishDims(room, finish){
  const s = projectData[room].settings || {};
  if(finish.type === 'cokol'){
    return { h: Number(s.legHeight)||10 };
  }
  if(finish.type === 'blenda_gorna'){
    return { h: Number(s.ceilingBlende)||0 };
  }
  return {};
}

function addFinish(room, finish){
  finish.id = finish.id || FC.utils.uid();
  projectData[room].finishes.push(finish);
  saveProject();
}

function removeFinish(room, finishId){
  projectData[room].finishes = (projectData[room].finishes||[]).filter(f=>f.id!==finishId);
  saveProject();
}

function insertGapAfter(room, seg, row, index, widthCm){
  const arr = seg.rows[row];
  const gap = { kind:'gap', id:'gap_'+FC.utils.uid(), width: Number(widthCm)||0, label:'PRZERWA' };
  arr.splice(index+1, 0, gap);
  saveProject();
}

function finishLabel(f){
  if(f.type==='panel') return `Panel ${f.side==='L'?'lewy':'prawy'}`;
  if(f.type==='blenda_pion') return `Blenda pion ${f.side==='L'?'lewa':'prawa'}`;
  if(f.type==='blenda_pion_full') return `Blenda pion pe≈Çna ${f.side==='L'?'lewa':'prawa'}`;
  if(f.type==='panel_pion_full') return `Panel pe≈Çny ${f.side==='L'?'lewy':'prawy'}`;
  if(f.type==='cokol') return `Cok√≥≈Ç (${humanRow(f.row)})`;
  if(f.type==='blenda_gorna') return `Blenda g√≥rna (${humanRow(f.row)})`;
  return f.type;
}

function renderFinishList(container, room){
  const seg = getActiveSegment(room);
  const finishes = (projectData[room].finishes||[]).filter(f=>f.segmentId===seg.id);
  const wrap = document.createElement('div');
  wrap.className='finish-list';
  if(finishes.length===0){
    const empty = document.createElement('div');
    empty.className='muted xs';
    empty.textContent = 'Brak dodanych wyko≈Ñcze≈Ñ w tym segmencie.';
    wrap.appendChild(empty);
  } else {
    finishes.forEach(f=>{
      const item = document.createElement('div');
      item.className='finish-item';
      const meta = document.createElement('div');
      meta.className='meta';
      const b = document.createElement('b'); b.textContent = finishLabel(f);
      const p = document.createElement('p'); p.className='muted xs'; p.style.margin='0';
      let extra = [];
      if(f.type==='panel'){
        const cabId = f.cabinetId || null;
        const c = cabId ? getCabById(room, cabId) : null;
        const fbH = (f.row==='base') ? (Math.max(40, Number(s.bottomHeight)||90) - Math.max(0, Number(s.legHeight)||0)) : (f.row==='wall') ? defaultWallH : defaultModuleH;
        const korpusH = c ? (Number(c.height)||fbH) : fbH;

        // G≈ÅƒòBOKO≈öƒÜ panelu: wg zasad
        const cabDepth = c && c.depth!=null ? Number(c.depth)||0 : (f.row==='wall' ? 32 : 59.2);
        const isModuleLikeWall = (f.row==='module') && (cabDepth <= 40); // modu≈Çy p≈Çytkie traktujemy jak g√≥rne
        let depth = 0;

        if(f.row==='wall' || isModuleLikeWall){
          depth = cabDepth + 2.2; // g√≥rne: +2,2cm
        } else {
          // dolne (i modu≈Çy g≈Çƒôbokie): je≈õli <=57 -> 59,2; je≈õli >57 -> depth + 2,5
          depth = (cabDepth > 57) ? (cabDepth + 2.5) : 59.2;
        }

        // WYSOKO≈öƒÜ panelu: korpus + cok√≥≈Ç/blenda zale≈ºnie od rzƒôdu
        let height = korpusH;
        if(f.row==='wall') height += Math.max(0, Number(s.ceilingBlende)||0);
        if(f.row==='base') height += Math.max(0, Number(s.legHeight)||0);
        // modu≈Çy: bez dodatk√≥w wysoko≈õci

        extra.push(`wymiar: ${depth.toFixed(1)}√ó${height.toFixed(1)}cm (g≈Ç.√ówys.)`);
        if(f.width!=null) extra.push(`gr.: ${Number(f.width).toFixed(1)}cm`);
      } else if(f.type==='blenda_pion'){
        extra.push(`Szafka: ${f.cabinetId || '-'}`);
        if(f.width != null) extra.push(`szer.: ${f.width}cm`);
      }
            if(f.type==='blenda_pion_full' || f.type==='panel_pion_full'){
        const wcm = Number(f.width)||2;
        const topRow = f.topRow || 'wall';
        const bottomRow = f.bottomRow || 'base';
        const order = ['wall','module','base'];
        const i0 = Math.min(order.indexOf(topRow), order.indexOf(bottomRow));
        const i1 = Math.max(order.indexOf(topRow), order.indexOf(bottomRow));
        const segRows = (Array.isArray(f.rows) && f.rows.length) ? f.rows : order.slice(i0, i1+1);

        let hcm = 0;
        for(const rk of segRows){ hcm += (rk==='wall'?wallH:(rk==='module'?moduleH:baseH)); }
        // dodatki wysoko≈õci wg zasad: je≈õli w zakresie jest g√≥rna -> + blenda; je≈õli dolna -> + cok√≥≈Ç
        if(segRows.includes('wall')) hcm += Math.max(0, Number(s.ceilingBlende)||0);
        if(segRows.includes('base')) hcm += Math.max(0, Number(s.legHeight)||0);

        if(f.type==='blenda_pion_full'){
          extra.push(`wymiar: ${wcm.toFixed(1)}√ó${hcm.toFixed(1)}cm (szer.√ówys.)`);
        } else {
          // PANEL pe≈Çny: g≈Çƒôboko≈õƒá wg zasad (bazujemy na najg≈Çƒôbszej szafce w kolumnie)
          const x0 = Math.min(Number(f.x0cm)||0, Number(f.x1cm)||0);
          const x1 = Math.max(Number(f.x0cm)||0, Number(f.x1cm)||0);
          let maxDepth = 0;
          for(const rk of segRows){
            const pos = computeXPositionsCm(room, seg, rk);
            for(const pp of pos){
              if(!pp || !pp.el || pp.el.kind!=='cabinet') continue;
              if(pp.x1<=x0 || pp.x0>=x1) continue;
              const cab = getCabById(room, pp.el.id);
              if(!cab) continue;
              const d = (cab.depth!=null) ? Number(cab.depth)||0 : (rk==='wall'?32:59.2);
              maxDepth = Math.max(maxDepth, d);
            }
          }
          const depth = (maxDepth > 57) ? (maxDepth + 2.5) : 59.2;
          extra.push(`wymiar: ${depth.toFixed(1)}√ó${hcm.toFixed(1)}cm (g≈Ç.√ówys.)`);
          if(f.width!=null) extra.push(`gr.: ${Number(f.width).toFixed(1)}cm`);
        }
        extra.push((f.side||'R')==='L' ? 'lewa' : 'prawa');
      }

            if(f.type==='blenda_pion_full' || f.type==='panel_pion_full'){
        const x0cm = Number(f.x0cm)||0;
        const x1cm = Number(f.x1cm)||0;
        const wcm = Number(f.width)||2;
        const side = f.side || 'R';
        const x0 = PAD_L + x0cm*SCALE;
        const x1 = PAD_L + x1cm*SCALE;
        const w = Math.max(8, wcm*SCALE);
        const x = (side==='L') ? (x0 - w) : x1;

        const topRow = f.topRow || 'wall';
        const bottomRow = f.bottomRow || 'base';
        const order = ['wall','module','base'];
        const i0 = Math.min(order.indexOf(topRow), order.indexOf(bottomRow));
        const i1 = Math.max(order.indexOf(topRow), order.indexOf(bottomRow));
        const segRows = (Array.isArray(f.rows) && f.rows.length) ? f.rows : order.slice(i0, i1+1);

        // y start = g√≥rna krawƒôd≈∫ topRow, y end = dolna krawƒôd≈∫ bottomRow
        if(rowY[topRow]==null || rowY[bottomRow]==null) return;

        let topY = rowY[topRow] + LABEL_H;
        let bottomY = rowY[bottomRow] + LABEL_H;
        const botHcm = (bottomRow==='wall'?wallH:(bottomRow==='module'?moduleH:baseH));
        bottomY += botHcm*SCALE;

        // dodatki: je≈õli w zakresie jest wall -> blenda; je≈õli base -> cok√≥≈Ç
        if(segRows.includes('wall')) topY -= Math.max(0, Number(s.ceilingBlende)||0)*SCALE;
        if(segRows.includes('base')) bottomY += Math.max(0, Number(s.legHeight)||0)*SCALE;

        const y = Math.min(topY, bottomY);
        const h = Math.max(10, Math.abs(bottomY - topY));

        const rr = document.createElementNS(svgNS,'rect');
        rr.setAttribute('x', x);
        rr.setAttribute('y', y);
        rr.setAttribute('width', w);
        rr.setAttribute('height', h);
        rr.setAttribute('rx', 10); rr.setAttribute('ry', 10);

        if(f.type==='blenda_pion_full'){
          rr.setAttribute('fill', 'rgba(14,165,233,0.18)');
          rr.setAttribute('stroke', 'rgba(14,165,233,0.85)');
          rr.setAttribute('stroke-width', '3');
        } else {
          rr.setAttribute('fill', 'rgba(148,163,184,0.22)');
          rr.setAttribute('stroke', 'rgba(100,116,139,0.9)');
          rr.setAttribute('stroke-width', '3');
        }
        finG.appendChild(rr);
      }

      if(f.type==='cokol' || f.type==='blenda_gorna'){
        const x0 = (f.x0cm!=null) ? Number(f.x0cm) : null;
        const x1 = (f.x1cm!=null) ? Number(f.x1cm) : null;
        if(x0!=null && x1!=null){
          extra.push(`d≈Ç.: ${((f.lengthCm!=null)?Number(f.lengthCm):Math.abs(x1-x0)).toFixed(1)}cm`);
        } else if(f.startIndex!=null && f.endIndex!=null){
          extra.push(`Zakres: ${f.startIndex+1}‚Üí${f.endIndex+1}`);
        }
        if(f.height != null) extra.push(`wys.: ${f.height}cm`);
      }
      p.textContent = extra.join(' ‚Ä¢ ');
      meta.appendChild(b); meta.appendChild(p);

      const btns = document.createElement('div');
      const del = document.createElement('button');
      del.className='btn-danger';
      del.textContent='Usu≈Ñ';
      del.onclick = ()=>{ if(confirm('UsunƒÖƒá to wyko≈Ñczenie?')){ removeFinish(room, f.id); renderCabinets(); } };
      btns.appendChild(del);

      item.appendChild(meta);
      item.appendChild(btns);
      wrap.appendChild(item);
    });
  }
  container.appendChild(wrap);
}

function renderDrawingTab(list, room){
  ensureLayout(room);
  const pd = projectData[room];
  const seg = getActiveSegment(room);

  // ephemeral UI state
  if(!uiState.drawing){
    uiState.drawing = {
      selected: null,        // {row, index}
      zoom: 6,            // px per cm (skalowanie rysunku)
      rangeStart: null,
      hRange: null,          // {row, x0cm, x1cm}
      vRange: null,          // {x0cm,x1cm, topRow, bottomRow, rows}
      drag: null             // internal
    };
  }
  const st = uiState.drawing;

  list.innerHTML = '';

  const outer = document.createElement('div');
  outer.className = 'drawing-wrap';

  // toolbar
  const toolbar = document.createElement('div');
  toolbar.className = 'drawing-toolbar';
  toolbar.innerHTML = `
    <div class="group">
      <span class="pill">Rysunek 2D (drag & drop)</span>
      <span class="muted xs">PrzeciƒÖgnij kafelki aby zmieniƒá kolejno≈õƒá. Kliknij, aby dodaƒá panel/blendƒô/przerwƒô. Shift+klik zaznacza zakres (cok√≥≈Ç / blenda g√≥rna).</span>
    </div>
    
    <div class="group" style="margin-left:auto">
      <span class="muted xs" style="margin-right:6px">Zoom:</span>
      <button id="zoomOut" class="btn" title="Pomniejsz">‚àí</button>
      <input id="zoomSlider" type="range" min="1" max="16" step="1" style="width:140px" />
      <button id="zoomIn" class="btn" title="Powiƒôksz">+</button>
      <span id="zoomVal" class="pill" style="min-width:64px;text-align:center">10px/cm</span>
      <button id="drawRebuild" class="btn">‚Üª Odbuduj z listy szafek</button>
          </div>

  `;
  outer.appendChild(toolbar);

  // layout: stage + inspector
  const grid = document.createElement('div');
  grid.style.display = 'grid';
  grid.style.gridTemplateColumns = '1fr';
  grid.style.gap = '12px';

  const stage = document.createElement('div');
  stage.className = 'drawing-stage';
  stage.style.position = 'relative';
  stage.style.overflowX = 'auto';
  stage.style.overflowY = 'hidden';
  stage.style.webkitOverflowScrolling = 'touch';

  const svgHost = document.createElement('div');
  svgHost.id = 'svgHost';
  stage.appendChild(svgHost);

  const inspector = document.createElement('div');
  inspector.className = 'card';
  inspector.style.margin = '0';
  inspector.style.maxWidth = '520px';
  inspector.style.justifySelf='center';
  inspector.innerHTML = `
    <h3 class="section-title" style="margin:0 0 10px 0">Inspektor</h3>
    <div id="insBody" class="muted xs">Kliknij kafelek (szafkƒô lub przerwƒô).</div>
    <div class="hr"></div>
    <h3 class="section-title" style="margin:0 0 10px 0">Wyko≈Ñczenia (segment)</h3>
    <div id="finList"></div>
  `;

  grid.appendChild(stage);
  grid.appendChild(inspector);
  outer.appendChild(grid);
  list.appendChild(outer);

  // toolbar actions
  toolbar.querySelector('#drawRebuild').onclick = ()=>{
    if(!confirm('Odbudowaƒá uk≈Çad segmentu z aktualnej listy szafek? (Uwaga: usuwa PRZERWY w uk≈Çadzie, NIE usuwa wyko≈Ñcze≈Ñ)')) return;
    seg.rows.base = [];
    seg.rows.module = [];
    seg.rows.wall = [];
    (pd.cabinets||[]).forEach(c=>{
      const row = (c.type === 'wiszƒÖca') ? 'wall' : (c.type === 'modu≈Ç' ? 'module' : 'base');
      seg.rows[row].push({ kind:'cabinet', id:c.id });
    });
    st.selected = null;
    st.rangeStart = null;
    st.hRange = null;
    st.vRange = null;
    saveProject();
    renderCabinets();
  };
  // zoom controls
  const zoomSlider = toolbar.querySelector('#zoomSlider');
  const zoomVal = toolbar.querySelector('#zoomVal');
  const zoomOut = toolbar.querySelector('#zoomOut');
  const zoomIn = toolbar.querySelector('#zoomIn');
  zoomSlider.value = String(Math.max(1, Math.min(16, Number(st.zoom)||10)));
  zoomVal.textContent = `${zoomSlider.value}px/cm`;

  function setZoom(val){
    st.zoom = Math.max(1, Math.min(16, Number(val)||10));
    FC.storage.setJSON(STORAGE_KEYS.ui, uiState);
    renderCabinets(); // prze-renderuje rysunek z nowƒÖ skalƒÖ
  }
  zoomSlider.addEventListener('input', ()=>{ zoomVal.textContent = `${zoomSlider.value}px/cm`; });
  zoomSlider.addEventListener('change', ()=> setZoom(zoomSlider.value));
  zoomOut.addEventListener('click', ()=> setZoom((Number(st.zoom)||10) - 1));
  zoomIn.addEventListener('click', ()=> setZoom((Number(st.zoom)||10) + 1));


  // helpers
  const s = pd.settings || {};
  const autoTopHeight = Math.max(0,
    (Number(s.roomHeight)||0)
    - (Number(s.bottomHeight)||0)
    - (Number(s.legHeight)||0) // w Twoim UI bottomHeight jest "z nogami", ale zostawiamy to symbolicznie
    - (Number(s.counterThickness)||0)
    - (Number(s.gapHeight)||0)
    - (Number(s.ceilingBlende)||0)
  );
  const defaultBaseH = Math.max(40, Number(s.bottomHeight)||90);
const defaultWallH = Math.max(40, autoTopHeight || 70);
const defaultModuleH = 60;

function cabHeightCm(el, fallback){
  if(!el || el.kind!=='cabinet') return fallback;
  const c = getCabById(room, el.id);
  const h = c ? Number(c.height)||0 : 0;
  return (h>0) ? h : fallback;
}
function maxRowHeightCm(rowKey, fallback){
  const arr = seg.rows[rowKey] || [];
  let mx = fallback;
  arr.forEach(el=>{
    if(el.kind==='cabinet'){
      const h = cabHeightCm(el, fallback);
      if(h>mx) mx=h;
    }
  });
  return Math.max(40, mx);
}
function elHeightCm(rowKey, el){
  const fb = (rowKey==='base') ? defaultBaseH : (rowKey==='wall') ? defaultWallH : defaultModuleH;
  if(!el) return fb;
  if(el.kind==='gap') return fb;
  return cabHeightCm(el, fb);
}

const baseH = maxRowHeightCm('base', defaultBaseH);
const wallH = maxRowHeightCm('wall', defaultWallH);
const moduleH = maxRowHeightCm('module', defaultModuleH);

// rysunek w proporcji: 1cm = SCALE px (w pionie i poziomie)
  const SCALE = Math.max(1, Math.min(16, Number(st.zoom)||10)); // px/cm (skalowanie rysunku)
  const PAD_L = 20, PAD_T = 18, PAD_R = 20, PAD_B = 18;
  const ROW_GAP = 0;
  const LABEL_H = 0; 

  const rows = [
    { key:'wall', label:'G√ìRNE', hCm: wallH },
    { key:'module', label:'MODU≈ÅY', hCm: moduleH },
    { key:'base', label:'DOLNE', hCm: baseH }
  ];

  function elWidthCm(rowKey, el){
    if(el.kind==='gap') return Number(el.width)||0;
    const c = getCabById(room, el.id);
    return c ? Number(c.width)||0 : 0;
  }
  function elLabel(rowKey, el){
    if(el.kind==='gap') return `PRZERWA ${Number(el.width)||0}cm`;
    const c = getCabById(room, el.id);
    if(!c) return `SZAFKA`;
    const t = (c.subType || c.type || 'szafka');
    return `${t} ${Number(c.width)||0}cm`;
  }

  function computePositions(rowKey){
    const arr = seg.rows[rowKey] || [];
    let x = Number(seg.offsets?.[rowKey]||0);
    const pos = [];
    for(let i=0;i<arr.length;i++){
      const w = elWidthCm(rowKey, arr[i]);
      pos.push({ index:i, el:arr[i], x0:x, x1:x+w, w });
      x += w;
    }
    return pos;
  }

  const totals = rows.map(r=>{
    const pos = computePositions(r.key);
    const last = pos[pos.length-1];
    return (last ? last.x1 : 0) + Number(seg.offsets?.[r.key]||0);
  });
  const totalCm = Math.max(60, ...totals);

  // SVG sizing
  const contentW = totalCm*SCALE;
  const contentH = rows.reduce((acc,r)=>acc + (r.hCm*SCALE) + LABEL_H, 0) + ROW_GAP*(rows.length-1);
  const vbW = PAD_L + contentW + PAD_R;
  const vbH = PAD_T + contentH + PAD_B;

  // extra left space so left-side finishes (e.g., left blend/panel) are visible
  const finishesAll = (projectData[room].finishes||[]).filter(f=>f.segmentId===seg.id);
  const maxLeftCm = finishesAll.reduce((m,f)=>{
    if((f.side==='L') && (f.type==='panel' || f.type==='blenda_pion' || f.type==='blenda_pion_full')){
      return Math.max(m, Number(f.width)||0);
    }
    return m;
  }, 0);
  const EXTRA_L = Math.max(0, Math.round(maxLeftCm*SCALE + 40));

  // widen viewport to include left overhang
  const vbW2 = vbW + EXTRA_L;


  const svgNS = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(svgNS,'svg');
  svg.setAttribute('viewBox', `${-EXTRA_L} 0 ${vbW2} ${vbH}`);
  svg.setAttribute('preserveAspectRatio','xMinYMin meet');
  svg.style.width = `${vbW2}px`;
  svg.style.height = `${vbH}px`;
  svg.style.display = 'block';

  // defs (subtle grid)
  const defs = document.createElementNS(svgNS,'defs');
  defs.innerHTML = `
    <pattern id="gridSmall" width="${SCALE*10}" height="${SCALE*10}" patternUnits="userSpaceOnUse">
      <path d="M ${SCALE*10} 0 L 0 0 0 ${SCALE*10}" fill="none" stroke="#eef2f7" stroke-width="1"/>
    </pattern>
  `;
  svg.appendChild(defs);
  const bg = document.createElementNS(svgNS,'rect');
  bg.setAttribute('x', -EXTRA_L); bg.setAttribute('y', 0);
  bg.setAttribute('width', vbW2); bg.setAttribute('height', vbH);
  bg.setAttribute('fill', 'url(#gridSmall)');
  bg.setAttribute('rx', 12); bg.setAttribute('ry', 12);
  bg.style.opacity = '0.7';
  svg.appendChild(bg);

  function mkText(x,y,txt,cls){
    const t = document.createElementNS(svgNS,'text');
    t.setAttribute('x',x); t.setAttribute('y',y);
    t.setAttribute('class', cls||'svg-label');
    t.textContent = txt;
    svg.appendChild(t);
    return t;
  }
  function mkRect(x,y,w,h,cls,attrs){
    const r = document.createElementNS(svgNS,'rect');
    r.setAttribute('x',x); r.setAttribute('y',y);
    r.setAttribute('width',w); r.setAttribute('height',h);
    r.setAttribute('rx',10); r.setAttribute('ry',10);
    r.setAttribute('class', cls);
    if(attrs){ Object.keys(attrs).forEach(k=>r.setAttribute(k, attrs[k])); }
    svg.appendChild(r);
    return r;
  }
  function mkGroup(attrs){
    const g = document.createElementNS(svgNS,'g');
    if(attrs){ Object.keys(attrs).forEach(k=>g.setAttribute(k, attrs[k])); }
    svg.appendChild(g);
    return g;
  }

  // range highlight (non-interactive)
  const rangeG = document.createElementNS(svgNS,'g');
  rangeG.style.pointerEvents = 'none';

  // finishes overlay (non-interactive)
  const finG = document.createElementNS(svgNS,'g');
  finG.style.pointerEvents = 'none';

  // interactive elements group
  const elG = document.createElementNS(svgNS,'g');
  svg.appendChild(elG);
  svg.appendChild(finG);
  svg.appendChild(rangeG);

  

  // Ensure overlays (range highlight + finishes) render ABOVE cabinets.
  // (Appending moves existing nodes to the end of SVG children list.)
  svg.appendChild(rangeG);
  svg.appendChild(finG);
// row y mapping (anchor countertop/reference line at default base height; taller base can extend upward)
  const rowY = {};
  // floorY = bottom of BASE row when base height == defaultBaseH
  // NOTE: keep module zone anchored; do NOT shift floorY based on tallest wall cabinet.
  const wallRefH = Number((pd.settings||{}).wallRefH)||60;
  let floorY = PAD_T
    + (LABEL_H + wallRefH*SCALE + ROW_GAP)
    + (LABEL_H + moduleH*SCALE + ROW_GAP)
    + (LABEL_H + defaultBaseH*SCALE);

  // Place BASE so its bottom stays at floorY
  rowY['base'] = floorY - (LABEL_H + baseH*SCALE);
  // Countertop/reference line is based on the ROOM default base height (not the tallest base cabinet)
  const counterY = floorY - (LABEL_H + defaultBaseH*SCALE);
  // Place MODULE so its bottom sits on the countertop/reference line
  rowY['module'] = counterY - (ROW_GAP + LABEL_H + moduleH*SCALE);
// Stack WALL above MODULE
  rowY['wall'] = rowY['module'] - (ROW_GAP + LABEL_H + wallH*SCALE);

  // If anything would go above the top padding, shift everything down
  const minY = Math.min(rowY['wall'], rowY['module'], rowY['base']);
  if(minY < PAD_T){
    const shift = PAD_T - minY;
    rowY['base'] += shift;
    rowY['module'] += shift;
    rowY['wall'] += shift;
    floorY += shift;
  }

  // Render rows
  function renderAll(){
    // clear groups
    while(elG.firstChild) elG.removeChild(elG.firstChild);
    while(rangeG.firstChild) rangeG.removeChild(rangeG.firstChild);
    while(finG.firstChild) finG.removeChild(finG.firstChild);
    // (row labels hidden)
    // range highlight
    if(st.hRange && st.hRange.row){
      const row = st.hRange.row;
      const x0cm = Number(st.hRange.x0cm)||0;
      const x1cm = Number(st.hRange.x1cm)||0;
      const x0 = PAD_L + Math.min(x0cm,x1cm)*SCALE;
      const x1 = PAD_L + Math.max(x0cm,x1cm)*SCALE;
      const hcm = (row==='wall'?wallH:(row==='module'?moduleH:baseH));
      const y = rowY[row] + LABEL_H - 6;
      const h = hcm*SCALE + 12;
      const rr = document.createElementNS(svgNS,'rect');
      rr.setAttribute('x', x0);
      rr.setAttribute('y', y);
      rr.setAttribute('width', Math.max(8, x1-x0));
      rr.setAttribute('height', h);
      rr.setAttribute('rx', 14); rr.setAttribute('ry', 14);
      rr.setAttribute('class','svg-range');
      rangeG.appendChild(rr);
    }
// vertical range highlight (od do≈Çu do g√≥ry)
if(st.vRange && st.vRange.x1cm > st.vRange.x0cm){
  const x0 = PAD_L + st.vRange.x0cm*SCALE;
  const x1 = PAD_L + st.vRange.x1cm*SCALE;
  const topRow = st.vRange.topRow || 'wall';
  const bottomRow = st.vRange.bottomRow || 'base';
  const y0 = rowY[topRow] + LABEL_H - 6;
  const y1 = rowY[bottomRow] + LABEL_H + ((rows.find(rr=>rr.key===bottomRow)?.hCm)||60)*SCALE + 6;
  const rr = document.createElementNS(svgNS,'rect');
  rr.setAttribute('x', x0);
  rr.setAttribute('y', Math.min(y0,y1));
  rr.setAttribute('width', Math.max(8, x1-x0));
  rr.setAttribute('height', Math.max(10, Math.abs(y1-y0)));
  rr.setAttribute('rx', 14); rr.setAttribute('ry', 14);
  rr.setAttribute('fill', 'rgba(14,165,233,0.08)');
  rr.setAttribute('stroke', 'rgba(14,165,233,0.65)');
  rr.setAttribute('stroke-width', '2');
  rangeG.appendChild(rr);
}
    // elements
    const drawOrder = (projectData[room].layout && Array.isArray(projectData[room].layout.zOrderRows)) ? projectData[room].layout.zOrderRows : ['base','module','wall'];
    drawOrder.forEach(rowKey=>{
      const r = rows.find(rr=>rr.key===rowKey);
      if(!r) return;
      const row = r.key;
      const pos = computePositions(row);
      pos.forEach(p=>{
        const x = PAD_L + p.x0*SCALE;
        const elHcm = elHeightCm(row, p.el);
        let y = rowY[row] + LABEL_H;
        if(row!=='wall') y += Math.max(0, (r.hCm - elHcm))*SCALE;
        const w = Math.max(24, p.w*SCALE);
        const h = Math.max(10, elHcm*SCALE);
        const g = document.createElementNS(svgNS,'g');
        g.setAttribute('data-row', row);
        g.setAttribute('data-index', String(p.index));
        g.setAttribute('data-kind', p.el.kind);
        g.setAttribute('data-id', p.el.id || '');
        g.style.cursor = 'grab';

        const isSel = st.selected && st.selected.row===row && st.selected.index===p.index;
        const rect = document.createElementNS(svgNS,'rect');
        rect.setAttribute('x', x);
        rect.setAttribute('y', y);
        rect.setAttribute('width', w);
        rect.setAttribute('height', h);
        rect.setAttribute('rx', 12); rect.setAttribute('ry', 12);
        rect.setAttribute('fill', p.el.kind==='gap' ? '#fff' : '#eaf6ff');
        rect.setAttribute('stroke', isSel ? '#0ea5e9' : (p.el.kind==='gap' ? '#94a3b8' : '#8fd3ff'));
        rect.setAttribute('stroke-width', isSel ? '3' : '2');
        if(p.el.kind==='gap'){
          rect.setAttribute('stroke-dasharray', '6 4');
        }

        g.appendChild(rect);

        // drag handle (mobile)
        if(p.el.kind!=='gap'){
          const grip = document.createElementNS(svgNS,'rect');
          grip.setAttribute('x', x + w - 20);
          grip.setAttribute('y', y + 6);
          grip.setAttribute('width', 14);
          grip.setAttribute('height', 14);
          grip.setAttribute('rx', 3); grip.setAttribute('ry', 3);
          grip.setAttribute('fill', '#0ea5e9');
          grip.setAttribute('data-grip','1');
          grip.style.cursor = 'grab';
          grip.style.touchAction = 'none';
          g.appendChild(grip);

          const gripTxt = document.createElementNS(svgNS,'text');
          gripTxt.setAttribute('x', x + w - 17);
          gripTxt.setAttribute('y', y + 17);
          gripTxt.setAttribute('fill', '#fff');
          gripTxt.setAttribute('font-size','12');
          gripTxt.setAttribute('font-weight','900');
          gripTxt.setAttribute('pointer-events','none');
          gripTxt.textContent = '‚â°';
          g.appendChild(gripTxt);
        }

        const text = document.createElementNS(svgNS,'text');
        text.setAttribute('x', x + 8);
        text.setAttribute('y', y + 18);
        text.setAttribute('class', 'svg-label');
        text.textContent = elLabel(row, p.el);

        g.appendChild(text);
        elG.appendChild(g);

        // pointer handlers for drag & click
        g.addEventListener('pointerdown', (ev)=>{
          const isGrip = (ev.target && ev.target.getAttribute && ev.target.getAttribute('data-grip')==='1');
          const isMouse = (ev.pointerType === 'mouse');
          const isTouch = !isMouse;
          // Drag only from grip on touch; mouse can drag from anywhere
          if(!isGrip && !isMouse){
            return;
          }

          try{ ev.preventDefault(); }catch(_){}
          g.setPointerCapture(ev.pointerId);
          st.drag = {
            pointerId: ev.pointerId,
            row,
            startIndex: p.index,
            startClientX: ev.clientX,
            moved: false,
            startPxX: x,
            gEl: g
          };
          g.style.cursor = 'grabbing';
        });

        g.addEventListener('pointermove', (ev)=>{
          // cancel long-press if user moves finger
          if(st._lp && st._lp.pointerId === ev.pointerId && !st._lp.fired){
            const dx0 = ev.clientX - st._lp.startX;
            const dy0 = ev.clientY - st._lp.startY;
            if(Math.abs(dx0) > 6 || Math.abs(dy0) > 6){
              clearTimeout(st._lp.timer);
              st._lp = null;
            }
          }

          if(!st.drag || st.drag.pointerId !== ev.pointerId) return;
          const dx = ev.clientX - st.drag.startClientX;
          if(Math.abs(dx) > 4) st.drag.moved = true;
          // translate group visually
          g.setAttribute('transform', `translate(${dx},0)`);
        });

        g.addEventListener('pointerup', (ev)=>{
          // clear long-press timer (if any)
          if(st._lp && st._lp.pointerId === ev.pointerId){
            const fired = st._lp.fired;
            clearTimeout(st._lp.timer);
            st._lp = null;
            // if long-press fired, do not also treat this as a click
            if(fired) return;
          }

          // TAP without drag context (common on mobile because we only start drag from the grip)
          if(!st.drag || st.drag.pointerId !== ev.pointerId){
            // prevent accidental "tap after drag" triggering click
            if(st._justDragged && (Date.now() - st._justDragged) < 220) return;
            handleClick(row, p.index, ev.shiftKey);
            return;
          }

          const drag = st.drag;
          g.releasePointerCapture(ev.pointerId);
          g.style.cursor = 'grab';
          const dx = ev.clientX - drag.startClientX;
          g.removeAttribute('transform');
          st.drag = null;
          st._justDragged = drag.moved ? Date.now() : 0;

          if(!drag.moved){
            handleClick(row, p.index, ev.shiftKey);
            return;
          }

          // commit reorder
          commitReorder(row, drag.startIndex, dx);
        });

        g.addEventListener('pointercancel', ()=>{
          if(st._lp){
            try{ clearTimeout(st._lp.timer); }catch(_){}
            st._lp = null;
          }
          if(st.drag && st.drag.gEl === g){
            g.removeAttribute('transform');
            g.style.cursor='grab';
            st.drag = null;
          }
        });

        // Fallback click handler (some Android viewers are flaky with pointerup on SVG)
        g.addEventListener('click', (ev)=>{
          if(st._justDragged && (Date.now() - st._justDragged) < 250) return;
          handleClick(row, p.index, !!ev.shiftKey);
        });

        // Touch fallback for drag & drop on mobile (when PointerEvents are not delivered properly)
        let _touchActive = false;
        g.addEventListener('touchstart', (ev)=>{
          const t = ev.touches && ev.touches[0];
          if(!t) return;
          const isGrip = (ev.target && ev.target.getAttribute && ev.target.getAttribute('data-grip')==='1');
          if(!isGrip) return; // drag only from grip to keep horizontal scroll usable
          _touchActive = true;
          try{ ev.preventDefault(); }catch(_){}
          st.drag = {
            pointerId: 'touch',
            row,
            startIndex: p.index,
            startClientX: t.clientX,
            moved: false,
            startPxX: x,
            gEl: g
          };
          g.style.cursor = 'grabbing';
        }, {passive:false});

        g.addEventListener('touchmove', (ev)=>{
          if(!_touchActive || !st.drag || st.drag.pointerId !== 'touch' || st.drag.gEl !== g) return;
          const t = ev.touches && ev.touches[0];
          if(!t) return;
          try{ ev.preventDefault(); }catch(_){}
          const dx = t.clientX - st.drag.startClientX;
          if(Math.abs(dx) > 4) st.drag.moved = true;
          g.setAttribute('transform', `translate(${dx},0)`);
        }, {passive:false});

        function _touchEnd(ev){
          if(!_touchActive) return;
          _touchActive = false;
          if(!st.drag || st.drag.pointerId !== 'touch' || st.drag.gEl !== g) return;
          try{ ev.preventDefault(); }catch(_){}
          const drag = st.drag;
          const t = (ev.changedTouches && ev.changedTouches[0]) || null;
          const clientX = t ? t.clientX : drag.startClientX;
          const dx = clientX - drag.startClientX;
          g.removeAttribute('transform');
          g.style.cursor = 'grab';
          st.drag = null;
          st._justDragged = drag.moved ? Date.now() : 0;

          if(!drag.moved){
            handleClick(row, p.index, false);
            return;
          }
          commitReorder(row, drag.startIndex, dx);
        }
        g.addEventListener('touchend', _touchEnd, {passive:false});
        g.addEventListener('touchcancel', _touchEnd, {passive:false});
      });
    });


    // gap marks overlay (X) ‚Äî keep gaps visible even if covered by another row
    rows.forEach(rr=>{
      const row = rr.key;
      const pos = computePositions(row);
      pos.forEach(p=>{
        if(p.el.kind!=='gap') return;
        const x = PAD_L + p.x0*SCALE;
        const elHcm = elHeightCm(row, p.el);
        let y = rowY[row] + LABEL_H;
        if(row!=='wall') y += Math.max(0, (rr.hCm - elHcm))*SCALE;
        const w = Math.max(24, p.w*SCALE);
        const h = Math.max(10, elHcm*SCALE);
        const inset = 8;
        const x0 = x + inset, x1 = x + w - inset;
        const y0 = y + inset, y1 = y + h - inset;

        const l1 = document.createElementNS(svgNS,'line');
        l1.setAttribute('x1', x0); l1.setAttribute('y1', y0);
        l1.setAttribute('x2', x1); l1.setAttribute('y2', y1);
        l1.setAttribute('stroke', '#94a3b8');
        l1.setAttribute('stroke-width', '2');
        finG.appendChild(l1);

        const l2 = document.createElementNS(svgNS,'line');
        l2.setAttribute('x1', x0); l2.setAttribute('y1', y1);
        l2.setAttribute('x2', x1); l2.setAttribute('y2', y0);
        l2.setAttribute('stroke', '#94a3b8');
        l2.setAttribute('stroke-width', '2');
        finG.appendChild(l2);
      });
    });

    // finishes overlays (after elements so they appear on top, but non-interactive)
    const finishes = (pd.finishes||[]).filter(f=>f.segmentId===seg.id);
    finishes.forEach(f=>{
      if(f.type==='panel' || f.type==='blenda_pion'){
        const row = f.row;
        const idx = f.index;
        const pos = computePositions(row);
        const p = pos[idx];
        if(!p) return;
        const baseX0 = PAD_L + p.x0*SCALE;
        const baseX1 = PAD_L + p.x1*SCALE;
        const rowCfg = rows.find(rr=>rr.key===row);
        const elHcm = elHeightCm(row, p.el);
        let y = rowY[row] + LABEL_H;
        if(row!=='wall') y += Math.max(0, (((rowCfg?.hCm||elHcm) - elHcm)))*SCALE;

        // Panele boczne: wyd≈Çu≈º o cok√≥≈Ç (dolne) lub blendƒô g√≥rnƒÖ (g√≥rne)
        const s = (pd.settings || {});
        let addHcm = 0;
        if(f.type==='panel'){
          if(row==='base') addHcm = Number(s.legHeight)||0;
          if(row==='wall') addHcm = Number(s.ceilingBlende)||0;
        }

        // dla g√≥rnych panel wyd≈Çu≈ºamy do g√≥ry (odejmujemy od y)
        if(f.type==='panel' && row==='wall' && addHcm>0){
          y = Math.max(0, y - addHcm*SCALE);
        }

        const h = Math.max(10, (elHcm + (addHcm||0))*SCALE);
        const w = Math.max(8, (Number(f.width)||2)*SCALE);
        const x = (f.side==='L') ? (baseX0 - w) : baseX1;
        const rr = document.createElementNS(svgNS,'rect');
        rr.setAttribute('x', x);
        rr.setAttribute('y', y);
        rr.setAttribute('width', w);
        rr.setAttribute('height', h);
        rr.setAttribute('rx', 10); rr.setAttribute('ry', 10);
        rr.setAttribute('fill', f.type==='panel' ? 'rgba(2,132,199,0.35)' : 'rgba(14,165,233,0.18)');
        rr.setAttribute('stroke', f.type==='panel' ? 'rgba(2,132,199,0.85)' : 'rgba(14,165,233,0.55)');
        rr.setAttribute('stroke-width', '2');
        finG.appendChild(rr);
      }

      if(f.type==='blenda_pion_full'){
        const x0cm = Number(f.x0cm)||0;
        const x1cm = Number(f.x1cm)||0;
        const wcm = Number(f.width)||2;
        const side = f.side || 'R';
        const x0 = PAD_L + x0cm*SCALE;
        const x1 = PAD_L + x1cm*SCALE;
        const w = Math.max(8, wcm*SCALE);
        const x = (side==='L') ? (x0 - w) : x1;

        const topRow = f.topRow || 'wall';
        const bottomRow = f.bottomRow || 'base';
        if(rowY[topRow]==null || rowY[bottomRow]==null) return;

        const topY = rowY[topRow] + LABEL_H;
        const botHcm = (bottomRow==='wall'?wallH:(bottomRow==='module'?moduleH:baseH));
        const bottomY = rowY[bottomRow] + LABEL_H + botHcm*SCALE;

        const y = Math.min(topY, bottomY);
        const h = Math.max(10, Math.abs(bottomY - topY));

        const rr = document.createElementNS(svgNS,'rect');
        rr.setAttribute('x', x);
        rr.setAttribute('y', y);
        rr.setAttribute('width', w);
        rr.setAttribute('height', h);
        rr.setAttribute('rx', 10); rr.setAttribute('ry', 10);
        rr.setAttribute('fill', 'rgba(14,165,233,0.18)');
        rr.setAttribute('stroke', 'rgba(14,165,233,0.85)');
        rr.setAttribute('stroke-width', '3');
        finG.appendChild(rr);
      }

      if(f.type==='cokol' || f.type==='blenda_gorna'){
        const row = f.row;
        const pos = computePositions(row);

        let x0cm = (f.x0cm!=null) ? Number(f.x0cm) : null;
        let x1cm = (f.x1cm!=null) ? Number(f.x1cm) : null;

        // fallback: legacy indices
        if(x0cm==null || x1cm==null){
          const a = Math.max(0, Math.min(f.startIndex, f.endIndex));
          const b = Math.min(pos.length-1, Math.max(f.startIndex, f.endIndex));
          if(!pos[a] || !pos[b]) return;
          x0cm = pos[a].x0;
          x1cm = pos[b].x1;
        }

        const span0 = Math.min(x0cm,x1cm);
        const span1 = Math.max(x0cm,x1cm);

        let lenCm = (f.lengthCm!=null) ? Number(f.lengthCm)||0 : (span1 - span0);
        if(f.lengthCm==null && f.includeGaps === false){
          lenCm = 0;
          pos.forEach(pp=>{
            if(pp.el.kind!=='cabinet') return;
            const ov = Math.min(pp.x1, span1) - Math.max(pp.x0, span0);
            if(ov>0) lenCm += ov;
          });
        }

        const px0 = PAD_L + span0*SCALE;
        const pxW = Math.max(10, lenCm*SCALE);
        const isCokol = (f.type==='cokol');
        const yBase = rowY[row] + LABEL_H + (row==='wall' ? wallH : baseH)*SCALE;
        const y = isCokol ? (yBase + 8) : Math.max(2, (rowY[row] + LABEL_H - 14));
        const rr = document.createElementNS(svgNS,'rect');
        rr.setAttribute('x', px0);
        rr.setAttribute('y', y);
        rr.setAttribute('width', pxW);
        rr.setAttribute('height', 10);
        rr.setAttribute('rx', 8); rr.setAttribute('ry', 8);
        rr.setAttribute('fill', isCokol ? 'rgba(2,132,199,0.35)' : 'rgba(14,165,233,0.18)');
        rr.setAttribute('stroke', isCokol ? 'rgba(2,132,199,0.85)' : 'rgba(14,165,233,0.55)');
        rr.setAttribute('stroke-width', '2');
        finG.appendChild(rr);
      }
    });
  }

  function handleClick(row, index, isShift){
    const arr = seg.rows[row] || [];
    if(!arr[index]) return;
    st.selected = { row, index };
    // Zakresy sƒÖ sterowane przyciskami START/KONIEC + "Wyczy≈õƒá zakres"
    // Nie kasujemy ich automatycznie przy zwyk≈Çym klikniƒôciu (mobile UX).
    saveProject();
    renderCabinets();
  }


function commitReorder(row, fromIndex, dxPx){
    const arr = seg.rows[row] || [];
    if(fromIndex < 0 || fromIndex >= arr.length) return;
    const pos = computePositions(row);
    const item = arr[fromIndex];
    const w = (pos[fromIndex] ? pos[fromIndex].w : elWidthCm(row, item));
    const startX0 = pos[fromIndex] ? pos[fromIndex].x0 : 0;
    const newCenterCm = (startX0 + w/2) + (dxPx / SCALE);

    // remove item
    arr.splice(fromIndex, 1);

    // compute insertion index by scanning midpoints
    let insertAt = arr.length;
    let x = Number(seg.offsets?.[row]||0);
    for(let i=0;i<arr.length;i++){
      const wi = elWidthCm(row, arr[i]);
      const mid = x + wi/2;
      if(newCenterCm < mid){
        insertAt = i;
        break;
      }
      x += wi;
    }
    arr.splice(insertAt, 0, item);

    // after reorder, keep selection on the moved item
    st.selected = { row, index: insertAt };
    st.hRange = null;

    saveProject();
    renderCabinets();
  }

  // Inspector rendering
  const insBody = inspector.querySelector('#insBody');
  const finList = inspector.querySelector('#finList');

  function renderInspector(){
    const sel = st.selected;
    if(!sel){
      insBody.innerHTML = `<div class="muted xs">Kliknij kafelek (szafkƒô lub przerwƒô).<br/>Zaznacz zakres: Ustaw START i KONIEC.</div>`;
      return;
    }
    const row = sel.row;
    const el = (seg.rows[row]||[])[sel.index];
    if(!el){
      insBody.innerHTML = `<div class="muted xs">Brak elementu.</div>`;
      return;
    }

    const title = document.createElement('div');
    title.style.fontWeight = '900';
    title.style.marginBottom = '8px';
    title.textContent = (el.kind==='gap')
      ? `PRZERWA ‚Ä¢ ${Number(el.width)||0}cm ‚Ä¢ ${humanRow(row)}`
      : `${(getCabById(room, el.id)?.subType || getCabById(room, el.id)?.type || 'Szafka')} ‚Ä¢ ${Number(getCabById(room, el.id)?.width)||0}cm ‚Ä¢ ${humanRow(row)}`;

    const box = document.createElement('div');
    box.innerHTML = '';
    box.appendChild(title);

    // Layer order controls (row z-order)
    const zWrap = document.createElement('div');
    zWrap.style.display='flex';
    zWrap.style.gap='8px';
    zWrap.style.alignItems='center';
    zWrap.style.margin='0 0 10px 0';
    const zLbl = document.createElement('div');
    zLbl.className='muted xs';
    zLbl.textContent = 'Warstwa: ' + humanRow(row);
    const btnUp = document.createElement('button');
    btnUp.className='btn';
    btnUp.textContent='‚ñ≤ wy≈ºej';
    const btnDn = document.createElement('button');
    btnDn.className='btn';
    btnDn.textContent='‚ñº ni≈ºej';
    btnUp.onclick = ()=>{
      const lo = projectData[room].layout;
      const arr = (lo && Array.isArray(lo.zOrderRows)) ? lo.zOrderRows.slice() : ['base','module','wall'];
      const i = arr.indexOf(row);
      // wy≈ºej = bardziej na wierzch (rysowane p√≥≈∫niej)
      if(i>=0 && i < arr.length-1){ const t=arr[i+1]; arr[i+1]=arr[i]; arr[i]=t; }
      if(lo) lo.zOrderRows = arr;
      saveProject();
      renderCabinets();
    };
    btnDn.onclick = ()=>{
      const lo = projectData[room].layout;
      const arr = (lo && Array.isArray(lo.zOrderRows)) ? lo.zOrderRows.slice() : ['base','module','wall'];
      const i = arr.indexOf(row);
      // ni≈ºej = bardziej pod spodem (rysowane wcze≈õniej)
      if(i>0){ const t=arr[i-1]; arr[i-1]=arr[i]; arr[i]=t; }
      if(lo) lo.zOrderRows = arr;
      saveProject();
      renderCabinets();
    };
    zWrap.appendChild(zLbl);
    zWrap.appendChild(btnUp);
    zWrap.appendChild(btnDn);
    box.appendChild(zWrap);

    // Zakres (START/END) ‚Äî mobile-friendly
    const rSel = document.createElement('div');
    rSel.style.display='flex';
    rSel.style.flexDirection='column';
    rSel.style.gap='8px';
    rSel.style.margin='0 0 12px 0';

    const rInfo = document.createElement('div');
    rInfo.className='muted xs';
    const rs = st.rangeStart;
    const rTxt = [];
    if(rs){
      const aEl = (seg.rows[rs.row]||[])[rs.index];
      const aLbl = aEl ? (aEl.kind==='gap' ? 'PRZERWA' : (getCabById(room, aEl.id)?.subType || getCabById(room, aEl.id)?.type || 'Szafka')) : '‚Äî';
      rTxt.push('START: ' + aLbl + ' (' + humanRow(rs.row) + ')');
    }
    if(st.hRange){
      const len = Math.abs((Number(st.hRange.x1cm)||0) - (Number(st.hRange.x0cm)||0));
      rTxt.push('ZAKRES: ' + humanRow(st.hRange.row) + ' ‚Ä¢ d≈Ç.: ' + len.toFixed(1) + 'cm');
    }
    if(st.vRange){
      rTxt.push('ZAKRES PION: ' + humanRow(st.vRange.topRow) + '‚Üí' + humanRow(st.vRange.bottomRow));
    }
    rInfo.textContent = rTxt.length ? rTxt.join(' ‚Ä¢ ') : 'Zakres: ustaw START i KONIEC.';

    const rBtns = document.createElement('div');
    rBtns.style.display='flex';
    rBtns.style.gap='8px';
    rBtns.style.flexWrap='wrap';

    const bStart = document.createElement('button');
    bStart.className='btn';
    bStart.textContent='Ustaw START';
    bStart.onclick = ()=>{
      if(el.kind==='gap'){ alert('START nie mo≈ºe byƒá przerwƒÖ. Wybierz szafkƒô.'); return; }
      st.rangeStart = { row, index: sel.index };
      st.hRange = null;
      st.vRange = null;
      saveProject();
      renderCabinets();
    };

    const bEnd = document.createElement('button');
    bEnd.className='btn-primary';
    bEnd.textContent='Ustaw KONIEC';
    bEnd.onclick = ()=>{
      if(el.kind==='gap'){ alert('KONIEC nie mo≈ºe byƒá przerwƒÖ. Wybierz szafkƒô.'); return; }
      if(!st.rangeStart){
        st.rangeStart = { row, index: sel.index };
        st.hRange = null;
        st.vRange = null;
        saveProject();
        renderCabinets();
        return;
      }
      const a = st.rangeStart;
      // same row => horizontal range (tak jak pion: po X)
      if(a.row === row){
        const pos = computePositions(row);
        const pa = pos[a.index];
        const pb = pos[sel.index];
        if(pa && pb){
          const x0cm = Math.min(pa.x0, pb.x0);
          const x1cm = Math.max(pa.x1, pb.x1);
          // Blendy/cok√≥≈Ç tylko po ciƒÖg≈Çych szafkach ‚Äì bez przerw w ≈õrodku
          const i0 = Math.min(a.index, sel.index);
          const i1 = Math.max(a.index, sel.index);
          const rowEls = (seg.rows[row]||[]);
          let hasGap = false;
          for(let i=i0;i<=i1;i++){ if(rowEls[i] && rowEls[i].kind==='gap'){ hasGap=true; break; } }
          if(hasGap){
            alert('Zakres zawiera przerwƒô. Blendy/cok√≥≈Ç mo≈ºna dodaƒá tylko na ciƒÖg≈Çych szafkach.');
            st.rangeStart = { row, index: sel.index };
            st.hRange = null; st.vRange = null;
            saveProject(); renderCabinets();
            return;
          }
          st.hRange = { row, x0cm, x1cm, startIndex: a.index, endIndex: sel.index };
          st.vRange = null;
        } else {
          st.rangeStart = { row, index: sel.index };
          st.hRange = null;
          st.vRange = null;
          saveProject();
          renderCabinets();
          return;
        }
      } else {
        const posA = computePositions(a.row);
        const posB = computePositions(row);
        const pa = posA[a.index];
        const pb = posB[sel.index];
        if(pa && pb){
          const x0cm = Math.max(pa.x0, pb.x0);
          const x1cm = Math.min(pa.x1, pb.x1);
          if(x1cm > x0cm){
            const order = ['wall','module','base']; // top -> bottom
            const ia = order.indexOf(a.row);
            const ib = order.indexOf(row);
            const topRow = order[Math.min(ia, ib)];
            const bottomRow = order[Math.max(ia, ib)];
            const rowsIncl = order.slice(Math.min(ia, ib), Math.max(ia, ib)+1);
            // Blenda pion pe≈Çna tylko je≈ºeli w kolumnie nie ma przerw w ≈ºadnym z rzƒôd√≥w
            let hasGapV = false;
            for(const rk of rowsIncl){
              const posR = computePositions(rk);
              const elsR = (seg.rows[rk]||[]);
              for(let i=0;i<elsR.length;i++){
                if(elsR[i].kind==='gap'){
                  const pr = posR[i];
                  if(pr && pr.x1 > x0cm && pr.x0 < x1cm){ hasGapV = true; break; }
                }
              }
              if(hasGapV) break;
            }
            if(hasGapV){
              alert('Zakres pionowy przechodzi przez przerwƒô. Blendy mo≈ºna dodaƒá tylko na ciƒÖg≈Çych szafkach.');
              st.rangeStart = { row, index: sel.index };
              st.hRange = null; st.vRange = null;
              saveProject(); renderCabinets();
              return;
            }
            st.vRange = { x0cm, x1cm, topRow, bottomRow, rows: rowsIncl };
            st.hRange = null;
          } else {
            // no overlap => reset start to this
            st.rangeStart = { row, index: sel.index };
            st.hRange = null;
            st.vRange = null;
            saveProject();
            renderCabinets();
            return;
          }
        }
      }
      st.rangeStart = null;
      saveProject();
      renderCabinets();
    };

    const bClear = document.createElement('button');
    bClear.className='btn';
    bClear.textContent='Wyczy≈õƒá zakres';
    bClear.onclick = ()=>{
      st.rangeStart = null;
      st.hRange = null;
      st.vRange = null;
      saveProject();
      renderCabinets();
    };

    rBtns.appendChild(bStart);
    rBtns.appendChild(bEnd);
    rBtns.appendChild(bClear);

    rSel.appendChild(rInfo);
    rSel.appendChild(rBtns);
    box.appendChild(rSel);


// Vertical range actions (od do≈Çu do g√≥ry)
if(st.vRange && st.vRange.x1cm > st.vRange.x0cm){
  const vr = st.vRange;
  const rowDiv = document.createElement('div');
  rowDiv.style.display='flex';
  rowDiv.style.flexDirection='column';
  rowDiv.style.gap='8px';
  rowDiv.style.marginBottom='10px';

  const info = document.createElement('div');
  info.className='muted xs';
  info.textContent = `Zakres pionowy: ${humanRow(vr.topRow)} ‚Üí ${humanRow(vr.bottomRow)} (kolumna)`;
  rowDiv.appendChild(info);

  // Opcje zakresu pionowego (mobile-friendly): co doliczaƒá do wysoko≈õci
  if(vr.includeTopBlende === undefined){
    // domy≈õlnie: je≈õli w kolumnie sƒÖ G√ìRNE, dolicz blendƒô g√≥rnƒÖ
    vr.includeTopBlende = true;
  }
  if(vr.includePlinth === undefined){
    // domy≈õlnie: je≈õli zakres obejmuje DOLNE, dolicz cok√≥≈Ç
    vr.includePlinth = (Array.isArray(vr.rows)? vr.rows.includes('base') : (vr.bottomRow==='base' || vr.topRow==='base'));
  }
  const optWrap = document.createElement('div');
  optWrap.style.display='flex';
  optWrap.style.flexWrap='wrap';
  optWrap.style.gap='8px';

  const btnTopOpt = document.createElement('button');
  btnTopOpt.className='btn';
  const paintTop = ()=>{ btnTopOpt.textContent = 'Blenda g√≥rna: ' + (vr.includeTopBlende ? 'TAK' : 'NIE'); };
  paintTop();
  btnTopOpt.onclick = ()=>{ vr.includeTopBlende = !vr.includeTopBlende; paintTop(); saveProject(); renderCabinets(); };

  const btnPlOpt = document.createElement('button');
  btnPlOpt.className='btn';
  const paintPl = ()=>{ btnPlOpt.textContent = 'Cok√≥≈Ç: ' + (vr.includePlinth ? 'TAK' : 'NIE'); };
  paintPl();
  btnPlOpt.onclick = ()=>{ vr.includePlinth = !vr.includePlinth; paintPl(); saveProject(); renderCabinets(); };

  optWrap.appendChild(btnTopOpt);
  optWrap.appendChild(btnPlOpt);
  rowDiv.appendChild(optWrap);

  const btnL = document.createElement('button');
  btnL.className='btn-primary';
  btnL.textContent='Dodaj blendƒô pion pe≈Çna (lewa)';
  btnL.onclick = ()=>{
    const w = parseFloat(prompt('Szeroko≈õƒá blendy (cm):','5')||'0');
    if(!(w>0)) return;
    // wysoko≈õƒá pionu: suma rzƒôd√≥w + dodatki (blenda/cok√≥≈Ç)
    const rows = (Array.isArray(vr.rows) && vr.rows.length) ? vr.rows : ['wall','module','base'];
    let hcm = 0;
    rows.forEach(rk=>{ hcm += (rk==='wall'?wallH:(rk==='module'?moduleH:baseH)); });
    // dodatek za blendƒô g√≥rnƒÖ: je≈õli w tej kolumnie sƒÖ szafki G√ìRNE (overlap w osi X)
    const _x0 = Math.min(Number(vr.x0cm)||0, Number(vr.x1cm)||0);
    const _x1 = Math.max(Number(vr.x0cm)||0, Number(vr.x1cm)||0);
    const _wallPos = computePositions('wall');
    const _hasWall = _wallPos.some(pp=>pp && pp.el && pp.el.kind==='cabinet' && (Math.min(pp.x1,_x1) - Math.max(pp.x0,_x0) > 0));
    if(vr.includeTopBlende && _hasWall) hcm += Math.max(0, Number(s.ceilingBlende)||0);
    if(vr.includePlinth && rows.includes('base')) hcm += Math.max(0, Number(s.legHeight)||0);
    addFinish(room, { type:'blenda_pion_full', segmentId:seg.id, side:'L', width:w, heightCm:Number(hcm.toFixed(1)), x0cm:vr.x0cm, x1cm:vr.x1cm, topRow:vr.topRow, bottomRow:vr.bottomRow, rows:rows });
    st.vRange = null;
    saveProject();
    renderCabinets();
  };

  const btnR = document.createElement('button');
  btnR.className='btn-primary';
  btnR.textContent='Dodaj blendƒô pion pe≈Çna (prawa)';
  btnR.onclick = ()=>{
    const w = parseFloat(prompt('Szeroko≈õƒá blendy (cm):','5')||'0');
    if(!(w>0)) return;
    // wysoko≈õƒá pionu: suma rzƒôd√≥w + dodatki (blenda/cok√≥≈Ç)
    const rows = (Array.isArray(vr.rows) && vr.rows.length) ? vr.rows : ['wall','module','base'];
    let hcm = 0;
    rows.forEach(rk=>{ hcm += (rk==='wall'?wallH:(rk==='module'?moduleH:baseH)); });
    // dodatek za blendƒô g√≥rnƒÖ: je≈õli w tej kolumnie sƒÖ szafki G√ìRNE (overlap w osi X)
    const _x0 = Math.min(Number(vr.x0cm)||0, Number(vr.x1cm)||0);
    const _x1 = Math.max(Number(vr.x0cm)||0, Number(vr.x1cm)||0);
    const _wallPos = computePositions('wall');
    const _hasWall = _wallPos.some(pp=>pp && pp.el && pp.el.kind==='cabinet' && (Math.min(pp.x1,_x1) - Math.max(pp.x0,_x0) > 0));
    if(vr.includeTopBlende && _hasWall) hcm += Math.max(0, Number(s.ceilingBlende)||0);
    if(vr.includePlinth && rows.includes('base')) hcm += Math.max(0, Number(s.legHeight)||0);
    addFinish(room, { type:'blenda_pion_full', segmentId:seg.id, side:'R', width:w, heightCm:Number(hcm.toFixed(1)), x0cm:vr.x0cm, x1cm:vr.x1cm, topRow:vr.topRow, bottomRow:vr.bottomRow, rows:rows });
    st.vRange = null;
    saveProject();
    renderCabinets();
  };

  const btnC = document.createElement('button');
  btnC.className='btn';
  btnC.textContent='Wyczy≈õƒá zakres pionowy';
  btnC.onclick = ()=>{ st.vRange=null; saveProject(); renderCabinets(); };

    const btnPL = document.createElement('button');
  btnPL.className='btn';
  btnPL.textContent='Dodaj panel pe≈Çny (lewy)';
  btnPL.onclick = ()=>{
    const w = parseFloat(prompt('Grubo≈õƒá panela (cm):','1.8')||'0');
    if(!(w>0)) return;
    // wysoko≈õƒá pionu: suma rzƒôd√≥w + dodatki (blenda/cok√≥≈Ç)
    const rows = (Array.isArray(vr.rows) && vr.rows.length) ? vr.rows : ['wall','module','base'];
    let hcm = 0;
    rows.forEach(rk=>{ hcm += (rk==='wall'?wallH:(rk==='module'?moduleH:baseH)); });
    // dodatek za blendƒô g√≥rnƒÖ: je≈õli w tej kolumnie sƒÖ szafki G√ìRNE (overlap w osi X)
    const _x0 = Math.min(Number(vr.x0cm)||0, Number(vr.x1cm)||0);
    const _x1 = Math.max(Number(vr.x0cm)||0, Number(vr.x1cm)||0);
    const _wallPos = computePositions('wall');
    const _hasWall = _wallPos.some(pp=>pp && pp.el && pp.el.kind==='cabinet' && (Math.min(pp.x1,_x1) - Math.max(pp.x0,_x0) > 0));
    if(vr.includeTopBlende && _hasWall) hcm += Math.max(0, Number(s.ceilingBlende)||0);
    if(vr.includePlinth && rows.includes('base')) hcm += Math.max(0, Number(s.legHeight)||0);
    addFinish(room, { type:'panel_pion_full', segmentId:seg.id, side:'L', width:w, heightCm:Number(hcm.toFixed(1)), x0cm:vr.x0cm, x1cm:vr.x1cm, topRow:vr.topRow, bottomRow:vr.bottomRow, rows:rows });
    st.vRange = null;
    saveProject();
    renderCabinets();
  };

  const btnPR = document.createElement('button');
  btnPR.className='btn';
  btnPR.textContent='Dodaj panel pe≈Çny (prawy)';
  btnPR.onclick = ()=>{
    const w = parseFloat(prompt('Grubo≈õƒá panela (cm):','1.8')||'0');
    if(!(w>0)) return;
    // wysoko≈õƒá pionu: suma rzƒôd√≥w + dodatki (blenda/cok√≥≈Ç)
    const rows = (Array.isArray(vr.rows) && vr.rows.length) ? vr.rows : ['wall','module','base'];
    let hcm = 0;
    rows.forEach(rk=>{ hcm += (rk==='wall'?wallH:(rk==='module'?moduleH:baseH)); });
    // dodatek za blendƒô g√≥rnƒÖ: je≈õli w tej kolumnie sƒÖ szafki G√ìRNE (overlap w osi X)
    const _x0 = Math.min(Number(vr.x0cm)||0, Number(vr.x1cm)||0);
    const _x1 = Math.max(Number(vr.x0cm)||0, Number(vr.x1cm)||0);
    const _wallPos = computePositions('wall');
    const _hasWall = _wallPos.some(pp=>pp && pp.el && pp.el.kind==='cabinet' && (Math.min(pp.x1,_x1) - Math.max(pp.x0,_x0) > 0));
    if(vr.includeTopBlende && _hasWall) hcm += Math.max(0, Number(s.ceilingBlende)||0);
    if(vr.includePlinth && rows.includes('base')) hcm += Math.max(0, Number(s.legHeight)||0);
    addFinish(room, { type:'panel_pion_full', segmentId:seg.id, side:'R', width:w, heightCm:Number(hcm.toFixed(1)), x0cm:vr.x0cm, x1cm:vr.x1cm, topRow:vr.topRow, bottomRow:vr.bottomRow, rows:rows });
    st.vRange = null;
    saveProject();
    renderCabinets();
  };
rowDiv.appendChild(btnL);
  rowDiv.appendChild(btnR);
  rowDiv.appendChild(btnC);

  box.appendChild(rowDiv);
}
    // Range actions
    if(st.hRange && st.hRange.row===row){
      const r = st.hRange;
      const btn1 = document.createElement('button');
      btn1.className='btn-primary';
      btn1.textContent = (row==='base') ? 'Dodaj cok√≥≈Ç na zakresie' : (row==='wall') ? 'Dodaj blendƒô g√≥rnƒÖ na zakresie' : 'Zakres w modu≈Çach: brak akcji';
      if(row==='module'){ btn1.disabled = true; btn1.className='btn'; }
      btn1.onclick = ()=>{
        // d≈Çugo≈õƒá zakresu liczona jako suma szeroko≈õci SZAFEK w zakresie (bez przerw)
        const x0 = Math.min(Number(r.x0cm)||0, Number(r.x1cm)||0);
        const x1 = Math.max(Number(r.x0cm)||0, Number(r.x1cm)||0);
        let lenCm = 0;
        if(r.startIndex!=null && r.endIndex!=null){
          const i0 = Math.min(r.startIndex, r.endIndex);
          const i1 = Math.max(r.startIndex, r.endIndex);
          const rowEls = (seg.rows[row]||[]);
          for(let i=i0;i<=i1;i++){
            const e = rowEls[i];
            if(!e || e.kind!=='cabinet') continue;
            const c = getCabById(room, e.id);
            lenCm += (c ? Number(c.width)||0 : 0);
          }
        } else {
          const pos = computePositions(row);
          pos.forEach(pp=>{
            if(!pp || !pp.el || pp.el.kind!=='cabinet') return;
            const ov = Math.min(pp.x1, x1) - Math.max(pp.x0, x0);
            if(ov>0) lenCm += ov;
          });
        }
addFinish(room, {
          type: (row==='base') ? 'cokol' : 'blenda_gorna',
          segmentId: seg.id,
          row,
          startIndex: r.startIndex,
          endIndex: r.endIndex,
          x0cm: x0,
          x1cm: x1,
          lengthCm: Number(lenCm.toFixed(1)),
          includeGaps: false
        });
        st.hRange = null;
        saveProject();
        renderCabinets();
      };
      const btn2 = document.createElement('button');
      btn2.className='btn';
      btn2.textContent='Wyczy≈õƒá zakres';
      btn2.onclick = ()=>{ st.hRange=null; saveProject(); renderCabinets(); };

      const rowDiv = document.createElement('div');
      rowDiv.style.display='flex';
      rowDiv.style.flexDirection='column';
      rowDiv.style.gap='8px';
      rowDiv.appendChild(btn1);
      rowDiv.appendChild(btn2);
      box.appendChild(rowDiv);

      insBody.innerHTML = '';
      insBody.appendChild(box);
      return;
    }

    // Element actions

    const actions = document.createElement('div');
    actions.style.display='flex';
    actions.style.flexDirection='column';
    actions.style.gap='8px';

    function askWidth(def){ return parseFloat(prompt('Szeroko≈õƒá (cm):', String(def)) || '0'); }

    if(el.kind==='cabinet'){
      const btnPL = document.createElement('button');
      btnPL.className='btn';
      btnPL.textContent='Dodaj panel lewy';
      btnPL.onclick = ()=>{
        const w = askWidth(1.8); if(!(w>0)) return;
        addFinish(room, { type:'panel', segmentId:seg.id, row, index:sel.index, cabinetId: el.id, side:'L', width:w });
        renderCabinets();
      };
      const btnPR = document.createElement('button');
      btnPR.className='btn';
      btnPR.textContent='Dodaj panel prawy';
      btnPR.onclick = ()=>{
        const w = askWidth(1.8); if(!(w>0)) return;
        addFinish(room, { type:'panel', segmentId:seg.id, row, index:sel.index, cabinetId: el.id, side:'R', width:w });
        renderCabinets();
      };
      const btnBL = document.createElement('button');
      btnBL.className='btn';
      btnBL.textContent='Dodaj blendƒô pion lewa';
      btnBL.onclick = ()=>{
        const w = askWidth(5); if(!(w>0)) return;
        addFinish(room, { type:'blenda_pion', segmentId:seg.id, row, index:sel.index, cabinetId: el.id, side:'L', width:w });
        renderCabinets();
      };
      const btnBR = document.createElement('button');
      btnBR.className='btn';
      btnBR.textContent='Dodaj blendƒô pion prawa';
      btnBR.onclick = ()=>{
        const w = askWidth(5); if(!(w>0)) return;
        addFinish(room, { type:'blenda_pion', segmentId:seg.id, row, index:sel.index, cabinetId: el.id, side:'R', width:w });
        renderCabinets();
      };
      const btnGapA = document.createElement('button');
      btnGapA.className='btn';
      btnGapA.textContent='Wstaw przerwƒô po prawej';
      btnGapA.onclick = ()=>{
        const w = askWidth(5); if(!(w>0)) return;
        insertGapAfter(room, seg, row, sel.index, w);
        renderCabinets();
      };

      actions.appendChild(btnPL);
      actions.appendChild(btnPR);
      actions.appendChild(btnBL);
      actions.appendChild(btnBR);
      actions.appendChild(btnGapA);
    } else {
      // gap
      const btnEdit = document.createElement('button');
      btnEdit.className='btn';
      btnEdit.textContent='Zmie≈Ñ szeroko≈õƒá przerwy';
      btnEdit.onclick = ()=>{
        const w = askWidth(Number(el.width)||5);
        if(!(w>0)) return;
        el.width = w;
        saveProject();
        renderCabinets();
      };
      const btnDel = document.createElement('button');
      btnDel.className='btn-danger';
      btnDel.textContent='Usu≈Ñ przerwƒô';
      btnDel.onclick = ()=>{
        if(!confirm('UsunƒÖƒá przerwƒô?')) return;
        (seg.rows[row]||[]).splice(sel.index,1);
        st.selected = null;
        saveProject();
        renderCabinets();
      };
      actions.appendChild(btnEdit);
      actions.appendChild(btnDel);
    }

    box.appendChild(actions);
    insBody.innerHTML = '';
    insBody.appendChild(box);
  }

  function renderFinishListPanel(){
    const segFin = (pd.finishes||[]).filter(f=>f.segmentId===seg.id);
    finList.innerHTML = '';
    if(segFin.length===0){
      finList.innerHTML = `<div class="muted xs">Brak.</div>`;
      return;
    }
    segFin.forEach(f=>{
      const row = document.createElement('div');
      row.className = 'finish-item';
      const meta = document.createElement('div');
      meta.className = 'meta';
      const b = document.createElement('b');
      b.textContent = finishLabel(f);
      const p = document.createElement('p');
      p.className = 'muted xs';
      p.style.margin='0';
      let extra = [];
      const s = pd.settings || {};

      const fmt = (n)=> {
        const v = Number(n);
        if(!isFinite(v)) return '0';
        // keep one decimal if needed
        return (Math.round(v*10)/10).toString();
      };

      if(f.type==='panel' || f.type==='blenda_pion'){
        const rowKey = f.row;
        const idx = Number(f.index)||0;
        const arr = seg.rows[rowKey] || [];
        const el = arr[idx] || null;
        const hCm = elHeightCm(rowKey, el);
        const wCm = Number(f.width)||0;
        extra.push(`${humanRow(rowKey)} ‚Ä¢ #${idx+1} ‚Ä¢ ${f.side} ‚Ä¢ szer ${fmt(wCm)}cm ‚Ä¢ wys ${fmt(hCm)}cm`);
      } else if(f.type==='blenda_pion_full'){
        const topRow = f.topRow || 'wall';
        const bottomRow = f.bottomRow || 'base';
        const side = f.side || 'R';
        const wCm = Number(f.width)||0;

        const topY = rowY[topRow] + LABEL_H;
        const botHcm = (bottomRow==='wall'?wallH:(bottomRow==='module'?moduleH:baseH));
        const bottomY = rowY[bottomRow] + LABEL_H + botHcm*SCALE;
        const hCm = Math.abs(bottomY - topY)/SCALE;

        extra.push(`kolumna ${humanRow(topRow)}‚Üí${humanRow(bottomRow)} ‚Ä¢ ${side} ‚Ä¢ szer ${fmt(wCm)}cm ‚Ä¢ wys ${fmt(hCm)}cm`);
      } else if(f.type==='cokol' || f.type==='blenda_gorna'){
        const rowKey = f.row;
        const pos = computePositions(rowKey);
        const a = Math.max(0, Math.min(Number(f.startIndex)||0, Number(f.endIndex)||0));
        const b = Math.min(pos.length-1, Math.max(Number(f.startIndex)||0, Number(f.endIndex)||0));

        let lenCm = (isFinite(Number(f.lengthCm)) && Number(f.lengthCm)>0) ? Number(f.lengthCm) : NaN;
        if(pos[a] && pos[b]){
          if(!isFinite(lenCm)){
            if(f.includeGaps === false){
              lenCm = 0;
              for(let i=a;i<=b;i++){
                if(pos[i].el && pos[i].el.kind==='cabinet') lenCm += Number(pos[i].w)||0;
              }
            } else {
              lenCm = (Number(pos[b].x1)||0) - (Number(pos[a].x0)||0);
            }
          }
        }
        const hCm = (f.type==='cokol') ? (Number(s.legHeight)||0) : (Number(s.ceilingBlende)||0);
        extra.push(`${humanRow(rowKey)} ‚Ä¢ zakres ${a+1}-${b+1} ‚Ä¢ d≈Ç ${fmt(lenCm)}cm ‚Ä¢ wys ${fmt(hCm)}cm`);
      }

      p.textContent = extra.join(' | ');
      meta.appendChild(b);
      meta.appendChild(p);

      const del = document.createElement('button');
      del.className='btn-danger';
      del.textContent='Usu≈Ñ';
      del.onclick = ()=>{ removeFinish(room, f.id); renderCabinets(); };

      row.appendChild(meta);
      row.appendChild(del);
      finList.appendChild(row);
    });
  }

  // mount svg and render
  svgHost.innerHTML = '';
  svgHost.appendChild(svg);

  renderAll();
  renderInspector();
  renderFinishListPanel();
}

function initUI(){
  document.querySelectorAll('.room-btn').forEach(b => b.addEventListener('click', () => {
    uiState.roomType = b.getAttribute('data-room');
    FC.storage.setJSON(STORAGE_KEYS.ui, uiState);
    document.getElementById('roomsView').style.display='none';
    document.getElementById('appView').style.display='block';
    document.getElementById('topTabs').style.display = 'inline-block';
    uiState.activeTab = 'wywiad'; FC.storage.setJSON(STORAGE_KEYS.ui, uiState);
    document.querySelectorAll('.tab-btn').forEach(t=> t.style.background = (t.getAttribute('data-tab') === uiState.activeTab) ? '#e6f7ff' : 'var(--card)');
    renderCabinets();
  }));

  document.getElementById('backToRooms').addEventListener('click', () => {
    uiState.roomType = null; uiState.selectedCabinetId = null; FC.storage.setJSON(STORAGE_KEYS.ui, uiState);
    document.getElementById('roomsView').style.display='block'; document.getElementById('appView').style.display='none';
    document.getElementById('topTabs').style.display = 'none';
  });

  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      uiState.activeTab = btn.getAttribute('data-tab');
      FC.storage.setJSON(STORAGE_KEYS.ui, uiState);
      document.querySelectorAll('.tab-btn').forEach(t=>t.style.background='var(--card)');
      btn.style.background = '#e6f7ff';
      renderCabinets();
    });
  });

  document.getElementById('roomHeight').addEventListener('change', e => handleSettingChange('roomHeight', e.target.value));
  document.getElementById('bottomHeight').addEventListener('change', e => handleSettingChange('bottomHeight', e.target.value));
  document.getElementById('legHeight').addEventListener('change', e => handleSettingChange('legHeight', e.target.value));
  document.getElementById('counterThickness').addEventListener('change', e => handleSettingChange('counterThickness', e.target.value));
  document.getElementById('gapHeight').addEventListener('change', e => handleSettingChange('gapHeight', e.target.value));
  document.getElementById('ceilingBlende').addEventListener('change', e => handleSettingChange('ceilingBlende', e.target.value));

  document.getElementById('floatingAdd').addEventListener('click', addCabinet);
  document.getElementById('newProjectBtn').addEventListener('click', () => {
    if(!confirm('Utworzyƒá NOWY projekt? Wszystkie pomieszczenia zostanƒÖ wyczyszczone.')) return;
    projectData = FC.utils.clone(DEFAULT_PROJECT);
    uiState.roomType = null; uiState.selectedCabinetId = null; uiState.expanded = {};
    projectData = FC.project.save(projectData); FC.storage.setJSON(STORAGE_KEYS.ui, uiState);
    document.getElementById('roomsView').style.display='block';
    document.getElementById('appView').style.display='none';
    document.getElementById('topTabs').style.display='none';
    renderCabinets();
  });

  document.getElementById('openMaterialsBtn').addEventListener('click', () => { uiState.showPriceList='materials'; FC.storage.setJSON(STORAGE_KEYS.ui, uiState); renderPriceModal(); document.getElementById('priceModal').style.display='flex'; });
  document.getElementById('openServicesBtn').addEventListener('click', () => { uiState.showPriceList='services'; FC.storage.setJSON(STORAGE_KEYS.ui, uiState); renderPriceModal(); document.getElementById('priceModal').style.display='flex'; });
  document.getElementById('closePriceModal').addEventListener('click', closePriceModal);
  document.getElementById('priceSearch').addEventListener('input', renderPriceModal);

  document.getElementById('closeCabinetModal').addEventListener('click', closeCabinetModal);
  const _cabCancel2 = document.getElementById('cabinetModalCancel');
  if(_cabCancel2) _cabCancel2.addEventListener('click', closeCabinetModal);
  document.getElementById('setWizardCancel').addEventListener('click', closeCabinetModal);
  document.getElementById('setWizardCreate').addEventListener('click', createOrUpdateSetFromWizard);

  if(uiState.roomType){
    document.getElementById('roomsView').style.display='none';
    document.getElementById('appView').style.display='block';
    document.getElementById('topTabs').style.display = 'inline-block';
  } else {
    document.getElementById('roomsView').style.display='block';
    document.getElementById('appView').style.display='none';
    document.getElementById('topTabs').style.display = 'none';
  }

  document.querySelectorAll('.tab-btn').forEach(t=> t.style.background = (t.getAttribute('data-tab') === uiState.activeTab) ? '#e6f7ff' : 'var(--card)');

  renderTopHeight();
  renderCabinets();
  if(uiState.showPriceList){ renderPriceModal(); document.getElementById('priceModal').style.display = 'flex'; }
}



/* init on DOM ready */
document.addEventListener('DOMContentLoaded', initUI);
</script>

<script>
/* ===== robustness layer: keep home usable even if app init fails ===== */
(function(){
  // Create a small error banner (doesn't change layout unless an error happens)
  function ensureBanner(){
    if(document.getElementById('errorBanner')) return;
    const b=document.createElement('div');
    b.id='errorBanner';
    b.style.cssText='position:fixed;left:0;right:0;bottom:0;z-index:99999;padding:10px 12px;background:#fff3cd;border-top:1px solid #ffeeba;color:#856404;font:14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial;display:none';
    b.innerHTML='<span id="errorBannerMsg"></span><button id="errorBannerClose" style="float:right;border:0;background:transparent;font-size:18px;line-height:1;cursor:pointer">√ó</button>';
    document.body.appendChild(b);
    b.querySelector('#errorBannerClose').addEventListener('click', ()=>{ b.style.display='none'; });
  }
  function showBanner(msg, err){
    try{
      ensureBanner();
      const b=document.getElementById('errorBanner');
      const m=document.getElementById('errorBannerMsg');
      const details = err ? (' ‚Äî '+ (err.message||String(err))) : '';
      if(m) m.textContent = msg + details;
      if(b) b.style.display='block';
      console.error(err||msg);
    }catch(e){ /* noop */ }
  }

  // Global runtime error capture (SyntaxError at parse-time can't be caught)
  window.addEventListener('error', (e)=>{ showBanner('B≈ÇƒÖd w aplikacji', e.error||e.message); });
  window.addEventListener('unhandledrejection', (e)=>{ showBanner('Nieobs≈Çu≈ºony b≈ÇƒÖd (Promise)', e.reason); });

  // initUI sometimes doesn't fire reliably in content://. Ensure it runs once.
  function initOnce(){
    if(window.__robustInitDone) return;
    window.__robustInitDone = true;
    try{
      if(typeof initUI === 'function') initUI();
    }catch(err){
      showBanner('B≈ÇƒÖd inicjalizacji ‚Äî strona g≈Ç√≥wna powinna dzia≈Çaƒá', err);
    }
  }

  // Delegated click handler for tiles as a fallback (does NOT change layout)
  function bindHomeFallback(){
    if(window.__homeFallbackBound) return;
    const grid=document.querySelector('.rooms');
    if(!grid) return;
    window.__homeFallbackBound = true;

    grid.addEventListener('click', (ev)=>{
      const tile = ev.target && ev.target.closest ? ev.target.closest('.room-btn') : null;
      if(!tile) return;
      // If normal handlers are attached, let them handle (avoid double navigation)
      if(tile.__hasNativeHandler) return;
      ev.preventDefault();
      const room = tile.getAttribute('data-room');
      if(!room) return;
      try{
        // Mirror original behavior as closely as possible
        if(typeof uiState === 'object'){
          uiState.roomType = room;
          if(typeof FC !== 'undefined' && FC.storage && FC.storage.setJSON && typeof STORAGE_KEYS !== 'undefined'){
            FC.storage.setJSON(STORAGE_KEYS.ui, uiState);
          }
        }
        const rv=document.getElementById('roomsView');
        const av=document.getElementById('appView');
        const tabs=document.getElementById('topTabs');
        if(rv) rv.style.display='none';
        if(av) av.style.display='block';
        if(tabs) tabs.style.display='inline-block';
        if(typeof setActiveTab === 'function') setActiveTab('wywiad');
        if(typeof renderCabinets === 'function') renderCabinets();
        initOnce(); // try to wire the rest (buttons, add, etc.)
      }catch(err){
        showBanner('Nie uda≈Ço siƒô otworzyƒá pokoju', err);
      }
    }, {passive:false});
  }

  // Fallback delegated handler for top tabs (WYWIAD/MATERIA≈Å/CZYNNO≈öCI/WYCENA)
  function bindTopTabsFallback(){
    if(window.__topTabsFallbackBound) return;
    const tabs = document.getElementById('topTabs');
    if(!tabs) return;
    window.__topTabsFallbackBound = true;

    tabs.addEventListener('click', (ev)=>{
      const btn = ev.target && ev.target.closest ? ev.target.closest('button.tab-btn') : null;
      if(!btn) return;
      // If initUI attached handlers, we still allow this; it should be idempotent.
      ev.preventDefault();
      const tab = btn.getAttribute('data-tab');
      if(!tab) return;
      try{
        const rv=document.getElementById('roomsView');
        const av=document.getElementById('appView');
        const tabsEl=document.getElementById('topTabs');
        if(rv) rv.style.display='none';
        if(av) av.style.display='block';
        if(tabsEl) tabsEl.style.display='inline-block';
        if(typeof setActiveTab === 'function') setActiveTab(tab);
        // Some tabs rely on render calls; call safely when available
        if(tab==='wywiad' && typeof renderCabinets === 'function') renderCabinets();
        if(tab==='material' && typeof renderMaterials === 'function') renderMaterials();
        if(tab==='czynnosci' && typeof renderServices === 'function') renderServices();
        if(tab==='wycena' && typeof renderPriceList === 'function') renderPriceList();
        initOnce();
      }catch(err){
        showBanner('B≈ÇƒÖd prze≈ÇƒÖczania zak≈Çadki', err);
      }
    }, {passive:false});
  }

  // Guard: if an overlay/modal-back is left visible while on the home screen, hide it (prevents "dead tiles")
  function ensureNoStuckOverlay(){
    try{
      const rv = document.getElementById('roomsView');
      if(!rv) return;
      const onHome = (rv.style.display !== 'none') && (rv.offsetParent !== null);
      if(!onHome) return;

      let anyHidden = false;
      document.querySelectorAll('.modal-back').forEach(mb=>{
        const disp = getComputedStyle(mb).display;
        if(disp !== 'none'){
          mb.style.display = 'none';
          anyHidden = true;
        }
      });

      if(anyHidden){
        document.documentElement.classList.remove('modal-lock');
        document.body.classList.remove('modal-lock');
      }
    }catch(e){ /* noop */ }
  }


  // Mark tiles that already have native handlers (after initUI binds them)
  function markTilesWithNativeHandlers(){
    try{
      document.querySelectorAll('.room-btn').forEach(btn=>{
        // Heuristic: if click listeners exist we can't detect; mark after initUI by setting flag in wrapper
        // We simply set a flag when user clicks and we detect UI switched; not needed.
      });
    }catch(e){}
  }

  // Run
  const start=()=>{
    bindHomeFallback();
    bindTopTabsFallback();
    ensureNoStuckOverlay();
    initOnce();
    // Watchdog: re-bind fallbacks and clear stuck overlays (Android/WebView can drop handlers/leave overlays)
    setTimeout(()=>{
      bindHomeFallback();
      bindTopTabsFallback();
      ensureNoStuckOverlay();
      if(!window.__robustInitDone) initOnce();
    }, 1200);
  };
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', start, {once:true});
  }else{
    setTimeout(start, 0);
  }
})();
</script>

</body>
</html>